#+TITLE: LSJM Code for accuracy and RT
#+AUTHOR: Jonghyun Yun
#+EMAIL: jonghyun.yun@gmail.com

#+OPTIONS:   H:10 num:nil toc:nil \n:nil @:t ::t |:t ^:nil ^:{} -:t f:t *:t <:t ':nil -:nil pri:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

#+STARTUP: overview inlineimages logdone indent

# #+SETUPFILE: ~/setup/my-theme-readtheorg.setup

#+PROPERTY: header-args :tangle
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args:R :session *R-Org* :exports both :results none :noweb yes :eval never-export
* OrgMode                                                          :noexport:
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
# slide/none/fade/convex/concave/zoom
#+REVEAL_TRANS: slide
# solarized/black/white/league/sky/beige/simple/serif/blood/night/moon
#+REVEAL_THEME: solarized
#+REVEAL_HLEVEL: 1
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_EXTRA_CSS: ./my_reveal_style.css

#+HUGO_BASE_DIR: ~/website
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DATE_FORMAT: %Y-%m-%dT%T%z
#+HUGO_FRONT_MATTER_FORMAT: toml

#+HUGO_SECTION:
#+HUGO_BUNDLE:
#+HUGO_CATEGORIES:

#+HUGO_EXPORT_RMARKDOWN:

#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:t

#+HTML_MATHJAX: align: left tagside: right
#+HTML_MATHJAX: indent: 5em scale: 85
# MATHJAX font: MathJax TeX (default) Asana-Math Neo-Euler Latin-Modern Gyre-Pagella Gyre-Termes
# #+OPTIONS: tex:dvipng # use LaTeX to generate images for equations

#+HTML_HEAD:  <!-- Global site tag (gtag.js) - Google Analytics -->
#+HTML_HEAD:<script async src="https://www.googletagmanager.com/gtag/js?id=UA-128966866-1"></script>
#+HTML_HEAD:<script>
#+HTML_HEAD:  window.dataLayer = window.dataLayer || [];
#+HTML_HEAD:  function gtag(){dataLayer.push(arguments);}
#+HTML_HEAD:  gtag('js', new Date());
#+HTML_HEAD:
#+HTML_HEAD:  gtag('config', 'UA-128966866-1');
#+HTML_HEAD:</script>

# #+HTML_LINK_HOME: http://wweb.uta.edu/faculty/yunj/index.html
# #+HTML_LINK_UP: http://wweb.uta.edu/faculty/yunj/index.html

# https://scripter.co/latex-in-html/
#+macro: latex @@html:<span class="latex">L<sup>a</sup>T<sub>e</sub>X</span>@@

#+BEGIN_SRC emacs-lisp :eval no :exports none :tangle no
(setq org-html-htmlize-output-type 'css)
(setq org-html-htmlize-output-type 'inline-css)
#+END_SRC

#+begin_src emacs-lisp ::eval no results silent :exports none :tangle no
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
(add-hook 'org-mode-hook 'org-display-inline-images)
#+end_src

* LaTeX Header                                                     :noexport:
#+LATEX_CLASS: no-article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]

#+LATEX_COMPILER: xelatex

#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=0.7in,rmargin=0.7in}
#+LATEX_HEADER: \usepackage[stretch=10,babel=true]{microtype}
#+LATEX_HEADER: \usepackage{lmodern}
#+LATEX_HEADER: \setlength\parindent{0pt}\linespread{1.5}
#+LATEX_HEADER: \usepackage[mathbf=sym]{unicode-math}

#+LATEX_HEADER: \setmathfont{latinmodern-math.otf}
#+LATEX_HEADER: \setmathfont{XITS Math}[range={scr,bfscr}]

# #+LATEX_HEADER: \usepackage{amsmath}
# #+LATEX_HEADER: \usepackage{amsbsy}  %\boldsymbol %\pbm (faked bold)

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage[unicode,colorlinks]{hyperref}
# #+LATEX_HEADER: \PassOptionsToPackage{unicode,colorlinks}{hyperref}

# #+LATEX_HEADER: \usepackage[unicode]{hyperref}
# #+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     colorlinks,
# #+LATEX_HEADER:     linkcolor={red!50!black},
# #+LATEX_HEADER:     citecolor={blue!50!black},
# #+LATEX_HEADER:     urlcolor={blue!80!black}}

* References
#+BEGIN_SRC emacs-lisp :eval yes :exports none
(add-hook 'org-export-before-parsing-hook 'orcp-citeproc)
#+END_SRC

#+Bibliography: ~/Zotero/myref.bib
#+PANDOC_OPTIONS: csl:~/Zotero/styles/chicago-author-date.csl

# for html export with bib
# bibliographystyle:unsrt
# bibliography:~/Zotero/myref.bib

#+latex: \begingroup
#+latex: \renewcommand{\section}[2]{}%
#+latex: \printbibliography[sorting=ydnt, heading=none, type=article] % for biblatex, comment out everything else
#+latex: \endgroup
* pseudo code
** Initialize
1. initialize $\lambda_{ic,g}$: I x N x 2
** Update \lambda
1. initialize $\log \lambda_{ic,g}$: I x N x 2
2. for each i,k,c
3. for each j
4. the full conditional:
\begin{align*}
p(\lambda_{ic,j}| \cdot ) \propto & \lambda_{ic,j}^{\sum_{k=1}^{N} Y_{ik,j} = c} \exp[- \lambda_{ic,j} \sum_{k=1}^{N} I(T_{ik} > s_{j-1}) H_{ik,j} \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)]
\pi(\lambda_{ic,j})
\end{align*}
where $H_{ik,j} = \min(T_{ik}, s_{j}) - s_{j-1}$.

*** MH move (direct sampling is doable, dont do this)
1. initialize $\log \lambda_{ic,g}$: I x N x 2
2. for each i,k,c
3. for each j
4. Draw $\lambda_{ic,j}^{* } \sim N(\log \lambda_{ic,j}^{(t)}, jump_{\lambda_{ic,j}})$
5. accept if $r > \log U(0,1)$
\begin{align*}
r = & \prod_{k=1}^{N}
\frac{
   (\lambda_{ic,j}^{* })^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{* }]}
   {(\lambda_{ic,j}^{t})^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{1}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{t}]} \\
& \times
  \frac{J(\lambda_{ic,j}^{(t)} -> \lambda_{ic,g}^{* })}{J(\lambda_{ic,g}^{* } -> \lambda_{ic,g}^{t})}
\frac{\pi(\lambda_{ic,j}^{* })}{\pi(\lambda_{ic,g}^{(t)})} \\
= & \prod_{k=1}^{N}
  \frac{(\lambda_{ic,j}^{* })^{I(Y_{ikc,j} = 1)}}{(\lambda_{ic,j}^{t})^{I(Y_{ikc,j} = 1)}} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)(\sum_{m=1}^{j} H_{ic,m}(\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t}))] \\
& \times
\frac{\pi(\lambda_{ic,j}^{* })}{\pi(\lambda_{ic,j}^{(t)})}
 \frac{J(\lambda_{ic,j}^{(t)} -> \lambda_{ic,j}^{* })}{J(\lambda_{ic,j}^{* } -> \lambda_{ic,j}^{t})};
\end{align*}

if the event occurs before the $j$-th segment (g > j), then $\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t} = 0$ for all $m=1,..,j$, so no contribution in the likelihood part.

** Update \theta
prior: $\theta_{kc} | \sigma^{2} ~ N(0,\sigma^2)$
1. initialize $\theta_{kc}$: N x 2
2. for each k,c
3. Draw $\theta_{kc}^{* } \sim N(\theta_{kc}^{(t)}, jump_{\theta_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{* })}
   \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})} \\
&=
\frac{\exp(\theta_{kc}^{* })}{\exp(\theta_{kc}^{t})}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r = &
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}

** Update \beta
1. initialize $\beta_{ic}$: I x 2
2. for each i,c
3. Draw $\beta_{ic}^{* } \sim N(\\beta_{ic}^{(t)}, jump_{\beta_{ic}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\beta_{ic}^{* })}{\pi(\beta_{ic}^{t})}
   \frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})} \\
&=
\frac{\exp(\beta_{kc}^{* })}{\exp(\beta_{kc}^{t})}
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r =&
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
** Update z
1. initialize $z_{kc}$: N x 2
2. for each k,c
3. Draw $z_{ic}^{* } \sim N(z_{kc}^{(t)}, J_{z_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r =& \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)\Lambda_{ic}(t_{ik})]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{(t)} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{(t)} - w_{i}||)\Lambda_{ic}(t_{ik}) ]
} \\
& \times
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{(t)})}
   \frac{J(z_{kc}^{(t)} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{(t)})} \\
=&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{(t)})}
# \frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}
\exp[-\gamma_{c}\sum_{i=1}^{I}
(||z_{kc}^{* } - w_{i}||-||z_{kc}^{(t)} - w_{i}||)]\\
&\times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t_ik)\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{(t)} - w_{i}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r =&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{t})}
\frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}\\
& \times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t_{ik})\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{(t)} - w_{i}||)\}]
\end{align*}
** Update w
1. initialize $w_{i}$: I
2. for each I
3. Draw $w_{i}^{* } \sim N(\w_i^{(t)}, jump_{w_i})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r = &\prod_{c=1}^{2} \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)\Lambda_{ic}(t) ]
}
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
   \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
# \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[\sum_{c=1}^{2}\sum_{k=1}^{N} \gamma_{c}
(||z_{kc} - w_{i}^{* }||-||z_{kc} - w_{i}^{t}||)] \\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r & =
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}\\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}

** Update gamma
1. initialize $\gamma_{c}$: 2
2. for each c
3. Draw $\gamma_{c}^{* } \sim \log N(\log \gamma_{c}^{(t)}, jump_{\gamma_{c}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r = & \prod_{i=1}^{I}\prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\gamma_{c}^{* })}{\pi(\gamma_c^{t})}
   \frac{J(\gamma_{c}^{t} -> \gamma_{c}^{* })}{J(\gamma_{c}^{* } -> \gamma_{c}^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[\sum_{i=1}^{I}\sum_{k=1}^{N} ||z_{kc} - w_{i}||(\gamma_{c}^{t}-\gamma_{c}^{* })]\\
& \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t)\exp(\beta_{ic} + \theta_{kc}) \{\exp( - \gamma_{c}^{* } ||z_{kc} - w_{i}||) -
 \exp( -\gamma_{c}^{t} ||z_{kc} - w_{i}||)\}]
\end{align*}

if $Y_{ikc} = 1$; otherwise
\begin{align*}
r = &
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}\\
& \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t)\exp(\beta_{ic} + \theta_{kc}) \{\exp( - \gamma_{c}^{* } ||z_{kc} - w_{i}||) -
 \exp( -\gamma_{c}^{t} ||z_{kc} - w_{i}||)\}]
\end{align*}

** update \sigma^2
prior: $\sigma^{2} \sim inv-gamma(a,b)$
target: $\prod_{k,c} N(\theta_{kc}|0,\sigma^{2}) inv-gamma(\sigma^{2}|a,b)$ -> normal-(inv-gamma) model

1. initialize $\sigma^{2}$
2. Draw $\sigma^{2} \sim inv-Gamma(a + N, b + \sum_{k,c} \theta_{kc}^{2} / 2)$
* LSJM prior
\begin{aligned} \pi\left(\beta_{i}\right) & \sim \mathrm{N}\left(0, \tau_{\beta}^{2}\right) \\ \pi\left(\theta_{j} | \sigma^{2}\right) & \sim \mathrm{N}\left(0, \sigma^{2}\right) \\ \pi\left(\sigma^{2}\right) & \sim \operatorname{lnv}-\operatorname{Gamma}\left(a_{\sigma}, b_{\sigma}\right) \\ \pi\left(\mathbf{z}_{j}\right) & \sim \mathrm{MVN}_{d}\left(0, I_{d}\right) \\ \pi\left(\mathbf{w}_{i}\right) & \sim \mathrm{MVN}_{d}\left(0, I_{d}\right) \\ \log \pi(\gamma) & \sim \mathrm{N}\left(\mu_{\gamma}, \tau_{\gamma}^{2}\right) \end{aligned}

\[\sigma^{2}=4, \tau_{\beta}^{2}=1, a_{\sigma}=1, b_{\sigma}=1, \mu_{\gamma}=0, \text { and } \tau_{\gamma}^{2}=1\]
* PISA2015 data
** pisa2015/README.txt
- pisa2015: math
#+BEGIN_SRC sh :results output
cat ../pisa2015/README.txt
#+END_SRC

** notebook
#+BEGIN_SRC R
source('R/pisa-preprocess.R')
source('R/pisa-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-preprocess.R
## pick_person = 1:592
pick_person = 1:592
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/pisa2015/US_PISA2015.rdata")
df = as_tibble(US_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+END_SRC

#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :tangle R/art-functions.R
pullit = function(info,cl) {
  it = info %>% filter(Cluster_A == cl)# %>% dplyr::select(Item,Time)
  item = pull(it,Item)
  time = pull(it,Time)
  return(cbind(item,time))
}
#+end_src

#+begin_src R :results none :tangle R/pisa-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

di01 = di01[pick_person,pick_item]
dt01 = dt01[pick_person,pick_item]
#+end_src

** boxplot :ARCHIVE:
#+BEGIN_SRC R
library(reshape2)

di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+END_SRC

#+BEGIN_SRC R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 99))
#+END_SRC

#+BEGIN_SRC R
rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01, aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
#+END_SRC

[[file:figure/RTs_S01.pdf]]

#+BEGIN_SRC R
pdf("figure/RTs_S01.pdf")
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC
** numeric ID
#+BEGIN_SRC R :tangle R/art-functions.R
tabulate_id = function(chrid) {
  ## reference table of charactor and numeric id
  chr = sort(unique(chrid))
  out = data.frame(chr = chr, num = 1:length(chr))
  return(out)
}
to_numID = function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID = function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+END_SRC

#+begin_src R :tangle R/pisa-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
*** To export long format data for STAN
#+begin_src R
library(survival)
status = !(dit01$res == 99)

tmp <- survival::survSplit(formula = Surv(time, status) ~ ., data = dit01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         len = time - tstart,
         status_T = 1 * (status == 1 & res == 1),
         status_F = 1 * (status == 1 & res == 0)
         ) %>%
  as_tibble
to_stan = tmp %>% mutate(seg_g = seg_g - 1) %>% dplyr::select(stuid, item, time, seg_g, len, status_F, status_T)
## tmp %>% dplyr::select(res,status,status_T,status_F)
#+end_src

#+begin_src R
## data and fixed parameters
I = nrow(tab_item)
N = nrow(tab_stuid)
C = 2

L = nrow(to_stan)
G = ncut

with(to_stan,
     rstan::stan_rdump(c('I','N','C','L','G','stuid','item', 'G', 'seg_g','len','status_F','status_T'),"pisa_data.R"))

#+end_src

*** To export short format data for STAN

#+BEGIN_SRC R
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)
tt01 = data.frame(time = c(as.matrix(tt01)), status = 1)

tmp <- survival::survSplit(formula = survival::Surv(time, status) ~ ., data = tt01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 1,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+begin_src R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2

G = ncut + 1

rstan::stan_rdump(c('I','N','C','G', 'mseg','mlen', 'mh', 'mt','mi'),"pisa_short.R")

#+end_src

*** to export short format data for C++
#+BEGIN_SRC R :tangle R/pisa-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** not used
#+BEGIN_SRC R
item <- pull(info, Item)
time <- pull(info, Time)
cname <- colnames(df)
#+END_SRC

#+begin_src R
item = item[info$Cluster_A == "S01"]
time = time[info$Cluster_A == "S01"]
yi = df[,cname %in% item]
yt = df[,cname %in% time]

idx = !apply(yi,1,function(x) all(is.na(x)))
yi = yi[idx,]
yt = yt[idx,]
yi[is.na(yi)] = 99
yi[yi == 2] = 1
#+end_src


#+BEGIN_SRC R
boxplot(yt)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* opusIII-matrices-data.dat
#+BEGIN_SRC R
source("R/opusIII-preprocess.R")
source("R/opusIII-init.R")

#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
num_person = 504 ## max 504: do not change
num_item =35 ## max 35

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
opusIII = readr::read_delim("data/opusIII-matrices-data.dat"," ")
df = as_tibble(opusIII[,-1])[,1:4] ## drop row names
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

** knot selection
#+begin_src R :tangle R/opusIII-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/opusIII-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/opusIII-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src
** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/opusIII-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** boxplot
#+BEGIN_SRC R :results value :tangle R/opusIII-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(id_ = 1:num_item)
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/opusIII_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* verbalIntelligence.dat

#+BEGIN_SRC R :results none :tangle no :results output :session
source("R/verbal-preprocess.R")
source("R/verbal-init.R")
#+END_SRC

#+BEGIN_SRC R :tangle R/verbal-preprocess.R
num_person = 726 ## max 726: do not change
num_item = 34 ## max 34

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
verbal = readr::read_delim("data/verbalIntelligence.dat"," ")
df = as_tibble(verbal[,-1])[,1:4] ## drop row names
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(685,137,610,724,703)])
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(680,629,600,691,601)])
#+END_SRC

** knot selection
#+begin_src R :tangle R/verbal-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-functions.R
tab_sj = function(seg_g, G) {
  res = NULL
  for (m in 0:(G-1)) {
    res = c(res, sum(seg_g >= m))
  }
  return(res)
}

tab_IY = function(seg_g, G) {
  res = NULL
  for (m in 0:(G-1)) {
    res = c(res, sum(seg_g == m))
  }
  return(res)
}
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/verbal-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/verbal-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/verbal-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/verbal-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/verbal-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/verbal_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Marketing
** description

Here is the description of the dataset: Each row of the data represents one fixation.  The duration of the fixation is given by the column labeled "event_duration" and is in units of milliseconds.  The variable ~choice~ indicates the choice that the subject made in that trial, 1 is left and 0 is right. The variable "roi" indicates whether the fixation was to the left ("1) or the right ("2").  The variable ~rt~ is the reaction time for the trial. "fix_num" is the number of the fixation within the trial, with 1 being first fixation, 2 being second fixation etc.  Similarly, "rev_fix_num" is the number of the fixation but going backwards from the last fixation, so 1 is the last fixation, 2 is the second-to-last fixation, etc.

Please ignore the variables "corr_fix_duration", "computed_rt" and "temp", I either did not end up using those or they were temporary variables.

## processing model for choice (left or right)
- 1: subject: person
- 2: trial: item
- 7: rt: response time
- 8: choice; response

#+BEGIN_SRC R
source("R/marketing-preprocess.R")
source("R/marketing-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
df <- foreign::read.dta("data/fixations_final.dta")[,c(1,2,8,7)] %>% as_tibble %>% distinct
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

* Smith and Krajbich                                                 :ATTACH:
:PROPERTIES:
:ID:       d0a1e4f9-326e-4950-8d12-d805efe8950a
:END:
[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;1][In the two-food task (Figure 1b), subjects were presented with two previously rated food items, one on each side of the computer screen, and asked to choose the one they would like to eat most at the end of the experiment. Only positively rated (i.e., rating 0) food items were included in this task, to ensure that subjects were choosing between items that were relevant to them. These posi tively rated items were randomly selected, subject to the con straints that (a) no item could be shown more than seven times and (b) the value difference between the items could not exceed five.]]

[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;2][Many subjects (two-food: n  22; food-risk: n  39) did not have enough positively rated food items to generate 200 valid trials in each of the food choice tasks, so these subjects completed as many constraint-satisfying trials as were generated (two-food: M  171.3; food-risk: M  146.7). In the food tasks, we limited the difference in value between the options in order to increase the experiments efficiency by focusing on trials with nontrivial decisions. This also facilitates the model fitting procedure, which relies on the RT distributions of correct and error choices.]]

** description
[[mu4e:msgid:15884427-B662-4EF9-A15A-EA609676DECF@g.ucla.edu][Re: new marketing data]]
[[mu4e:msgid:D5AF8D06-A080-44CA-96F7-386165ED972F@g.ucla.edu][new marketing data]]

It should be formatted similarly to the previous one. Each row is a fixation/dwell.  A few notes:
"LeftRight" - 1 is left, 2 is right
"ROI" - 1 is left, 2 is right
"DwellLength" is the duration of the dwell/fixation in seconds

You can also see that there are columns for the names of the snack foods in each trial.  If you need more information than this, let me know.  I could provide you with a link to the images of the items.  You would just need to link the images to the names.

LeftRight is the choice variable - 1 means left choice, 2 means right choice
FoodLeft and FoodRight are just unique food identifiers.  They should be redundant with the food names.
ValueLeft and ValueRight are the independent ratings of the foods on the left and right.  Subjects should generally be choosing the item with the higher value.
DwellLength is the fixation/dwell time for that particular fixation/dwell. The units are seconds.

*Plan*: "correctness" is defined by the choice of higher valued food. Exclude cases with the same valued food. "item" is defined using the value difference (not exceed 5).

#+BEGIN_SRC R
source("R/twofood-preprocess.R")
source("R/twofood-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
load("data/SmithKrajbich2018.RData")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
df = data %>% select(SubjectNumber, LeftRight, RT, ValueLeft, ValueRight)
df = distinct(df)
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

* Chess proficiency                                                  :ATTACH:
:PROPERTIES:
:ID:       aaa8e8c6-ea9b-47b0-8901-047b0388e662
:END:
[[mu4e:msgid:380ABC3A-4965-4B3A-9B29-D3F370AAF0E8@g.ucla.edu][New data - chess proficiency]]

** description

- Choose-a-move test A (test B is a parallel version of A)
  A1 - A40: 1 if correct (the correct answer is vastly superior to all other legal moves)
  AR1 - AR40: RT (< 30s; or no response)
  1-20: tactical items
  21-30: positional items
  31-40: endgame items
  Item difficulty increased within each set
  Missingness in RT -> should be excluded

- Predict-a-move test
  items are related. no unique solution. points of merit on a scale from 0 to 5.

#+BEGIN_SRC R
source("R/chess-preprocess.R")
source("R/chess-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+END_SRC

#+BEGIN_SRC R :tangle R/chess-preprocess.R
dt = cbind(PPNR, chess[,grepl("AR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("A[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/chess-preprocess.R
time = pull(dit, RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/chess-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/chess-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/chess-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot
#+BEGIN_SRC R :results value :tangle R/chess-preprocess.R
dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/chess-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** Choose-a-move test B
*** description

#+BEGIN_SRC R
source("R/chessB-preprocess.R")
source("R/chessB-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+END_SRC

#+BEGIN_SRC R :tangle R/chessB-preprocess.R
dt = cbind(PPNR, chess[,grepl("BR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("B[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+END_SRC

*** knot selection
#+begin_src R :tangle R/chessB-preprocess.R
time = pull(dit, RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

*** survSplit
#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/chessB-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/chessB-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

*** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

*** init
#+BEGIN_SRC R :results none :tangle R/chessB-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: pp Gamma(0) = 1, Gamma(1) = 1
#+BEGIN_SRC R :results none :tangle R/chessB_pp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_pp-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: np (default) Gamma(0) = -1, Gamma(1) = 1
#+BEGIN_SRC R :results none :tangle R/chessB_np-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, 1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_np-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: nn Gamma(0) = -1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/chessB_nn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_nn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: pn Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/chessB_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Duolingo
#+BEGIN_SRC R :results none :tangle no :results output :session
source("R/duolingo-preprocess.R")
source("R/duolingo-init.R")
#+END_SRC

#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
num_person = 726 ## max 726: do not change
num_item = 34 ## max 34

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
duolingo = readr::read_csv("data/duolingo_final.csv")
df = as_tibble(duolingo[,-1])[,1:4] ## drop row names
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(685,137,610,724,703)])
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(680,629,600,691,601)])
#+END_SRC

** knot selection
#+begin_src R :tangle R/duolingo-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-functions.R
tab_sj = function(seg_g, G) {
  res = NULL
  for (m in 0:(G-1)) {
    res = c(res, sum(seg_g >= m))
  }
  return(res)
}

tab_IY = function(seg_g, G) {
  res = NULL
  for (m in 0:(G-1)) {
    res = c(res, sum(seg_g == m))
  }
  return(res)
}
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/duolingo-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/duolingo-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/duolingo-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/duolingo_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* MATH: Korea_PISA2015
** notebook
#+BEGIN_SRC R
source('R/pisa-KR-preprocess.R')
source('R/pisa-KR-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-preprocess.R
## pick_person = 1:615
pick_person = 1:615
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/Korea_PISA2015.rdata")
df = as_tibble(Korea_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+END_SRC

#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :results none :tangle R/pisa-KR-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

## exclude no person / no item
## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+BEGIN_SRC R :tangle R/art-functions.R
tabulate_id = function(chrid) {
  ## reference table of charactor and numeric id
  chr = sort(unique(chrid))
  out = data.frame(chr = chr, num = 1:length(chr))
  return(out)
}
to_numID = function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID = function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+END_SRC

#+begin_src R :tangle R/pisa-KR-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-KR-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-KR-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-KR-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Science: Korea_PISA2018
** notebook
#+BEGIN_SRC R
source('R/pisa-KR-sci2018-preprocess.R')
source('R/pisa-KR-sci2018-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-preprocess.R
## pick_person = 1:798
pick_person = 1:798
## pick_item = 1:23 # (it seems like the first cluster)
pick_item = 1:23

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-preprocess.R
load("data/Korea_PISA2018.rdata")
df = as_tibble(Korea_2018)
## info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
## polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
## pdx = which(colnames(df) %in% polytomous)
## pdx = c(pdx,pdx + 184)
## df[,-pdx]
#+END_SRC


#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :results none :tangle R/pisa-KR-sci2018-preprocess.R
di = df[,1:(115 + 3)]
dt = df[,c(1:3,(115+4):233)]
its = c()
dt01 = dt[,pick_item] %>% na.omit
di01 = di[,pick_item] %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[is.na(di01)] = 999
di01[di01 == 2] = 1

## drop plytomous
di01 = di01[,-c(11,14,15)]
dt01 = dt01[,-c(11,14,15)]

## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** boxplot

#+BEGIN_SRC R :results value :tangle R/pisa-KR-sci2018-preprocess.R
di01_long <- reshape2::melt(di01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- reshape2::melt(dt01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+END_SRC

#+BEGIN_SRC R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 999))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
pdf("figure/boxplot_ART.pdf")
## rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
## geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01[,4:6], aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
## print(rt_boxp)
print(logrt_boxp)
dev.off(which = dev.cur())
#+END_SRC

* C++ MCMC output
** Shell to run C++
#+begin_src sh :tangle run.sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=6
mkdir -p output
rm output/*
Rscript "R/opusIII-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/

for v in {1..3}
do
    Rscript "R/opusIII_pn-init.R"
    ./main initialize parallel single_w single_z sparse latent no_gamma true $v 10000 10000 10
done
mv output opusIII_pn
Rscript R/run-analysis.R opusIII_pn/

rm output/*
Rscript "R/verbal-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/

for v in {1..3}
do
    Rscript "R/verbal_pn-init.R"
    ./main initialize parallel single_w single_z sparse latent no_gamma true $v 10000 10000 10
done
mv output verbal_pn
Rscript R/run-analysis.R verbal_pn/
#+END_SRC

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=6
mkdir -p output
# rm output/*
# Rscript "R/chessB-preprocess.R"
# cp input/{mvar,mlen}.csv output/
# cp run.sh output/

# for v in {1..3}
# do
#     Rscript "R/chessB_pn-init.R"
#     ./main initialize parallel single_w single_z full latent no_gamma true $v 10000 10000 10
# done
# mv output chessB_pn
# Rscript R/run-analysis.R chessB_pn/

rm output/*
Rscript "R/chessB-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/

for v in {1..3}
do
    Rscript "R/chessB_nn-init.R"
    ./main initialize parallel single_w single_z full latent no_gamma true $v 10000 10000 10
done
mv output chessB_nn
Rscript R/run-analysis.R chessB_nn/

#+END_SRC

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=6
mkdir -p output
rm output/*
Rscript "R/chessB-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/chessB-init.R"
    ./main initialize parallel single_w single_z full latent no_gamma true $v 10000 10000 10
done
mv output chessB
Rscript R/run-analysis.R chessB/
#+END_SRC

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=6
mkdir -p output
rm output/*
Rscript "R/chess-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/chess-init.R"
    ./main initialize parallel single_w single_z full latent no_gamma $v 10000 10000 10
done
mv output chess-singleZ-singleW
#+END_SRC

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=6
mkdir -p output
rm output/*
Rscript "R/marketing-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/marketing-init.R"
    ./main initialize parallel single_w single_z sparse latent no_gamma $v 10000 10000 10
done
mv output marketing-singleZ-singleW
#+END_SRC

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=11
mkdir -p output
rm output/*
Rscript "R/pisa-KR-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/pisa-KR-init.R"
    ./main initialize parallel single_w single_z full latent no_gamma $v 10000 10000 10
done
mv output pisa-KR-singleZ-singleW
#+end_src

#+begin_src sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=10

mkdir -p output
rm -r output/*

rsync -rv pisa-KR-sci2018-singleZ-singleW/ output

Rscript R/pisa-KR-sci2018-preprocess.R
cp input/{mvar,mlen}.csv output/

touch output/run_hist.sh
cat run.sh >> output/run_hist.sh

for v in {1..3}
do
    ./main continue parallel single_w single_z full latent no_gamma $v 10000 10 10
done
rsync -rv output/ pisa-KR-sci2018-singleZ-singleW

mkdir -p output
rm -r output/*

rsync -rv pisa-KR-singleZ-singleW/ output

Rscript R/pisa-KR-preprocess.R
cp input/{mvar,mlen}.csv output/

touch output/run_hist.sh
cat run.sh >> output/run_hist.sh

for v in {1..3}
do
    ./main continue parallel single_w single_z full latent no_gamma $v 10000 10 10
done
rsync -rv output/ pisa-KR-singleZ-singleW
#+end_src

#+begin_src sh
export STAN_NUM_THREADS=6

mkdir -p output
rm output/*
Rscript "R/pisa-KR-sci2018-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/pisa-KR-sci2018-init.R"
    ./main initialize parallel single_w single_z full latent no_gamma $v 10000 10000 10
done
mv output pisa-KR-sci2018-singleZ-singleW
#+end_src

#+begin_src sh
mkdir -p output
rm output/*
Rscript "R/pisa-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/pisa-init.R"
    ./main parallel single_w single_z full latent no_gamma $v 10000 10000 10
done
mv output pisa-singleZ-singleW

rm output/*
mkdir -p output
Rscript "R/verbal-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/verbal-init.R"
    ./main parallel single_w single_z sparse latent no_gamma $v 10000 10000 10
done
mv output verbal-singleZ-singleW

rm output/*
mkdir -p output
Rscript "R/opusIII-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/
for v in {1..3}
do
    Rscript "R/opusIII-init.R"
    ./main parallel single_w single_z sparse latent no_gamma $v 10000 10000 10
done
mv output opusIII-singleZ-singleW
#+end_src

** Using R
#+BEGIN_SRC R :tangle R/run-analysis.R
#!/usr/bin/env Rscript
args = commandArgs(trailingOnly=TRUE)
# test if there is at least one argument: if not, return an error
if (length(args)==0) {
  stop("At least one argument must be supplied (input file).n", call.=FALSE)
} else if (length(args)==1) {
  # default output file
  HAS_REF = 0;
  ref_dir = ""
}
out_dir = args[1]
num_chain = 3; double_z = 0; double_w = 0;
## out_dir = "chessB-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir = "chessB_pn/"
num_chain = 3; double_z = 0; double_w = 0; HAS_REF = 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
## system(paste0("mkdir -p ", out_dir, "figure/"))
## system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir = "verbal_pn/"
num_chain = 3; double_z = 0; double_w = 0; HAS_REF = 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
## system(paste0("mkdir -p ", out_dir, "figure/"))
## system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir = "opusIII_pn/"
num_chain = 3; double_z = 0; double_w = 0; HAS_REF = 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
## system(paste0("mkdir -p ", out_dir, "figure/"))
## system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir = "pisa-KR-sci2018-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))

ref_dir = "pisa-singleZ-singleW/"
HAS_REF = 1

out_dir = "pisa-KR-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))

HAS_REF = 0
#+END_SRC

#+BEGIN_SRC R
num_chain = 3; double_z = 0; double_w = 0;

out_dir = "pisa-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mv figure/*.pdf ", out_dir,"figure/"))

out_dir = "opusIII-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("mv figure/*.pdf figure/",out_dir))

out_dir = "verbal-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("mv figure/*.pdf figure/",out_dir))
#+END_SRC

#+begin_src R
## install.packages("coda")
install.packages("dplyr")
install.packages("stringr")
install.packages("magrittr")
install.packages("bayesplot")
install.packages("foreach")
install.packages("doParallel")
install.packages("reshape2")
install.packages("readr")
install.packages("data.table")
install.packages("survival")
#+end_src

#+begin_src R
install.packages(c("ggplot2","ggrepel","fda","funFEM"))                 
#+end_src

#+BEGIN_SRC R :results none
## Rcpp::sourceCpp("comprisk.cpp")
install.packages("art_1.0.tar.gz", repos = NULL, type="source")
detach(package:art)
library(art)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-analysis.R
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
##registerDoParallel(cores = detectCores() - 1)
registerDoParallel(6)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-analysis.R
source('R/load-outputs.R')
## source('R/write_summary.R')
source('R/visual-latent-space-plot.R')
source('R/visual-trace-plot.R')
source('R/CIF_posm.R')
source('R/CIF.R')
#+END_SRC

print average acceptance rate per type of quantities: \lambda, \beta, \theta, z, w, \gamma, \sigma
#+BEGIN_SRC sh
cat output/summary.csv
#+END_SRC
** example to extract w0 and z0
#+begin_src R
out_dir = "chessB_pn/"
num_chain = 3; double_z = 0; double_w = 0; HAS_REF = 0;

library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
##registerDoParallel(cores = detectCores() - 1)
registerDoParallel(6)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
source("R/load-outputs.R")

z0 = matched$z0
w0 = matched$w0

readr::write_csv(as.data.frame(w0), paste0(out_dir, "w0.csv"))
readr::write_csv(as.data.frame(z0), paste0(out_dir, "z0.csv"))
#+end_src

** load outputs
#+begin_src R :tangle R/load-outputs.R
mvar = readr::read_csv(paste0(out_dir,"mvar.csv"), col_names=F) %>% as.matrix()
I = mvar[1]
N = mvar[2]
G = mvar[4]

sj = readr::read_csv(paste0(out_dir,"mlen.csv"),col_names=F) %>% as.matrix()
sj = c(0, cumsum(sj))
H = sj[2:(G+1)] - sj[1:G]

cnames = c(".chain", ".iteration")
for (c in 0:1) {
  for (i in 1:I) {
    for (g in 1:G) {
      cnames = c(cnames, paste0("lambda.",c,".",i,".",g))
    }}}

for (k in 1:N) {
  for (c in 0:1) {
    cnames = c(cnames, paste0("theta.",k,".",c))
  }}
for (i in 1:I) {
  for (c in 0:1) {
    cnames = c(cnames, paste0("beta.",i,".",c))
  }}

for(c in 0:1) {
  for (k in 1:N) {
    for (d in 1:2) {
      cnames = c(cnames, paste0("z.",c,".",k,".",d))
    }}
}
for (c in 0:1) {
  for (i in 1:I) {
    for (d in 1:2) {
      cnames = c(cnames, paste0("w.",c,".",i,".",d))
    }}}

for (c in 0:1) {
  cnames = c(cnames, paste0("gamma.",c))
}

cnames = c(cnames, "sigma", "lp_")
#+end_src

#+BEGIN_SRC R :tangle R/load-outputs.R
## mythin = 10
## mystart = 5001
## myend = 25000

no_z1 = !grepl("^z\\.1\\.", cnames)
no_w1 = !grepl("^w\\.1\\.", cnames)

dlist = list()
for (cid in 1:num_chain) {
  ## pisa-KR KR-sci data should skip 1000
  dlist[[cid]] = readr::read_csv(paste0(out_dir,"sample_chain",cid,".csv"), col_names=F, skip=0) %>% as.data.frame()
  ##dlist[[cid]] = readr::read_csv(paste0(out_dir,"sample_chain",cid,".csv"), col_names=F) %>% as.data.frame()
  colnames(dlist[[cid]]) = cnames
  if (!double_z && !double_w) {
    dlist[[cid]] = dlist[[cid]][,no_z1 & no_w1] ## remove duplicates when single_z and single_w
  } else if (!double_w) {
    dlist[[cid]] = dlist[[cid]][,no_w1] ## remove duplicates when single_w
  } else if (!double_z) {
    dlist[[cid]] = dlist[[cid]][,no_z1] ## remove duplicates when single_z
  }
}

## mylist[[cid]] = mcmc(df, start = mystart, end = myend, thin = mythin)
#+END_SRC


#+BEGIN_SRC R :tangle R/art-functions.R
my_procrustes = function(Xstar, dlist, is_list = FALSE, translation = TRUE, scale = FALSE, reflect = TRUE) {
  posm = 0
  if (is_list == TRUE) {
    num_chain = length(dlist)
  } else { num_chain = 1 }
  for (i in 1:num_chain) {
    if (is_list == TRUE) { df = dlist[[i]]
    } else { df = dlist }

    num_samples = nrow(df)

    z0dx = grepl("^z\\.0\\.", colnames(df))
    z1dx = grepl("^z\\.1\\.", colnames(df))
    w0dx = grepl("^w\\.0\\.", colnames(df))
    w1dx = grepl("^w\\.1\\.", colnames(df))

    no_z1 = sum(z1dx) == 0
    no_w1 = sum(w1dx) == 0

    num_w = sum(w0dx) / 2;
    num_z = sum(z0dx) / 2;
    w0 = aperm( array(unlist( t(df[,w0dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
    z0 = aperm( array(unlist( t(df[,z0dx])), dim = c(2, num_z, num_samples)), c(2,1,3))

    w0star = Xstar$w.0

    if (no_w1) {
      w1 = NULL
    } else {
      w1star = MCMCpack::procrustes(Xstar$w.1, w0star)$X.new
      w1 = aperm( array(unlist( t(df[,w1dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
    }
    if (no_z1) {
      z1 = NULL
    } else {
      z1 = aperm( array(unlist( t(df[,z1dx])), dim = c(2, num_z, num_samples)), c(2,1,3))
    }

    adx = z0dx | z1dx | w0dx | w1dx

    mm = foreach (k = 1:num_samples) %dopar% {
      pout = MCMCpack::procrustes(w0[,,k], w0star)
      w0[,,k] = pout$X.new
      z0[,,k] = z0[,,k] %*% pout$R

      if (!no_w1) {
        pout = MCMCpack::procrustes(w1[,,k], w1star)
        w1[,,k] = pout$X.new
      }
      if (!no_z1) {
        z1[,,k] = z1[,,k] %*% pout$R
      }
      rbind(z0[,,k], z1[,,k], w0[,,k], w1[,,k])
    }
    tmm = lapply(mm,t)
    df[,adx] = t( matrix(unlist(tmm), nrow = sum(adx)) )

    posm = posm + Reduce("+",mm) / num_samples
    if (is_list == TRUE) { dlist[[i]] = df
    } else { dlist = df }
  }

  posm = posm / num_chain
  z0 = posm[1:num_z,]
  if (no_z1 && no_w1) {
    w0 = posm[num_z + (1:num_w),]
  } else if (no_z1 && !no_w1) {
    w0 = posm[num_z + (1:num_w),]
    w1 = posm[num_z + num_w + (1:num_w),]
  }

  if (!no_z1 && no_w1) {
    z1 = posm[num_z + (1:num_z),]
    w0 = posm[2*num_z + (1:num_w),]
  } else if (!no_z1 && !no_w1) {
    z1 = posm[num_z + (1:num_z),]
    w0 = posm[2*num_z + (1:num_w),]
    w1 = posm[2*num_z + num_w + (1:num_w),]
  }
  return(list(dlist = dlist, z0=z0, z1=z1, w0=w0, w1=w1))
}
#+END_SRC

#+begin_src R :results none :tangle R/load-outputs.R
if (!HAS_REF) {
  Xstar = find_xstar_inlist(dlist)
  readr::write_csv(as.data.frame(Xstar$z.0), paste0(out_dir, "z0star.csv"), col_names = FALSE)
  readr::write_csv(as.data.frame(Xstar$w.0), paste0(out_dir, "w0star.csv"), col_names = FALSE)
}
#+end_src

#+begin_src R :results none :tangle R/load-outputs.R
if (HAS_REF) {
  Xstar = list()
  Xstar$z.0 = readr::read_csv(paste0(ref_dir, "z0star.csv"), col_names = FALSE) %>% as.matrix()
  Xstar$w.0 = readr::read_csv(paste0(ref_dir, "w0star.csv"), col_names = FALSE) %>% as.matrix()
}
#+end_src

#+BEGIN_SRC R :tangle R/load-outputs.R
matched = my_procrustes(Xstar, dlist, is_list = T)
mydf = matched$dlist
mdf = bind_rows(matched$dlist, .id = "column_label")
#+END_SRC

#+BEGIN_SRC R :tangle R/load-outputs.R
mylist = mcmc.list()
item = 1
cname = names(mydf[[1]])
mylist = mcmc.list()
for (cid in 1:num_chain) {
  for (c in 0:1) {
    for (k in 1:N) {
      z = mydf[[cid]][,str_which(cname, paste0("z\\.",c * double_z,"\\.",k,"\\.[1-2]"))]
      w = mydf[[cid]][,str_which(cname, paste0("w\\.",c * double_w,"\\.",item,"\\."))]
      mydf[[cid]][[paste0("dist_z.",c,".",k,"_","w.",c,".",item)]] = sqrt(rowSums((z-w)^2))
    }}
  mylist[[cid]] = mcmc(mydf[[cid]])
}
#+END_SRC

The posterior means of \beta, \theta, \lambda are exported to CSV files.
#+begin_src R :tangle R/write_summary.R
ss = summary(mylist)
mm = ss$statistics[,"Mean"]
rr = c(grep("^beta",  names(mm)), grep("^theta",  names(mm)))
dout = data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "beta_theta_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr = grep("^lambda",  names(mm))
dout = data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "lambda_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr = grep("^^z\\.0\\.",  names(mm))
dout = data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "z0_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr = grep("^^z\\.0\\.",  names(mm))
dout = data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "z0_mean.csv"))
#+end_src

#+BEGIN_SRC R :results none
## sink("output/mcmc_summary.txt")
cat("==================================")
cat("Rejection Rate")
cat("==================================")
rejectionRate(mylist)
cat("==================================")
cat("Effective Size")
cat("==================================")
effectiveSize(mylist)
cat("==================================")
cat("Summary")
cat("==================================")
summary(mylist)
## sink()
#+END_SRC

** latent space

HPD based latent plot
[[pdf:figure/latent_space_hpd.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
mcdf = mcmc(mdf[,-1])
tn = nrow(mcdf)
hpd = apply(HPDinterval(mcdf, prob = 1/tn), 1, median)

z0dx = grepl("^z\\.0\\.", names(hpd))
z1dx = grepl("^z\\.1\\.", names(hpd))
w0dx = grepl("^w\\.0\\.", names(hpd))
w1dx = grepl("^w\\.1\\.", names(hpd))

num_w = sum(w0dx) / 2;
num_z = sum(z0dx) / 2;

no_z1 = sum(z1dx) == 0
no_w1 = sum(w1dx) == 0
w0 = matrix(hpd[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 = NULL
} else w1 = matrix(hpd[w1dx], byrow = T, nrow = num_w, ncol = 2)
if (no_z1) {
  z1 = NULL
} else z1 = matrix(hpd[z1dx], byrow = T, nrow = num_z, ncol = 2)

z0 = matrix(hpd[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])
myname = c(1:N,paste0("I.",1:I))

pdf("figure/latent_space_hpd.pdf")
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/latent_space_med.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
med = apply(mdf[,-1] , 2, median)

z0dx = grepl("^z\\.0\\.", names(med))
z1dx = grepl("^z\\.1\\.", names(med))
w0dx = grepl("^w\\.0\\.", names(med))
w1dx = grepl("^w\\.1\\.", names(med))

num_w = sum(w0dx) / 2;
num_z = sum(z0dx) / 2;

no_z1 = sum(z1dx) == 0
no_w1 = sum(w1dx) == 0
w0 = matrix(med[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 = NULL
} else w1 = matrix(med[w1dx], byrow = T, nrow = num_w, ncol = 2)
if (no_z1) {
  z1 = NULL
} else z1 = matrix(med[z1dx], byrow = T, nrow = num_z, ncol = 2)

z0 = matrix(med[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])
myname = c(1:N,paste0("I.",1:I))

pdf("figure/latent_space_med.pdf")
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+END_SRC


[[file:figure/latent_space_mode.pdf]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
if (!HAS_REF) {
  z0.star = Xstar$z.0
  z1.star = Xstar$z.1
  w0.star = Xstar$w.0
  w1.star = Xstar$w.1

  xmin = min(z0.star[,1],z1.star[,1],w0.star[,1],w1.star[,1])
  ymin = min(z0.star[,2],z1.star[,2],w0.star[,2],w1.star[,2])
  xmax = max(z0.star[,1],z1.star[,1],w0.star[,1],w1.star[,1])
  ymax = max(z0.star[,2],z1.star[,2],w0.star[,2],w1.star[,2])

  myname = c(1:N,paste0("I.",1:I))
  pdf("figure/latent_space_mode.pdf")
  print(lsjmplot(z0.star,w0.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
  if (double_z && !double_w) {
    print(lsjmplot(z1.star,w0.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
  } else if (double_z && double_w) {
    print(lsjmplot(z1.star,w1.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
  } else if (!double_z && double_w) {
    print(lsjmplot(z0.star,w1.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
  }

  dev.off(which = dev.cur())
}
#+END_SRC


[[file:figure/latent_space_single.pdf]]
#+begin_src R
pdf("figure/latent_space_single.pdf")

k = 20

##df = mydf[[1]]
df = mydf[[2]]
num_samples = nrow(df)

z0dx = grepl("^z\\.0\\.", colnames(df))
z1dx = grepl("^z\\.1\\.", colnames(df))
w0dx = grepl("^w\\.0\\.", colnames(df))
w1dx = grepl("^w\\.1\\.", colnames(df))

num_w = sum(w0dx) / 2;
num_z = sum(z0dx) / 2;
aw0 = aperm( array(unlist( t(df[,w0dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
aw1 = aperm( array(unlist( t(df[,w1dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
az0 = aperm( array(unlist( t(df[,z0dx])), dim = c(2, num_z, num_samples)), c(2,1,3))
az1 = aperm( array(unlist( t(df[,z1dx])), dim = c(2, num_z, num_samples)), c(2,1,3))

z0 = az0[,,k]
z1 = az1[,,k]
w0 = aw0[,,k]
w1 = aw1[,,k]
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(1:N,paste0("I.",1:I))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src
[[pdf:figure/latent_space_mean.pdf]]
#+begin_src R :tangle R/visual-latent-space-plot.R
pdf("figure/latent_space_mean.pdf")

z0 = matched$z0
z1 = matched$z1
w0 = matched$w0
w1 = matched$w1
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(1:N,paste0("I.",1:I))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "verbal_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "verbal_pn_w.csv", col_names = TRUE)
#+END_SRC

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "opusIII_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "opusIII_pn_w.csv", col_names = TRUE)
#+END_SRC

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "chessB_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "chessB_pn_w.csv", col_names = TRUE)
#+END_SRC
** trace plots
[[file:figure/lambda_mcmc_interval_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lambda_mcmc_interval_plot.pdf")
p0 = mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.0\\.1\\.",
  transformations = "log"
)
##mcmc_areas(
##  lambda0.sam,
##  prob = 0.8, # 80% intervals
##  prob_outer = 0.99, # 99%
##  point_est = "mean"
##)

p1 = mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.1\\.1\\.",
  transformations = "log"
)
print(p0)
print(p1)
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/z_pairs_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/z_pairs_plot.pdf")
for (k in 1:min(N,50)) {
  p = mcmc_pairs(mylist,
                 regex_pars = paste0("^z\\.[0-1]\\.",k,"\\."),
                 off_diag_args = list(size = 0.05))
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/w_pairs_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/w_pairs_plot.pdf")
for (i in 1:min(I,50)) {
  p = mcmc_pairs(mylist,
                 regex_pars = paste0("^w\\.[0-1]\\.",i,"\\."),
                 off_diag_args = list(size = 0.05))
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/beta_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/beta_parcoord.pdf")
p = bayesplot::mcmc_parcoord(mylist,
                             regex_pars = "^beta\\.[0-9]\\.")
print(p)
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/theta_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/theta_parcoord.pdf")
p = bayesplot::mcmc_parcoord(mylist,
                             regex_pars = "^theta\\.[0-9]\\.")
print(p)
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/lambda_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lambda_parcoord.pdf")
p = bayesplot::mcmc_parcoord(mylist,
                             regex_pars = "^lambda\\.[0-1]\\.1\\.",
                             transformations = "log")
print(p)
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/w_parcoord_plot.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/w_parcoord_plot.pdf")
p = mcmc_parcoord(mylist,
                  regex_pars = "^w\\.[0-1]\\.[1-5]\\.")
print(p)
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/dist_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/dist_mcmc_trace_plot.pdf")
p0 <- mcmc_trace(mylist,
                 regex_pars = "^dist_z.[0-1]\\.[0-2]_w",
                 ##transformations = "log",
                 facet_args = list(nrow = 2, labeller = label_parsed))
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
                regex_pars = "^dist_z.[0-1]\\.[3-6]_w",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
                regex_pars = "^dist_z.[0-1]\\.[7-9]_w",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC


[[file:figure/z_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/z_mcmc_trace_plot.pdf")
p <- mcmc_trace(mylist,
                regex_pars = "^z.[0-1]\\.[0-2]\\.",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
                regex_pars = "^z.[0-1]\\.[3-6]\\.",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
                regex_pars = "^z.[0-1]\\.[7-9]\\.",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
print(p)
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/w_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/w_mcmc_trace_plot.pdf")
for (i in 1:min(I, 40)) {
  p <- mcmc_trace(mylist,
                  regex_pars = paste0("^w\\.[0-1]\\.",i,"\\."),
                  ##transformations = "log",
                  facet_args = list(nrow = 2, labeller = label_parsed))
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/lambda_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
colnames(df)[grepl("^w\\.1\\.", colnames(df))]


pdf("figure/lambda_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (item in 1:I) {
  p <- mcmc_trace(mylist,
                  regex_pars = paste0("^lambda\\.0\\.",item,"\\."),
                  transformations = "log",
                  facet_args = list(nrow = 2, labeller = label_parsed))
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ",item,".")))

  p <- mcmc_trace(mylist,
                  regex_pars = paste0("^lambda\\.1\\.",item,"\\."),
                  transformations = "log",
                  facet_args = list(nrow = 2, labeller = label_parsed))
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ",item,".")))
}
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/beta_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/beta_mcmc_trace_plot.pdf")
for (i in 1:I) {
  color_scheme_set("mix-blue-pink")
  p <- mcmc_trace(mylist,
                  regex_pars = paste0("^beta\\.",i,"\\."),
                  facet_args = list(nrow = 2, labeller = label_parsed))
  p + facet_text(size = 15)
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/theta_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/theta_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (k in 1:10) {
  p <- mcmc_trace(mylist,
                  regex_pars = paste0("^theta\\.",k,"\\."),
                  facet_args = list(nrow = 2, labeller = label_parsed))
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/gamma_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/gamma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
                regex_pars = "^gamma\\.",
                facet_args = list(nrow = 2, labeller = label_parsed))
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC

[[file:figure/lp_sigma_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lp_sigma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
                pars = c("sigma", "lp_"),
                facet_args = list(nrow = 2, labeller = label_parsed))
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC

** output analysis

#+BEGIN_SRC R :tangle R/CIF_posm.R
tmp = foreach(v=1:num_chain, .combine='rbind') %dopar% apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp = tmp[,1:( which( colnames(mydf[[1]]) == "lp_") )]
  posm = apply(tmp, 2, mean)
} else {
  posm = tmp[1:( which( colnames(mydf[[1]]) == "lp_") )]
}

cname = names(posm)
param = getparam(posm,sj,i,k)

#+END_SRC

[[file:figure/tradeoff.pdf]]
#+BEGIN_SRC R :tangle R/CIF.R
## accuracy = foreach(k=1:N, .combine='rbind') %dopar% fun_accuracy_ick(t,i,k,posm,cname,sj)
pdf(paste0("figure/tradeoff.pdf"))
for (item in 1:I) {
  time = 1:(sj[G] + 10)
  accuracy = foreach(k=1:N, .combine='rbind') %dopar%
    {
      param = getparam(posm,sj,item,k)
      eval_accuracy(param, time)
    }

  plotdf = reshape::melt(accuracy, id.vars=c("time"))
  colnames(plotdf) = c("person", "time", "accuracy")

  p = ggplot(data=plotdf, aes(x=time, y=accuracy, group=person)) +
    geom_line(aes(color=factor(person)), show.legend=FALSE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ##scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Plot of speed-accuracy tradeoff for item ",item,"."))
  print(p)
}
dev.off(which = dev.cur())

## system(paste0("open figure/tradeoff_", item, ".pdf")
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
getparam = function(posm, sj, i, k) {
  cname = names(posm)
  z = posm[str_which(cname, paste0("z\\.[0-1]\\.",k,"\\.[1-2]"))] %>% matrix(nrow = 2, ncol = 2) %>% t()
  w = posm[str_which(cname, paste0("w\\.[0-1]\\.",i,"\\.[1-2]"))] %>% matrix(nrow = 2, ncol = 2) %>% t()
  gamma = posm[str_which(cname, paste0("gamma"))]
  beta = posm[str_which(cname, paste0("beta\\.",i,"\\."))]
  theta = posm[str_which(cname, paste0("theta\\.",k,"\\."))]
  lambda = posm[str_which(cname, paste0("lambda\\.[0-1]\\.",i,"\\."))] %>% matrix(ncol = 2) %>% t()
  H = sj[2:(G+1)] - sj[1:G]
  res = list(lambda=lambda,beta=beta,theta=theta,gamma=gamma,z=z,w=w,sj=sj,H=H)
  if (any(unlist(lapply(res, is.na)))) stop("Index out of range")
  ## should if be G+1? or G?
  ## if (ncol(lambda) != (G+1)) stop("ncol(lambda) != G+1")
  if (ncol(lambda) != (G)) stop("ncol(lambda) != G")
  else return(res)
}
#+END_SRC

#+BEGIN_SRC R
param = getparam(posm, sj, i, k)

ll = 0;
uu = 50

cumcicurve(param, 1, ll, uu, 50);
cumcifun(param, 1, ll, uu);
#+END_SRC

#+BEGIN_SRC R
##CIF = foreach (k=1:50, .combine='rbind') %dopar% {
##integrand <- function(t) {
##  fun_hazard_surv(t,i,k,posm,cname,sj)
##}
##CIF_k = foreach(t=1:200, .combine='c') %dopar% {
##  integrate(integrand, lower = t-1, upper = t)$value
##}
##cumsum(CIF_k)
##}
#+END_SRC

[[pdf:figure/CIF.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF.R
myN = min(100, N)
maxt = sj[G+1] + 10
num_seg = 100
time = seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF.pdf"))

for (item in 1:I) {

  CIF_T = foreach (k=1:myN, .combine='rbind') %do% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F = foreach (k=1:myN, .combine='rbind') %dopar% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T = data.frame(t(CIF_T), time)
  CIF_F = data.frame(t(CIF_F), time)
  plot_T <- reshape::melt(CIF_T, id.vars="time")
  colnames(plot_T) = c("time", "person", "CIF")
  p = ggplot(data=plot_T, aes(x=time, y=CIF, group=person)) +
    geom_line(aes(color=factor(person)), show.legend=FALSE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ##scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ",item,")."))
  print(p)

  plot_F <- reshape::melt(CIF_F, id.vars=c("time"))
  colnames(plot_F) = c("time", "person", "CIF")
  p = ggplot(data=plot_F, aes(x=time, y=CIF, group=person)) +
    geom_line(aes(color=factor(person)), show.legend=FALSE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ",item,")."))
  print (p)
}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/CIF_person.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF_person.R
## choose a few people adn items from latent space
z0 = matched$z0
w0 = matched$w0
## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci
myI = sort(c(8,12,14,17,1,6,13,18)) ## pisa KR

which_z = function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

myN = NULL
for (i in 1:length(myI)) {
  myN = c(myN, which_z(w0[myI[i],],z0))
}
myN = c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt = sj[G+1] + 10
num_seg = 100
time = seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_person.pdf"))

for (k in myN) {

  CIF_T = foreach (item=myI, .combine='rbind') %do% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F = foreach (item=myI, .combine='rbind') %dopar% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T = data.frame(t(CIF_T), c(time))
  colnames(CIF_T) = c(paste0("I",myI),"time")

  plot_T <- reshape2::melt(CIF_T, id.vars="time")
  colnames(plot_T) = c("time", "item", "CIF")

  p = ggplot(data=plot_T, aes(x=time, y=CIF, group=item)) +
    geom_line(aes(color=factor(item)), show.legend=TRUE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ##scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (person ",k,")."))
  print(p)

  CIF_F = data.frame(t(CIF_F), c(time))
  colnames(CIF_F) = c(paste0("I",myI),"time")

  plot_F <- reshape2::melt(CIF_F, id.vars=c("time"))
  colnames(plot_F) = c("time", "item", "CIF")

  p = ggplot(data=plot_F, aes(x=time, y=CIF, group=item)) +
    geom_line(aes(color=factor(item)), show.legend=TRUE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (person ",k,")."))
  print (p)

}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/latent_space_person.pdf]]
#+begin_src R :tangle R/CIF_person.R
pdf("figure/latent_space_person.pdf")

z1 = matched$z1
w1 = matched$w1
z0 = matched$z0[myN,]
w0 = matched$w0[myI,]

xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(myN,paste0("I.",myI))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src

#+BEGIN_SRC R :tangle R/CIF_person.R
system(paste0("rsync -v figure/CIF_person.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_person.pdf ", out_dir, "figure/"))
#+END_SRC

[[pdf:figure/latent_space_cl1.pdf]]
#+begin_src R :tangle R/CIF_cl.R
pdf("figure/latent_space_cl1.pdf")

## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci

## myN = c(23,37,20,27,33,36) ## marketing
## myI = 1:I # marketing

## myN = c(62,589,14,219,524,509,161,435,252,595) ## pisa KR
## myI = 1:I # pisa KR

## myN = c(518, 584, 370, 418, 79, 276, 572, 358, 73, 274) ## pisa
## myI = 1:I # pisa

myN = c(270,367,712,17,615,265,653,484,155,290) ## pisa KR sci
myI = 1:I # pisa KR sci

z1 = matched$z1
w1 = matched$w1
z0 = matched$z0[myN,]
w0 = matched$w0[myI,]

xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(myN,paste0("I.",myI))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src

[[pdf:figure/CIF_cl1.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF_cl1.R
## choose a few people adn items from latent space

which_z = function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

## myN = NULL
## for (i in 1:length(myI)) {
## myN = c(myN, which_z(w0[myI[i],],z0))
## }
## myN = c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt = sj[G] + 500
num_seg = 100
time = seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_cl1.pdf"))

for (item in myI) {

  CIF_T = foreach (k = myN, .combine='rbind') %dopar% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F = foreach (k = myN, .combine='rbind') %dopar% {
    c(0,cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T = data.frame(t(CIF_T), c(time))
  colnames(CIF_T) = c(myN,"time")

  plot_T <- reshape2::melt(CIF_T, id.vars="time")
  colnames(plot_T) = c("time", "person", "CIF")

  p = ggplot(data=plot_T, aes(x=time, y=CIF, group=person)) +
    geom_line(aes(color=factor(person)), show.legend=TRUE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ##scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ",item,")."))
  print(p)

  CIF_F = data.frame(t(CIF_F), c(time))
  colnames(CIF_F) = c(myN,"time")

  plot_F <- reshape2::melt(CIF_F, id.vars=c("time"))
  colnames(plot_F) = c("time", "person", "CIF")

  p = ggplot(data=plot_F, aes(x=time, y=CIF, group=person)) +
    geom_line(aes(color=factor(person)), show.legend=TRUE) +
    ylim(0,1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ",item,")."))
  print (p)

}
dev.off(which = dev.cur())
#+END_SRC

#+BEGIN_SRC R :tangle R/CIF_cl1.R
system(paste0("rsync -v figure/CIF_cl1.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_cl1.pdf ", out_dir, "figure/"))
#+END_SRC

#+BEGIN_SRC R
mN = length(myN)
mise = matrix(0,mN,mN)
for (kk in 1:(mN-1)) {
  for (ll in (kk+1):mN) {
    mise[ll,kk] = sum((CIF_T[,kk] - CIF_T[,ll])^2) / maxt
  }
}
#+END_SRC

#+BEGIN_SRC R
posm_CIF_T = CIF_T[,-ncol(CIF_T)]
num_iter = min(unlist(lapply(mydf,  nrow)))

mises = foreach(v=1:num_chain, .combine='rbind') %dopar% {
  foreach(nn = seq(1, num_iter, 10), .combine='rbind') %dopar% {
    CIF_T = foreach (k = myN, .combine='cbind') %dopar% {
      c(0,cumcicurve(getparam(unlist(mydf[[v]][nn,]), sj, item, k), 1, 0, maxt, num_seg))
    }
    colSums((posm_CIF_T - CIF_T)^2) / maxt
  }
}
#+END_SRC

#+BEGIN_SRC R
apply(mises, 2, median)
#+END_SRC

#+BEGIN_SRC R

sam = mydf[[v]][,1:( which( colnames(mydf[[v]]) == "lp_") )]

CIF_T = foreach (k = myN, .combine='rbind') %dopar% {
  c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
}

}
apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp = tmp[,1:( which( colnames(mydf[[1]]) == "lp_") )]
  posm = apply(tmp, 2, mean)
} else {
  posm = tmp[1:( which( colnames(mydf[[1]]) == "lp_") )]
}

cname = names(posm)
param = getparam(posm,sj,i,k)
#+END_SRC
** FDA
#+BEGIN_SRC R
library(fda)
library(funFEM)
##library(fda.usc)
#+END_SRC

[[file:figure/functionDA.pdf]]
#+BEGIN_SRC R
tmp = as.matrix(CIF_T)
y = tmp[, -ncol(tmp)]
x = tmp[, ncol(tmp)]

## basis <- create.polygonal.basis(x)
## basis <- create.bspline.basis(c(0, max(x)), nbasis=50, norder=4) #below 0 occurs
basis <- create.bspline.basis(c(0, max(x)), nbasis=10)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=99)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=10)
##basis = create.monomial.basis(c(0, max(x)), nbasis=10)
##basis = create.exponential.basis(c(0, max(x)), nbasis=9) # not work
fdobj <- smooth.basis(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd
##fdobj <- smooth.monotone(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd

pdf("figure/functionDA.pdf")
plot(fdobj)
dev.off(which = dev.cur())
#+END_SRC

#+BEGIN_SRC R
kran = 2:2
## res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)
## res = funFEM(fdobj,K=kran,model='AkjBk',crit="icl",init='hclust',lambda=0,disp=TRUE)
res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)

## plot(kran,res$plot$bic,type='b',xlab='K',main='ICL')
#+END_SRC

[[file:figure/functional-clustering.pdf]]
#+begin_src R
pdf("figure/functional-clustering.pdf")
par(mfrow=c(1,2))
plot(fdobj,col=res$cls,lwd=2,lty=1)
fdmeans = fdobj;
fdmeans$coefs = t(res$prms$my)
plot(fdmeans,col=1:max(res$cls),lwd=2)
dev.off(which = dev.cur())
#+end_src

* custom functions
#+BEGIN_SRC R :tangle R/art-functions.R
fun_hazard_surv = function(t,i,k,posm,cname,sj) {
  z = posm[str_which(cname, paste0("z\\.[0-1]\\.",k,"\\.[1-2]"))] %>% matrix(ncol = 2)
  w = rep(posm[str_which(cname, paste0("w\\.",i,"\\."))], 2)  %>% matrix(ncol = 2)
  gamma = posm[str_which(cname, paste0("gamma"))] %>% matrix(ncol = 2)
  beta = posm[str_which(cname, paste0("beta\\.",i,"\\."))] %>% matrix(ncol = 2)
  theta = posm[str_which(cname, paste0("theta\\.",k,"\\."))] %>% matrix(ncol = 2)
  lambda = posm[str_which(cname, paste0("lambda\\.[0-1]\\.",i,"\\."))] %>% matrix(ncol = 2)

  G = length(lambda[,1])
  H = sj[2:(G+1)] - sj[1:G]

  seg = 0
  for (g in 1:G) {
    seg = seg + 1 * (t > sj[g])
  }
  out = lambda[seg,2] * exp(beta[,2] + theta[,2] - gamma[,2] * sqrt(sum((z[,2]-w[,2])^2)))
  if (seg == 1) {
    for (c in 1:2) {
      out = out * exp(
                    - ((t - sj[seg]) *lambda[seg,c]) * exp(beta[,c] + theta[,c] - gamma[,c] * sqrt( sum((z[,c]-w[,c])^2))))
    }
  } else {
    for (c in 1:2) {
      out = out * exp(
                    - ((t - sj[seg]) *lambda[seg,c] + sum(H[1:(seg-1)] * lambda[1:(seg-1),c])) * exp(beta[,c] + theta[,c] - gamma[,c] * sqrt(sum((z[,c]-w[,c])^2))))
    }
  }
  names(out) = NULL
  return(out)
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
fun_hazard_ick = function(t,i,c,k,posm,cname,sj) {
  z = posm[str_which(cname, paste0("z\\.",c,"\\.",k,"\\.[1-2]"))]
  w = posm[str_which(cname, paste0("w\\.",i))]
  gamma = posm[str_which(cname, paste0("gamma\\.",c))]
  beta = posm[str_which(cname, paste0("beta\\.",i,"\\.",c))]
  theta = posm[str_which(cname, paste0("theta\\.",k,"\\.",c))]
  lambda = posm[str_which(cname, paste0("lambda\\.",c,"\\.",i,"\\."))]

  G = length(lambda)
  seg = 0 * t
  for (g in 1:G)
    seg = seg + 1 * (t > sj[g])
  hazard = lambda[seg] * exp(beta + theta - gamma * sum((z-w)^2))
  names(hazard) = NULL
  return(hazard)
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
fun_accuracy_ick = function(t,i,k,posm,cname,sj) {
  fun_hazard_ick(t,i,1,k,posm,cname,sj) / (fun_hazard_ick(t,i,1,k,posm,cname,sj) + fun_hazard_ick(t,i,0,k,posm,cname,sj))
}
#+END_SRC

#+NAME: mdsplot
#+BEGIN_SRC R :tangle R/art-functions.R
library(ggplot2)
library(ggrepel)

lsjmplot <- function( z, w, myname = NULL, xlim=NA, ylim=NA, lab = "Coordinate") {

  ## extract objects

  x = rbind(z,w)
  idx = rep("w", nrow(x))
  idx[1:nrow(z)] = "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position",1:ndim,sep="")

  padding = 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[,1]))*padding
    x2 <- max(abs(position[,1]))*padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[,2]))*padding
    y2 <- max(abs(position[,2]))*padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme = theme(axis.line = element_line(colour = "black"),
                  ##panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  ##panel.border = element_blank(),
                  panel.background = element_blank()
                  )

  ## plot
  pp = ggplot(position,aes(x=position1,y=position2,colour=idx)) +
    theme(text=element_text(size=20)) +
    ## geom_point()+
    xlim(x1,x2) + ylim(y1,y2) +
    xlab(paste(lab," 1",sep="")) + ylab(paste(lab," 2",sep="")) +
    ##xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype=2) +
    geom_vline(xintercept = 0, color = "gray70", linetype=2)
  ##  pp = pp + geom_text_repel(label=rownames(position), segment.color = "grey50", size=6)
  if (!is.null(myname)) {
    pp = pp + geom_text(label=myname,
                        ## segment.color = "grey50",
                        check_overlap = FALSE, show.legend=FALSE,size = 2)
  } else pp = pp + geom_point()
  pp + mytheme
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
find_xstar = function(df) {
  num_samples = nrow(df)

  z0dx = grepl("^z\\.0\\.", colnames(df))
  z1dx = grepl("^z\\.1\\.", colnames(df))
  w0dx = grepl("^w\\.0\\.", colnames(df))
  w1dx = grepl("^w\\.1\\.", colnames(df))
  adx = z0dx | z1dx | w0dx | w1dx

  mlp_ = max(df$lp_)
  star = min(which.max(df$lp_))
  lpos = df[,adx]
  Xstar = list()
  Xstar$z.0 = matrix(unlist(df[star,z0dx]), byrow = T, ncol = 2)
  if (sum(z1dx) == 0) {
    Xstar$z.1 = NULL
  } else {
    Xstar$z.1 = matrix(unlist(df[star,z1dx]), byrow = T, ncol = 2)
  }
  if (sum(w1dx) == 0) {
    Xstar$w.1 = NULL
  } else {
    Xstar$w.1 = matrix(unlist(df[star,w1dx]), byrow = T, ncol = 2)
  }
  Xstar$w.0 = matrix(unlist(df[star,w0dx]), byrow = T, ncol = 2)
  return(list(lp_ = mlp_, Xstar=Xstar))}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
find_xstar_inlist = function(mydf) {
  num_chain = length(mydf)
  mlp = -Inf
  for (i in 1:num_chain) {
    slist = find_xstar(mydf[[i]])
    if (slist$lp_ > mlp) Xstar = slist$Xstar
  }
  return(Xstar)}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
do_procrustes = function(Xstar, mydf, is_list = FALSE, translation = TRUE, scale = FALSE, reflect = TRUE) {
  posm = 0
  if (is_list == TRUE) {
    num_chain = length(mydf)
  } else { num_chain = 1 }
  for (i in 1:num_chain) {
    if (is_list == TRUE) { df = mydf[[i]]
    } else { df = mydf }

    num_samples = nrow(df)

    z0dx = grepl("^z\\.0\\.", colnames(df))
    z1dx = grepl("^z\\.1\\.", colnames(df))
    wdx = grepl("^w", colnames(df))
    adx = z0dx | z1dx | wdx
    N = sum(z0dx) / 2
    nall = sum(adx)/2

    mlp_ = max(df$lp_)
    star = min(which.max(df$lp_))
    lpos = df[,adx]

    ## mm = list()
    ## for (k in 1:num_samples) {
    ##   X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
    ##   ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation)$X.new #MCMCpack
    ##   mm[[k]] = vegan::procrustes(X, Xstar, scale = scale)$Yrot #vegan
    ##   df[k,adx] = mm[[k]] %>% t() %>% c()
    ## }

    mm = foreach (k = 1:num_samples) %dopar% {
      ## X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
      ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation = scale)$X.new #MCMCpack
      ## vegan::procrustes(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2) ), scale = scale)$Yrot #vegan
      shapes::procOPA(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2)) , scale = scale, reflect = reflect)$Bhat #shapes
    }
    tmm = lapply(mm,t)
    df[,adx] = t( matrix(unlist(tmm), nrow = sum(adx)) )


    posm = posm + Reduce("+",mm) / num_samples
    if (is_list == TRUE) { mydf[[i]] = df
    } else { mydf = df }
  }

  posm = posm / num_chain
  z0= posm[1:N,]
  if (sum(z1dx) == 0) {
    w = posm[-(1:N),]
    z1 = NULL
  } else {
    z1 = posm[(N + 1):(2*N),]
    w = posm[-(1:(2*N)),]
  }
  return(list(mydf = mydf, z0=z0, z1=z1, w=w))
}
#+END_SRC

* Local Variables
# Local Variables:
# eval: (flyspell-mode -1)
# End:

* TEST
