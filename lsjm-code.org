#+TITLE: LSJM Code for accuracy and RT
#+AUTHOR: Jonghyun Yun
#+EMAIL: jonghyun.yun@gmail.com

#+OPTIONS:   H:10 num:nil toc:nil \n:nil @:t ::t |:t ^:nil ^:{} -:t f:t *:t <:t ':nil -:nil pri:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

#+STARTUP: overview inlineimages logdone indent

#+SETUPFILE: ~/setup/my-theme-readtheorg.setup

#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args:R :session *R-Org* :exports both :noweb yes
#+PROPERTY: header-args:jupyter-python :session *jupyter-lsjm* :kernel tf :async yes

* OrgMode                                                          :noexport:
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

** Reveal
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
# slide/none/fade/convex/concave/zoom
#+REVEAL_TRANS: slide
# solarized/black/white/league/sky/beige/simple/serif/blood/night/moon
#+REVEAL_THEME: solarized
#+REVEAL_HLEVEL: 2
#+REVEAL_PLUGINS: (highlight search zoom)
#+REVEAL_EXTRA_CSS: ./reveal_firago.css

#+OPTIONS: reveal_history:t reveal_fragmentinurl:t
#+OPTIONS: reveal_mousewheel:t reveal_inter_presentation_links:t
#+OPTIONS: reveal_width:1400 reveal_height:1000
#+REVEAL_TITLE_SLIDE: <h2 class="title">%t</h2><h4 class="subtitle">%s</h4><h3 class="author">%a</h3><h3 class="date">%d</h3>

** Hugo
#+HUGO_BASE_DIR: ~/website
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DATE_FORMAT: %Y-%m-%dT%T%z
#+HUGO_FRONT_MATTER_FORMAT: toml

#+HUGO_SECTION:
#+HUGO_BUNDLE:
#+HUGO_CATEGORIES:

#+HUGO_EXPORT_RMARKDOWN:

** HTML
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:t

# #+HTML_MATHJAX: align: left indent: 5em tagside: right
# #+HTML_MATHJAX: scale: 85 font: Asana-Math
# MATHJAX font: MathJax TeX (default) Asana-Math Neo-Euler Latin-Modern Gyre-Pagella Gyre-Termes
# #+OPTIONS: tex:dvipng tex:dvisvgm # use LaTeX to generate images for equations

#+HTML_HEAD:  <!-- Global site tag (gtag.js) - Google Analytics -->
#+HTML_HEAD:<script async src="https://www.googletagmanager.com/gtag/js?id=UA-128966866-1"></script>
#+HTML_HEAD:<script>
#+HTML_HEAD:  window.dataLayer = window.dataLayer || [];
#+HTML_HEAD:  function gtag(){dataLayer.push(arguments);}
#+HTML_HEAD:  gtag('js', new Date());
#+HTML_HEAD:
#+HTML_HEAD:  gtag('config', 'UA-128966866-1');
#+HTML_HEAD:</script>

# #+HTML_LINK_HOME: http://wweb.uta.edu/faculty/yunj/index.html
# #+HTML_LINK_UP: http://wweb.uta.edu/faculty/yunj/index.html

# https://scripter.co/latex-in-html/
#+macro: latex @@html:<span class="latex">L<sup>a</sup>T<sub>e</sub>X</span>@@

#+BEGIN_SRC emacs-lisp :eval no :results silent :exports none :tangle no
(setq org-html-htmlize-output-type 'css)
(setq org-html-htmlize-output-type 'inline-css)
#+END_SRC

#+begin_src emacs-lisp ::eval no results silent :exports none :tangle no
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
(add-hook 'org-mode-hook 'org-display-inline-images)
#+end_src

* LaTeX Header                                                     :noexport:
#+LATEX_CLASS: no-article
#+LATEX_CLASS_OPTIONS: [letterpaper,11pt]

#+LATEX_COMPILER: xelatex

#+LATEX_HEADER: %% Margins
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{verbose,margin=1.5in}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+LATEX_HEADER: \linespread{1.1}

#+LATEX_HEADER: %% Typesetting
#+LATEX_HEADER: \usepackage[stretch=10,babel=true]{microtype} % better typesetting. works w/ pdftex, not latex.
#+LATEX_HEADER: %% \usepackage[english]{babel} % manages hyphenation patterns
#+LATEX_HEADER: %% \usepackage{polyglossia} \setdefaultlanguage{english} % babel replacement for XeLaTex.
#+LATEX_HEADER: \usepackage{csquotes} % Context sensitive quotation facilities

#+LaTeX_HEADER: %% Biblio
#+LATEX_HEADER: \usepackage[natbib=true, sorting=ynt, backend=biber, minbibnames=3, maxbibnames=3, doi=false, isbn=false, style=authoryear]{biblatex}
#+LATEX_HEADER: \addbibresource{~/Zotero/myref.bib}
#+LATEX_HEADER: \AtEveryBibitem{\clearfield{note}}
#+LATEX_HEADER: \AtEveryBibitem{\clearfield{month}}
#+LATEX_HEADER: \AtEveryBibitem{\clearfield{day}}
#+LATEX_HEADER: \AtEveryBibitem{\clearfield{eprint}}

#+LATEX_HEADER: %% Math
#+LATEX_HEADER: \usepackage{amsmath} % \declareMathOperator
# #+LATEX_HEADER: \usepackage{mathabx} % \widebar
# #+LATEX_HEADER: \usepackage{amssymb}
# #+LATEX_HEADER: \usepackage{amsbsy}  %\boldsymbol %\pbm (faked bold)
# #+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage[mathbf=sym]{unicode-math}
#+LATEX_HEADER: %% \usepackage{cool} % for math operators & symbols e.g. partial diff
#+LATEX_HEADER: \usepackage{mathtools} % for math aligning & spacing
#+LATEX_HEADER: \usepackage{physics} % derivative, dx, operators
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \allowdisplaybreaks % Allow new page within align

#+LATEX_HEADER: %% Font
# #+LATEX_HEADER: \usepackage{lmodern}
# #+LATEX_HEADER: \setmathfont{latinmodern-math.otf}
#+LATEX_HEADER: \setmainfont{XITS}
#+LATEX_HEADER: \setmathfont{XITS Math} % \boldsymbol works
#+LATEX_HEADER: \setmathfont[range={\mathcal,\mathbfcal},StylisticSet=1]{XITS Math}

#+LATEX_HEADER: \usepackage[unicode,colorlinks]{hyperref}
# #+LATEX_HEADER: \PassOptionsToPackage{unicode,colorlinks=true}{hyperref}

# #+LATEX_HEADER: \usepackage[unicode]{hyperref}
# #+LATEX_HEADER: \PassOptionsToPackage{unicode}{hyperref}
# #+LATEX_HEADER: \hypersetup{colorlinks = true}
# #+LATEX_HEADER:     linkcolor={red!50!black},
# #+LATEX_HEADER:     citecolor={blue!50!black},
# #+LATEX_HEADER:     urlcolor={blue!80!black}}
* References
#+BEGIN_SRC emacs-lisp :eval yes :exports none
(add-hook 'org-export-before-parsing-hook 'orcp-citeproc)
#+END_SRC

#+Bibliography: ~/Zotero/myref.bib
#+PANDOC_OPTIONS: csl:~/Zotero/styles/chicago-author-date.csl

# for html export with bib
# bibliographystyle:unsrt
# bibliography:~/Zotero/myref.bib

#+latex: \begingroup
#+latex: \renewcommand{\section}[2]{}%
#+latex: \printbibliography[sorting=ydnt, heading=none, type=article] % for biblatex, comment out everything else
#+latex: \endgroup
* pseudo code
** Initialize
1. initialize $\lambda_{ic,g}$: I x N x 2
** Update \lambda
1. initialize $\log \lambda_{ic,g}$: I x N x 2
2. for each i,k,c
3. for each j
4. the full conditional:
\begin{align*}
p(\lambda_{ic,j}| \cdot ) \propto & \lambda_{ic,j}^{\sum_{k=1}^{N} Y_{ik,j} = c} \exp[- \lambda_{ic,j} \sum_{k=1}^{N} I(T_{ik} > s_{j-1}) H_{ik,j} \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)]
\pi(\lambda_{ic,j})
\end{align*}
where $H_{ik,j} = \min(T_{ik}, s_{j}) - s_{j-1}$.

*** MH move (direct sampling is doable, dont do this)
1. initialize $\log \lambda_{ic,g}$: I x N x 2
2. for each i,k,c
3. for each j
4. Draw $\lambda_{ic,j}^{* } \sim N(\log \lambda_{ic,j}^{(t)}, jump_{\lambda_{ic,j}})$
5. accept if $r > \log U(0,1)$
\begin{align*}
r = & \prod_{k=1}^{N}
\frac{
   (\lambda_{ic,j}^{* })^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{* }]}
   {(\lambda_{ic,j}^{t})^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{1}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{t}]} \\
& \times
  \frac{J(\lambda_{ic,j}^{(t)} -> \lambda_{ic,g}^{* })}{J(\lambda_{ic,g}^{* } -> \lambda_{ic,g}^{t})}
\frac{\pi(\lambda_{ic,j}^{* })}{\pi(\lambda_{ic,g}^{(t)})} \\
= & \prod_{k=1}^{N}
  \frac{(\lambda_{ic,j}^{* })^{I(Y_{ikc,j} = 1)}}{(\lambda_{ic,j}^{t})^{I(Y_{ikc,j} = 1)}} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)(\sum_{m=1}^{j} H_{ic,m}(\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t}))] \\
& \times
\frac{\pi(\lambda_{ic,j}^{* })}{\pi(\lambda_{ic,j}^{(t)})}
 \frac{J(\lambda_{ic,j}^{(t)} -> \lambda_{ic,j}^{* })}{J(\lambda_{ic,j}^{* } -> \lambda_{ic,j}^{t})};
\end{align*}

if the event occurs before the $j$-th segment (g > j), then $\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t} = 0$ for all $m=1,..,j$, so no contribution in the likelihood part.

** Update \theta
prior: $\theta_{kc} | \sigma^{2} ~ N(0,\sigma^2)$
1. initialize $\theta_{kc}$: N x 2
2. for each k,c
3. Draw $\theta_{kc}^{* } \sim N(\theta_{kc}^{(t)}, jump_{\theta_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{* })}
   \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})} \\
&=
\frac{\exp(\theta_{kc}^{* })}{\exp(\theta_{kc}^{t})}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r = &
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}

** Update \beta
1. initialize $\beta_{ic}$: I x 2
2. for each i,c
3. Draw $\beta_{ic}^{* } \sim N(\\beta_{ic}^{(t)}, jump_{\beta_{ic}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\beta_{ic}^{* })}{\pi(\beta_{ic}^{t})}
   \frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})} \\
&=
\frac{\exp(\beta_{kc}^{* })}{\exp(\beta_{kc}^{t})}
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r =&
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
** Update z
1. initialize $z_{kc}$: N x 2
2. for each k,c
3. Draw $z_{ic}^{* } \sim N(z_{kc}^{(t)}, J_{z_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r =& \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)\Lambda_{ic}(t_{ik})]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{(t)} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{(t)} - w_{i}||)\Lambda_{ic}(t_{ik}) ]
} \\
& \times
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{(t)})}
   \frac{J(z_{kc}^{(t)} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{(t)})} \\
=&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{(t)})}
# \frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}
\exp[-\gamma_{c}\sum_{i=1}^{I}
(||z_{kc}^{* } - w_{i}||-||z_{kc}^{(t)} - w_{i}||)]\\
&\times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t_ik)\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{(t)} - w_{i}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r =&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{t})}
\frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}\\
& \times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t_{ik})\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{(t)} - w_{i}||)\}]
\end{align*}
** Update w
1. initialize $w_{i}$: I
2. for each I
3. Draw $w_{i}^{* } \sim N(\w_i^{(t)}, jump_{w_i})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r = &\prod_{c=1}^{2} \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)\Lambda_{ic}(t) ]
}
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
   \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
# \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[\sum_{c=1}^{2}\sum_{k=1}^{N} \gamma_{c}
(||z_{kc} - w_{i}^{* }||-||z_{kc} - w_{i}^{t}||)] \\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r & =
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}\\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}

** Update gamma
1. initialize $\gamma_{c}$: 2
2. for each c
3. Draw $\gamma_{c}^{* } \sim \log N(\log \gamma_{c}^{(t)}, jump_{\gamma_{c}})$
4. accept if $\min(\log r, 0) > \log U(0,1)$
\begin{align*}
r = & \prod_{i=1}^{I}\prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
} \\
& \times
\frac{\pi(\gamma_{c}^{* })}{\pi(\gamma_c^{t})}
   \frac{J(\gamma_{c}^{t} -> \gamma_{c}^{* })}{J(\gamma_{c}^{* } -> \gamma_{c}^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})} \\
& \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t)\exp(\beta_{ic} + \theta_{kc}) \{\exp( - \gamma_{c}^{* } ||z_{kc} - w_{i}||) -
 \exp( -\gamma_{c}^{t} ||z_{kc} - w_{i}||)\}] \\
=&\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t) (RR_{c}^{*} - RR_{c})]
\end{align*}

If $Y_{ikc} = 1$,
\[
r = r \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N} ||z_{kc} - w_{i}||(\gamma_{c}^* - \gamma_{c}^{t})]
\]
* prerequisite
:PROPERTIES:
:header-args:R:          :tangle R/prerequisite.R
:END:
#+begin_src R
require(magrittr)
require(dplyr)
#+end_src

#+RESULTS:
: Loading required package: magrittr

#+begin_src R :tangle R/art-functions.R
source("R/prerequisite.R")
#+end_src

#+RESULTS:
#+begin_example
Loading required package: magrittr
Loading required package: dplyr

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union
#+end_example

* PISA2015 data
** pisa2015/README.txt
- pisa2015: math
#+BEGIN_SRC sh :results output
cat ../pisa2015/README.txt
#+END_SRC

** notebook
#+BEGIN_SRC R
source('R/pisa-preprocess.R')
source('R/pisa-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-preprocess.R
## pick_person = 1:592
pick_person = 1:592
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/pisa2015/US_PISA2015.rdata")
df = as_tibble(US_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+END_SRC

#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :tangle R/art-functions.R
pullit <- function(info, cl) {
  it <- info %>% filter(Cluster_A == cl) # %>% dplyr::select(Item,Time)
  item <- pull(it, Item)
  time <- pull(it, Time)
  return(cbind(item, time))
}
#+end_src

#+begin_src R :results none :tangle R/pisa-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

di01 = di01[pick_person,pick_item]
dt01 = dt01[pick_person,pick_item]
#+end_src

** boxplot :ARCHIVE:
#+BEGIN_SRC R
library(reshape2)

di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+END_SRC

#+BEGIN_SRC R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 99))
#+END_SRC

#+BEGIN_SRC R
rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01, aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
#+END_SRC

[[file:figure/RTs_S01.pdf]]

#+BEGIN_SRC R
pdf("figure/RTs_S01.pdf")
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC
** numeric ID
#+BEGIN_SRC R :tangle R/art-functions.R
tabulate_id = function(chrid) {
  ## reference table of charactor and numeric id
  chr = sort(unique(chrid))
  out = data.frame(chr = chr, num = seq_len(length(chr)))
  return(out)
}
to_numID = function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID = function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+END_SRC

#+begin_src R :tangle R/pisa-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
*** To export long format data for STAN
#+begin_src R
library(survival)
status = !(dit01$res == 99)

tmp <- survival::survSplit(formula = Surv(time, status) ~ ., data = dit01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         len = time - tstart,
         status_T = 1 * (status == 1 & res == 1),
         status_F = 1 * (status == 1 & res == 0)
         ) %>%
  as_tibble
to_stan = tmp %>% mutate(seg_g = seg_g - 1) %>% dplyr::select(stuid, item, time, seg_g, len, status_F, status_T)
## tmp %>% dplyr::select(res,status,status_T,status_F)
#+end_src

#+begin_src R
## data and fixed parameters
I = nrow(tab_item)
N = nrow(tab_stuid)
C = 2

L = nrow(to_stan)
G = ncut

with(to_stan,
     rstan::stan_rdump(c('I','N','C','L','G','stuid','item', 'G', 'seg_g','len','status_F','status_T'),"pisa_data.R"))

#+end_src

*** To export short format data for STAN

#+BEGIN_SRC R
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)
tt01 = data.frame(time = c(as.matrix(tt01)), status = 1)

tmp <- survival::survSplit(formula = survival::Surv(time, status) ~ ., data = tt01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 1,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+begin_src R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2

G = ncut + 1

rstan::stan_rdump(c('I','N','C','G', 'mseg','mlen', 'mh', 'mt','mi'),"pisa_short.R")

#+end_src

*** to export short format data for C++
#+BEGIN_SRC R :tangle R/pisa-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** not used
#+BEGIN_SRC R
item <- pull(info, Item)
time <- pull(info, Time)
cname <- colnames(df)
#+END_SRC

#+begin_src R
item = item[info$Cluster_A == "S01"]
time = time[info$Cluster_A == "S01"]
yi = df[,cname %in% item]
yt = df[,cname %in% time]

idx = !apply(yi,1,function(x) all(is.na(x)))
yi = yi[idx,]
yt = yt[idx,]
yi[is.na(yi)] = 99
yi[yi == 2] = 1
#+end_src


#+BEGIN_SRC R
boxplot(yt)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* opusIII-matrices-data.dat                                         :ARCHIVE:
#+BEGIN_SRC R
source("R/opusIII-preprocess.R")
source("R/opusIII-init.R")

#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
num_person = 504 ## max 504: do not change
num_item =35 ## max 35

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
opusIII = readr::read_delim("data/opusIII-matrices-data.dat"," ")
df = as_tibble(opusIII[,-1])[,1:4] ## drop row names
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

** knot selection
#+begin_src R :tangle R/opusIII-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/opusIII-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/opusIII-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src
** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/opusIII-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** boxplot
#+BEGIN_SRC R :results value :tangle R/opusIII-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(id_ = 1:num_item)
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :results none :tangle R/opusIII-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/opusIII_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/opusIII_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* verbalIntelligence.dat

#+BEGIN_SRC R :results none :tangle no :results output :session
source("R/verbal-preprocess.R")
source("R/verbal-init.R")
#+END_SRC

#+BEGIN_SRC R :tangle R/verbal-preprocess.R
num_person = 726 ## max 726: do not change
num_item = 34 ## max 34

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
verbal = readr::read_delim("data/verbalIntelligence.dat"," ")
df = as_tibble(verbal[,-1])[,1:4] ## drop row names
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(685,137,610,724,703)])
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(680,629,600,691,601)])
#+END_SRC

** knot selection
#+begin_src R :tangle R/verbal-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-functions.R
tab_sj <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g >= m))
  }
  return(res)
}

tab_IY <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g == m))
  }
  return(res)
}
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
item <- pull(tmp, item)
person <- pull(tmp, person)
seg_g <- pull(tmp, seg_g)
H <- pull(tmp, len)
#+END_SRC

#+BEGIN_SRC R :tangle R/verbal-preprocess.R
mi <- reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[, -1]
mt <- reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[, -1]
mNA <- mi
mNA[!is.na(mNA)] <- 1
mNA[is.na(mNA)] <- 0
mseg <- reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[, -1]
mh <- reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[, -1]
mlen <- sj[2:(ncut + 1)] - sj[1:(ncut)]

mi[is.na(mi)] <- -99
mt[is.na(mt)] <- -99
mseg[is.na(mseg)] <- -99
mh[is.na(mh)] <- -99
#+END_SRC

#+begin_src R :results none :tangle R/verbal-preprocess.R
## data and fixed parameters
I <- nrow(mt)
N <- ncol(mt)
C <- 2
G <- ncut #
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
readr::write_csv(data.frame(I = I, N = N, C = C, G = G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen), "input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg), "input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh), "input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt), "input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi), "input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA), "input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
mtab_sj <- t(apply(mseg, 1, function(x) tab_sj(x, G)))

tmp_0 <- mseg
tmp_0[mi == 1] <- -99
tmp_1 <- mseg
tmp_1[mi == 0] <- -99
mIY <- rbind(t(apply(tmp_0, 1, function(x) tab_IY(x, G))), t(apply(tmp_1, 1, function(x) tab_IY(x, G))))

readr::write_csv(as.data.frame(mtab_sj), "input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY), "input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
mvar <- readr::read_csv("input/mvar.csv", col_names = FALSE) %>% as.matrix()
I <- mvar[1, 1]
N <- mvar[1, 2]
C <- mvar[1, 3]
G <- mvar[1, 4]
## lambda
a_lambda <- matrix(0.1, I, G)
b_lambda <- matrix(0.1, I, G)
jump_lambda <- matrix(0.5, I, G)

mu_beta <- matrix(0.0, I, 2)
sigma_beta <- matrix(sqrt(1.0), I, 2)
jump_beta <- matrix(0.25, I, 2)

mu_theta <- matrix(0.0, N, 2)
sigma_theta <- matrix(sqrt(1.0), N, 2)
jump_theta <- matrix(1.0, N, 2)

a_sigma <- 1.0
b_sigma <- 1.0

mu_gamma <- matrix(0.0, 1, 2)
sigma_gamma <- matrix(sqrt(1.0), 1, 2)
jump_gamma <- matrix(1.0, 1, 2)

mu_z <- matrix(0.0, N, 2)
sigma_z <- matrix(sqrt(1.0), N, 2)
jump_z <- matrix(1.0, N, 2)

mu_w <- matrix(0.0, I, 2)
sigma_w <- matrix(sqrt(1.0), I, 2)
jump_w <- matrix(0.5, I, 2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda, b_lambda, jump_lambda)), "input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta, sigma_beta, jump_beta)), "input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta, sigma_theta, jump_theta)), "input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma, b_sigma)), "input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma, sigma_gamma, jump_gamma)), "input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z, sigma_z, jump_z)), "input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w, sigma_w, jump_w)), "input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/verbal-init.R
mvar <- as.matrix(readr::read_csv("input/mvar.csv", col_names = F))
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

set.seed(as.numeric(Sys.time()))

set.seed(as.numeric(Sys.time()))

init_lambda <- matrix(1, nrow = 2 * I, ncol = G)
init_beta <- 0 * matrix(rnorm(2 * I), ncol = 2)
init_theta <- 0 * matrix(rnorm(2 * N), ncol = 2)
init_gamma <- 1 * matrix(c(1, 1), ncol = 1)
init_w <- 0 * matrix(rnorm(2 * 2 * I), ncol = 2)
init_z <- 0 * matrix(rnorm(2 * 2 * N), ncol = 2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/verbal-preprocess.R
df %>%
  group_by(item) %>%
  summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/verbal-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x = factor(resp), y = RT, fill = factor(resp))) +
  geom_boxplot() +
  labs(title = "RT by accuracy") +
  facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x = factor(resp), y = log(RT), fill = factor(resp))) +
  geom_boxplot() +
  labs(title = "log RT by accuracy") +
  facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/verbal_pn-init.R
mvar <- as.matrix(readr::read_csv("input/mvar.csv", col_names = F))
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda <- matrix(1, nrow = 2 * I, ncol = G)
init_beta <- 0 * matrix(rnorm(2 * I), ncol = 2)
init_theta <- 0 * matrix(rnorm(2 * N), ncol = 2)
init_gamma <- 1 * matrix(c(1, -1), ncol = 1)
init_w <- 0 * matrix(rnorm(2 * 2 * I), ncol = 2)
init_z <- 0 * matrix(rnorm(2 * 2 * N), ncol = 2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/verbal_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Marketing                                                         :ARCHIVE:
** description

Here is the description of the dataset: Each row of the data represents one fixation.  The duration of the fixation is given by the column labeled "event_duration" and is in units of milliseconds.  The variable ~choice~ indicates the choice that the subject made in that trial, 1 is left and 0 is right. The variable "roi" indicates whether the fixation was to the left ("1) or the right ("2").  The variable ~rt~ is the reaction time for the trial. "fix_num" is the number of the fixation within the trial, with 1 being first fixation, 2 being second fixation etc.  Similarly, "rev_fix_num" is the number of the fixation but going backwards from the last fixation, so 1 is the last fixation, 2 is the second-to-last fixation, etc.

Please ignore the variables "corr_fix_duration", "computed_rt" and "temp", I either did not end up using those or they were temporary variables.

## processing model for choice (left or right)
- 1: subject: person
- 2: trial: item
- 7: rt: response time
- 8: choice; response

#+BEGIN_SRC R
source("R/marketing-preprocess.R")
source("R/marketing-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
df <- foreign::read.dta("data/fixations_final.dta")[,c(1,2,8,7)] %>% as_tibble %>% distinct
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

* Smith and Krajbich                                         :ATTACH:ARCHIVE:
:PROPERTIES:
:ID:       d0a1e4f9-326e-4950-8d12-d805efe8950a
:END:
[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;1][In the two-food task (Figure 1b), subjects were presented with two previously rated food items, one on each side of the computer screen, and asked to choose the one they would like to eat most at the end of the experiment. Only positively rated (i.e., rating 0) food items were included in this task, to ensure that subjects were choosing between items that were relevant to them. These posi tively rated items were randomly selected, subject to the con straints that (a) no item could be shown more than seven times and (b) the value difference between the items could not exceed five.]]

[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;2][Many subjects (two-food: n 􏰂 22; food-risk: n 􏰂 39) did not have enough positively rated food items to generate 200 valid trials in each of the food choice tasks, so these subjects completed as many constraint-satisfying trials as were generated (two-food: M 􏰂 171.3; food-risk: M 􏰂 146.7). In the food tasks, we limited the difference in value between the options in order to increase the experiment’s efficiency by focusing on trials with nontrivial decisions. This also facilitates the model fitting procedure, which relies on the RT distributions of “correct” and “error” choices.]]

** description
[[mu4e:msgid:15884427-B662-4EF9-A15A-EA609676DECF@g.ucla.edu][Re: new marketing data]]
[[mu4e:msgid:D5AF8D06-A080-44CA-96F7-386165ED972F@g.ucla.edu][new marketing data]]

It should be formatted similarly to the previous one. Each row is a fixation/dwell.  A few notes:
"LeftRight" - 1 is left, 2 is right
"ROI" - 1 is left, 2 is right
"DwellLength" is the duration of the dwell/fixation in seconds

You can also see that there are columns for the names of the snack foods in each trial.  If you need more information than this, let me know.  I could provide you with a link to the images of the items.  You would just need to link the images to the names.

LeftRight is the choice variable - 1 means left choice, 2 means right choice
FoodLeft and FoodRight are just unique food identifiers.  They should be redundant with the food names.
ValueLeft and ValueRight are the independent ratings of the foods on the left and right.  Subjects should generally be choosing the item with the higher value.
DwellLength is the fixation/dwell time for that particular fixation/dwell. The units are seconds.

*Plan*: "correctness" is defined by the choice of higher valued food. Exclude cases with the same valued food. "item" is defined using the value difference (not exceed 5).

#+BEGIN_SRC R
source("R/twofood-preprocess.R")
source("R/twofood-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
load("data/SmithKrajbich2018.RData")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
df = data %>% select(SubjectNumber, LeftRight, RT, ValueLeft, ValueRight)
df = distinct(df)
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/twofood-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

* Chess proficiency (this is for Chees A)                    :ATTACH:ARCHIVE:
:PROPERTIES:
:ID:       aaa8e8c6-ea9b-47b0-8901-047b0388e662
:END:
[[mu4e:msgid:380ABC3A-4965-4B3A-9B29-D3F370AAF0E8@g.ucla.edu][New data - chess proficiency]]

** description

- Choose-a-move test A (test B is a parallel version of A)
  A1 - A40: 1 if correct (the correct answer is vastly superior to all other legal moves)
  AR1 - AR40: RT (< 30s; or no response)
  1-20: tactical items
  21-30: positional items
  31-40: endgame items
  Item difficulty increased within each set
  Missingness in RT -> should be excluded

- Predict-a-move test
  items are related. no unique solution. points of merit on a scale from 0 to 5.

#+BEGIN_SRC R :results none
source("R/chess-preprocess.R")
source("R/chess-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+END_SRC

#+BEGIN_SRC R :tangle R/chess-preprocess.R
dt = cbind(PPNR, chess[,grepl("AR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("A[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+END_SRC

#+RESULTS:
: [1] TRUE

** knot selection
#+begin_src R :tangle R/chess-preprocess.R
time = pull(dit, RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

** survSplit
#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/chess-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/chess-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/chess-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chess-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot
#+BEGIN_SRC R :results value :tangle R/chess-preprocess.R
dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/chess-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

* Choose-a-move test B
See [[id:aaa8e8c6-ea9b-47b0-8901-047b0388e662][Chess proficiency (this is for Chees A)]]
** description

#+BEGIN_SRC R :results none
source("R/chessB-preprocess.R")
source("R/chessB-init.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+END_SRC

#+BEGIN_SRC R :tangle R/chessB-preprocess.R
dt = cbind(PPNR, chess[,grepl("BR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("B[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+END_SRC

#+RESULTS:
: [1] TRUE

** knot selection
#+begin_src R :tangle R/chessB-preprocess.R
time = pull(dit, RT)
item = pull(dit, item)
resp = pull(dit, resp)

ncut = 2
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

#+begin_src R :tangle R/chessB-preprocess.R
checksj = 0
tab0 = table(findInterval(time[resp == 0], sj), item[resp==0])
tab1 = table(findInterval(time[resp == 1], sj), item[resp==1])
sjtab = list(tab0,tab1)
  for (c in 1:2) {
  checksj = checksj + sum(sjtab[[c]]==0) 
}
if (checksj > 0) {
print(tab0)
print(tab1)
  cat(checksj,"\n")
  stop("there exists an interval(s) with no observation.")
  }
#+end_src

#+RESULTS:
#+begin_example
   
      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
  1   7  12  25   3   5   9   6   8  12   3   5  11  18   6   2  11   9  28   4
  2   3   3  18  15  18  31  20  34  47  26  43  69  61  20  19  97  31  76  45
  3   0   0   2  12   5  23  35  41  87  51  72  68  41 124  75  91 127  79 119
   
     20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
  1   7   8  16  15  23  15  12  19   2   7  31   2  11   8  94  56  68  78  61
  2  23   8  33  40  72  21  66  96  38  34  89   0   4  27  73  72  66  84  96
  3 198   5  15  18  99  44 124 116 153 115 100   2   0   8  16  28  23  64  50
   
     39  40
  1 104  29
  2  54  41
  3  24 133
   
      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
  1 216 219 174 149 188 138 108 104  21  30  70  25  39  18  32  12  19  13   5
  2  24  17  31  62  31  44  59  51  58  89  49  49  62  48  94  32  30  27  19
  3   1   0   1  10   4   6  23  13  26  52  12  29  30  35  29   8  35  28  59
   
     20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
  1   4 146  65  49   8  33  10   4   3  15  10 227 206 141  30  25  12  17   6
  2   5  70  90  97  21  90  22   6  21  43  15  19  27  58  26  46  52   4  23
  3  14  14  32  32  28  48  17  10  34  37   6   1   3   9  12  24  30   4  15
   
     39  40
  1  34   5
  2  26  10
  3   9  33
5 
Error: there exists an interval(s) with no observation.
#+end_example

** survSplit
#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/chessB-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+RESULTS:
: Using response as value column: use value.var to override.
: Using time as value column: use value.var to override.
: Using seg_g as value column: use value.var to override.
: Using len as value column: use value.var to override.

#+begin_src R :results none :tangle R/chessB-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** boxplot
#+BEGIN_SRC R :results none
dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

#+BEGIN_SRC R
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=time,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(time),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
#+END_SRC

#+RESULTS:

[[file:figure/RTs.pdf]]

#+BEGIN_SRC R
pdf("figure/RTs.pdf")
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(1.0,I,G)
b_lambda = matrix(1.0,I,G)
jump_lambda = matrix(0.25,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(0.25,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(0.05,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.25,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/chessB-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: pp Gamma(0) = 1, Gamma(1) = 1
#+BEGIN_SRC R :results none :tangle R/chessB_pp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_pp-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: np (default) Gamma(0) = -1, Gamma(1) = 1
#+BEGIN_SRC R :results none :tangle R/chessB_np-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, 1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_np-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: nn Gamma(0) = -1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/chessB_nn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_nn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: pn Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/chessB_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: no_latent Gamma(0) = 0, Gamma(1) = 0
#+BEGIN_SRC R :results none :tangle R/chessB_no_latent-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 0*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_no_latent-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: fn (free gamma0) Gamma(0) > 0, Gamma(1) = -1
:PROPERTIES:
:ID:       f4cdf66c-59ff-4569-9fec-04baa3f2b694
:END:

#+BEGIN_SRC R :results none :tangle R/chessB_noinfo-preprocess.R
source("R/chessB-preprocess.R")

mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.0001,I,G)
b_lambda = matrix(0.0001,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(10000.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(10000.0),N,2)
jump_theta = matrix(0.1,N,2)

a_sigma = 0.0001
b_sigma = 0.0001

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(10000.0),1,2)
jump_gamma = matrix(0.01,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(10000.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(10000.0),I,2)
jump_w = matrix(0.15,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_noinfo-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_fn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_fn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: fp (free gamma0) Gamma(0) > 0, Gamma(1) = 1
:PROPERTIES:
:ID:       3d57be6d-547d-40a8-81a1-43b45124dd57
:END:
#+BEGIN_SRC R :results none :tangle R/chessB_fp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_fp-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: pf (free gamma1) Gamma(0) = 1, Gamma(1) > 0
:PROPERTIES:
:ID:       dc374dfa-1995-4432-9929-038f3c5c52e0
:END:
#+BEGIN_SRC R :results none :tangle R/chessB_pf-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_pf-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** Choose-a-move test B: nf (free gamma1) Gamma(0) = -1, Gamma(1) > 0
:PROPERTIES:
:ID:       9b975f46-8639-4b53-8ee6-0eb16721eb63
:END:
#+BEGIN_SRC R :results none :tangle R/chessB_nf-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/chessB_nf-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Duolingo                                                          :ARCHIVE:
#+BEGIN_SRC R :results none :tangle no :results output :session
source("R/duolingo-preprocess.R")
source("R/duolingo-init.R")
#+END_SRC

#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
num_person = 726 ## max 726: do not change
num_item = 34 ## max 34

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
duolingo = readr::read_csv("data/duolingo_final.csv")
df = as_tibble(duolingo[,-1])[,1:4] ## drop row names
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

#+BEGIN_SRC R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(685,137,610,724,703)])
#+END_SRC

#+BEGIN_SRC R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(680,629,600,691,601)])
#+END_SRC

** knot selection
#+begin_src R :tangle R/duolingo-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-functions.R
tab_sj <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g >= m))
  }
  return(res)
}

tab_IY <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g == m))
  }
  return(res)
}
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+END_SRC

#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+begin_src R :results none :tangle R/duolingo-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/duolingo-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC
** boxplot

#+BEGIN_SRC R :results value :tangle R/duolingo-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/duolingo-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+BEGIN_SRC R :results none :tangle R/duolingo_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/duolingo_pn-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* MATH: Korea_PISA2015                                              :ARCHIVE:
** notebook
#+BEGIN_SRC R
source('R/pisa-KR-preprocess.R')
source('R/pisa-KR-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-preprocess.R
## pick_person = 1:615
pick_person = 1:615
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/Korea_PISA2015.rdata")
df = as_tibble(Korea_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+END_SRC

#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :results none :tangle R/pisa-KR-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

## exclude no person / no item
## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+BEGIN_SRC R :tangle R/art-functions.R
tabulate_id <- function(chrid) {
  ## reference table of charactor and numeric id
  chr <- sort(unique(chrid))
  out <- data.frame(chr = chr, num = seq_len(length(chr)))
  return(out)
}
to_numID <- function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID <- function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+END_SRC

#+begin_src R :tangle R/pisa-KR-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-KR-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-KR-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-KR-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

* Science: Korea_PISA2018                                           :ARCHIVE:
** notebook
#+BEGIN_SRC R
source('R/pisa-KR-sci2018-preprocess.R')
source('R/pisa-KR-sci2018-init.R')
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-preprocess.R
## pick_person = 1:798
pick_person = 1:798
## pick_item = 1:23 # (it seems like the first cluster)
pick_item = 1:23

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-preprocess.R
load("data/Korea_PISA2018.rdata")
df = as_tibble(Korea_2018)
## info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
## polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
## pdx = which(colnames(df) %in% polytomous)
## pdx = c(pdx,pdx + 184)
## df[,-pdx]
#+END_SRC


#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :results none :tangle R/pisa-KR-sci2018-preprocess.R
di = df[,1:(115 + 3)]
dt = df[,c(1:3,(115+4):233)]
its = c()
dt01 = dt[,pick_item] %>% na.omit
di01 = di[,pick_item] %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[is.na(di01)] = 999
di01[di01 == 2] = 1

## drop plytomous
di01 = di01[,-c(11,14,15)]
dt01 = dt01[,-c(11,14,15)]

## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+END_SRC

#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+END_SRC

** init
#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/pisa-KR-sci2018-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+END_SRC

** boxplot

#+BEGIN_SRC R :results value :tangle R/pisa-KR-sci2018-preprocess.R
di01_long <- reshape2::melt(di01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- reshape2::melt(dt01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+END_SRC

#+BEGIN_SRC R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 999))
#+END_SRC

[[file:figure/boxplot_ART.pdf]]
#+BEGIN_SRC R :tangle R/pisa-KR-sci2018-preprocess.R
pdf("figure/boxplot_ART.pdf")
## rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
## geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01[,4:6], aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
## print(rt_boxp)
print(logrt_boxp)
dev.off(which = dev.cur())
#+END_SRC

* C++ MCMC output
** Shell to run C++
#+begin_src sh :tangle run.sh
#!/usr/bin/env bash
out_dir="chessB_pn_noinfo_zero_theta_ncut2_free_zw/"
prename="R/chessB_noinfo-preprocess.R"
initname="R/chessB_pn-init.R"
n_chain=2

echo "================================"
echo "Output dir:" $out_dir
echo "preprocessing:" $prename
echo "initializing:" $initname
echo "n_chain:" $n_chain
echo "================================"

export STAN_NUM_THREADS=2
mkdir -p output
rm output/*
rm input/*

Rscript $prename
cp input/{mvar,mlen}.csv output/
cp run.sh output/
cp $prename output/
cp $initname output/

for ((v = 1; v <= $n_chain; v++))
do
    Rscript $initname
    ./main initialize parallel single_w single_z full latent no_gamma true false no_ars zero_theta $v 5000 5000 5
done
## explain comandline arguments:
 # continue initialize -> start new chains?
 # parallel serial -> parallel computation?
 # single_w double_w
 # single_z double_z
 # full sparse -> missing or not
 # latent no_latent -> update latent space?
 # gamma no_gamma -> update gamma?
 # true false -> can I play with the gamma sign?
 # correct incorrect false -> gamma for what process?
 # do_ars no_ars -> ARS for gamma
 # zero_theta nonzero_theta -> theta.k.0 is zero

mkdir -p $out_dir
mv output/* $out_dir
Rscript R/run-analysis.R $out_dir $n_chain
echo "Outputs are moved to" $out_dir"."
echo "================================"
#+end_src

#+begin_src sh
#!/usr/bin/env bash
out_dir="chessB_fn_noinfo_no_ARS/"

export STAN_NUM_THREADS=2
mkdir -p output
rm output/*
cp $out_dir\* ./output/

Rscript "R/chessB_fn-preprocess.R"
cp input/{mvar,mlen}.csv output/
cp run.sh output/

for v in {1..3}
do
    Rscript "R/chessB_fn-init.R"
    ./main continue parallel single_w single_z full latent gamma true incorrect no_ars $v 500 500 5
done

mkdir -p $out_dir
cp R/chessB_fn-init.R $out_dir
mv output/* $out_dir
Rscript R/run-analysis.R $out_dir
#+end_src

* Using R
** Initiate R analysis + prerequites
#+BEGIN_SRC R :tangle R/run-analysis.R
#!/usr/bin/env Rscript
args <- commandArgs(trailingOnly = TRUE)
# test if there is at least one argument: if not, return an error
if (length(args) == 0) {
  stop("At least one argument must be supplied (input file).n", call. = FALSE)
} else if (length(args) == 2) {
  # default output file
  num_chain <- args[2]
  HAS_REF <- 0
  ref_dir <- ""
} else if (length(args) == 1) {
  # default output file
  num_chain <- 3
  HAS_REF <- 0
  ref_dir <- ""
}
out_dir <- args[1]
double_z <- 0
double_w <- 0
## out_dir <- "chessB-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir, "figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir="chessB_pn_noinfo_no_ARS/"
num_chain <- 2; double_z <- 0; double_w <- 0; HAS_REF <- 0;
system(paste0("rm figure/*.pdf"))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :results none
source("R/art-analysis.R")
#+END_SRC

#+BEGIN_SRC R :results none
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir <- "verbal_pn/"
num_chain <- 3; double_z <- 0; double_w <- 0; HAS_REF <- 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
## system(paste0("mkdir -p ", out_dir, "figure/"))
## system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir <- "opusIII_pn/"
num_chain <- 3; double_z <- 0; double_w <- 0; HAS_REF <- 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
## system(paste0("mkdir -p ", out_dir, "figure/"))
## system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+END_SRC

#+BEGIN_SRC R
out_dir <- "pisa-KR-sci2018-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))

ref_dir <- "pisa-singleZ-singleW/"
HAS_REF <- 1

out_dir <- "pisa-KR-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))

HAS_REF <- 0
#+END_SRC

#+BEGIN_SRC R
num_chain <- 3; double_z <- 0; double_w <- 0;

out_dir <- "pisa-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mv figure/*.pdf ", out_dir,"figure/"))

out_dir <- "opusIII-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("mv figure/*.pdf figure/",out_dir))

out_dir <- "verbal-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("mv figure/*.pdf figure/",out_dir))
#+END_SRC

#+begin_src R
## install.packages("coda")
install.packages("dplyr")
install.packages("stringr")
install.packages("magrittr")
install.packages("bayesplot")
install.packages("foreach")
install.packages("doParallel")
install.packages("reshape2")
install.packages("readr")
install.packages("data.table")
install.packages("survival")
#+end_src

#+begin_src R
install.packages(c("ggplot2","ggrepel","fda","funFEM"))
#+end_src

#+BEGIN_SRC R :results none
## Rcpp::sourceCpp("comprisk.cpp")
install.packages("art_1.0.tar.gz", repos = NULL, type="source")
detach(package:art)
library(art)
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-analysis.R
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
##registerDoParallel(cores = detectCores() - 1)
stopImplicitCluster()
registerDoParallel(2)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle R/art-analysis.R
source('R/load-outputs.R')
## source('R/write_summary.R')
source('R/visual-latent-space-plot.R')
source('R/visual-trace-plot.R')
## source('R/CIF_posm.R')
## source('R/CIF.R')
#+END_SRC

print average acceptance rate per type of quantities: \lambda, \beta, \theta, z, w, \gamma, \sigma
#+BEGIN_SRC sh
cat output/summary.csv
#+END_SRC
** example to extract w0 and z0                                     :ARCHIVE:
#+begin_src R
out_dir <- "chessB_pn/"
num_chain <- 3
double_z <- 0
double_w <- 0
HAS_REF <- 0
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
## registerDoParallel(cores = detectCores() - 1)
registerDoParallel(6)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
source("R/load-outputs.R")

z0 <- matched$z0
w0 <- matched$w0

readr::write_csv(as.data.frame(w0), paste0(out_dir, "w0.csv"))
readr::write_csv(as.data.frame(z0), paste0(out_dir, "z0.csv"))
#+end_src

** Biclustering example
:PROPERTIES:
:EXPORT_FILE_NAME: biclustering_example
:END:

Method: cite:dhillon_co-clustering_2001
Dhillon, I. S., Co-clustering documents and words using bipartite spectral graph partitioning, In , Proceedings of the Seventh {{ACM SIGKDD}} International Conference on {{Knowledge}} Discovery and Data Mining (pp. 269–274) (2001). {New York, NY, USA}: {Association for Computing Machinery}.

Code: https://scikit-learn.org/stable/modules/biclustering.html
https://scikit-learn.org/stable/auto_examples/bicluster/plot_bicluster_newsgroups.html#sphx-glr-auto-examples-bicluster-plot-bicluster-newsgroups-py
*** initialization
=w0= and =z0= are matrices for latent item and respondent coordinates.
#+begin_src R :results none
out_dir <- "chessB_pn/"
num_chain <- 3
double_z <- 0
double_w <- 0
HAS_REF <- 0
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
## registerDoParallel(cores = detectCores() - 1)
stopImplicitCluster()
registerDoParallel(2)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

w0 <- readr::read_csv(paste0(out_dir, "w0.csv"))
z0 <- readr::read_csv(paste0(out_dir, "z0.csv"))
#+end_src

*** calculate Euclidean distance and Gaussian distance over all item-respondent pairs
- =dist_zw.csv= Euclidean dist
- =rbf_dist_zw.csv= Gaussian dist
#+begin_src R
D <- matrix(0, nrow = nrow(z0), ncol = nrow(w0))
for (i in 1:nrow(D)) {
  for (j in 1:ncol(D)) {
    D[i, j] <- sqrt(sum((z0[i, ] - w0[j, ])^2))
  }
}

RBF_D <- exp(-1 / 2 * D)
readr::write_csv(as.data.frame(D), paste0(out_dir, "dist_zw.csv"))
readr::write_csv(as.data.frame(RBF_D), paste0(out_dir, "rbf_dist_zw.csv"))
#+end_src


#+begin_src emacs-lisp :exports none
;; python
(require 'conda)
(conda-env-activate "tf")
#+end_src

*** biclustering using Python
See https://scikit-learn.org/stable/modules/biclustering.html for the spectral co-clustering method we implement below: ( https://scikit-learn.org/stable/auto_examples/bicluster/plot_spectral_coclustering.html#sphx-glr-auto-examples-bicluster-plot-spectral-coclustering-py)

#+NAME: 184db033-517c-4a42-b7dc-5999752f3fd6
#+begin_src jupyter-python :tangle latent-biclustering.py
import numpy as np
from matplotlib import pyplot as plt

from sklearn.cluster import SpectralCoclustering
from sklearn.metrics import consensus_score

import pandas as pd
D = pd.read_csv('chessB_pn/rbf_dist_zw.csv', sep=',',header=0)
data = D.values

plt.matshow(data, cmap=plt.cm.Blues)
plt.title("Original dataset")
#+end_src

#+RESULTS: 184db033-517c-4a42-b7dc-5999752f3fd6
:RESULTS:
: Text(0.5, 1.05, 'Original dataset')
[[file:./.ob-jupyter/5c410dc2c8c9bfc6c337607fd33e76ea2dbf1260.png]]
:END:

#+NAME: 9ec5811f-af20-43af-9d7a-b81193dd62ec
#+begin_src jupyter-python :tangle latent-biclustering.py
# row_idx = np.linspace(0,(data.shape[0]-1), num=data.shape[0]).astype(int)
# col_idx = np.linspace(0,(data.shape[1]-1), num=data.shape[1]).astype(int)
K = 2

model = SpectralCoclustering(n_clusters=K, random_state=0)
model.fit(data)

fit_data = data[np.argsort(model.row_labels_)]
fit_data = fit_data[:, np.argsort(model.column_labels_)]

plt.matshow(fit_data, cmap=plt.cm.Blues)
plt.title("After biclustering; rearranged to show biclusters")
#+end_src

#+RESULTS: 9ec5811f-af20-43af-9d7a-b81193dd62ec
:RESULTS:
: Text(0.5, 1.05, 'After biclustering; rearranged to show biclusters')
[[file:./.ob-jupyter/2358ac0c34e1b2d3ce346e94cce645b368b615be.png]]
:END:

#+NAME: 8eb17f79-bd45-4d6c-bb93-9df2515a0065
#+begin_src jupyter-python :tangle latent-biclustering.py
df_row = pd.DataFrame(model.row_labels_)
df_col = pd.DataFrame(model.column_labels_)

# save the dataframe as a csv file
df_row.to_csv("chessB_pn/cl_row" + str(K) + ".csv")
df_col.to_csv("chessB_pn/cl_col" + str(K) + ".csv")
#+end_src

#+RESULTS: 8eb17f79-bd45-4d6c-bb93-9df2515a0065

*** back to R for visualization
#+begin_src R :results none
source("R/art-functions.R")

K <- 2

w0 <- readr::read_csv(paste0(out_dir, "w0.csv"))
z0 <- readr::read_csv(paste0(out_dir, "z0.csv"))

cl_z <- readr::read_csv(paste0(out_dir, "cl_row", K, ".csv"))[, 2]
cl_w <- readr::read_csv(paste0(out_dir, "cl_col", K, ".csv"))[, 2]

xmin <- min(z0[, 1], w0[, 1])
ymin <- min(z0[, 2], w0[, 2])
xmax <- max(z0[, 1], w0[, 1])
ymax <- max(z0[, 2], w0[, 2])

pdf(paste0(out_dir, "spc_cl_dist_rbf", K, ".pdf"))

print(cl_lsjmplot(z0, w0, cl_z, cl_w, xlim = c(xmin, xmax), ylim = c(ymin, ymax)))

dev.off(which = dev.cur())
#+end_src

** WAIT simulation of survival times
:PROPERTIES:
:header-args:R: :tangle R/sim_surv_data.R
:END:
- State "WAIT"       from              [2021-02-19 Fri 03:55] \\
  see if it can be run in another machine
1. get break points for time
2. fix item, get item parameters + piecewise constant rates
3. calculate relative risk for each type (for all persons)
4. simulate survival time -> response
5. repeat for all items (40)
6. repeat for many MCMC samples (10000?)

Run =R/sim_surv_data.R= for the simulation, and find relevant data as
follows:
   #+begin_src R :tangle no
   time = sim_data[[item]][,1:251]
   pp = sim_data[[item]][,252:502]

   mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
   mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()
   #+end_src

- ~iter~: MCMC iteration
- ~time[iter, person]~: simulated survival time t
- ~pp[iter, person]~: simulated conditional probability of correct response given time t
- ~mi[item,person]~: observed response (1: correct, 0: incorrect)
- ~mi[item,person]~: observed response (1: correct, 0: incorrect)
- ~mt[item,person]~: observed time

The =RData= will be saved in =chessB_pn=. To run the simulation with no
distance term, set =out_dir <- "chessB_no_latent/"= in =R/sim_surv_data.R=.

#+begin_src R :results none
## out_dir <- "chessB_pn/"
## out_dir <- "chessB_np/"
out_dir <- "chessB_no_latent/"

num_chain <- 3
double_z <- 0
double_w <- 0
HAS_REF <- 0
## library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
## library(timereg)
## registerDoParallel(cores = detectCores() - 1)
registerDoParallel(2)
## stopImplicitCluster()

## setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
source("R/load-outputs.R")
#+end_src

#+begin_src R :tangle R/art-functions.R
gethaz_item <- function(sam, cname, item, N, theta = NULL) {
  num_iter <- nrow(sam)
  d_zw <- matrix(0, num_iter, N)

  for (k in 1:N) {
    ## distance calculation can be fully vectorized (and storing z), but I don't have time for this.
    z <- sam[, stringr::str_which(cname, paste0("^z\\.", 0, "\\.", k, "\\.[1-2]"))]
    w <- sam[, stringr::str_which(cname, paste0("^w\\.", 0, "\\.", item, "\\."))]
    d_zw[, k] <- sqrt(rowSums((z - w)^2))
  }
  beta <- sam[, stringr::str_which(cname, paste0("^beta\\.", item, "\\."))]

  if (is.null(theta)) {
    theta_temp <- sam[, stringr::str_which(cname, paste0("^theta\\."))] ## (theta.k.0 theta.k.1)
    teq <- seq(1, ncol(theta_temp), 2)
    gamma <- theta <- lambda <- rr <- list()
    theta[[1]] <- theta_temp[, teq]
    theta[[2]] <- theta_temp[, -teq]
  }

  gamma <- sam[1, stringr::str_which(cname, paste0("gamma\\."))]

  lambda_temp <- sam[, stringr::str_which(cname, paste0("^lambda\\.[0-1]\\.", item, "\\."))]
  leq <- seq(1, ncol(lambda_temp), 2)
  lambda[[1]] <- lambda_temp[, leq]
  lambda[[2]] <- lambda_temp[, -leq]

  for (cc in 1:2) rr[[cc]] <- exp(beta[, cc] + theta[[cc]] - gamma[c] * d_zw)

  res <- list(lambda = lambda, rr = rr, theta = theta)
  return(res)
}
#+end_src

#+begin_src R :tangle R/art-functions.R
gen_surv_time <- function(out, sj, H, N, nn) {
  rr <- out$rr
  lambda <- out$lambda
  mj <- length(sj)

  haz <- lambda[[1]][nn, ] %o% rr[[1]][nn, ] + lambda[[2]][nn, ] %o% rr[[2]][nn, ]
  logS <- -rexp(N)
  cumhaz <- rbind(rep(0, N), apply(haz * H, 2, cumsum))
  vtime <- numeric(N)

  for (kk in 1:N) {
    ss <- findInterval(-logS[kk], cumhaz[, kk])
    if (ss != mj) {
      vtime[kk] <- sj[ss] - (logS[kk] + cumhaz[ss, kk]) / haz[ss, kk]
    } else {
      vtime[kk] <- sj[ss]
    }
  }
  return(vtime)
}
#+end_src

#+begin_src R :tangle R/art-functions.R
gen_surv_pp <- function(out, time, sj) {
  rr <- out$rr
  lambda <- out$lambda
  num_iter <- nrow(time)
  hr <- list()
  seg_g <- findInterval(time, sj)
  mg <- length(sj)
  seg_g[seg_g == mg] <- (mg - 1)

  ## m is the number of rows in the matrix, r and c are row and column numbers respectively, and ind the linear index:
  ## ind = (c-1)*m + r
  ind <- (seg_g - 1) * num_iter + 1:num_iter

  for (cc in 1:2) hr[[cc]] <- lambda[[cc]][ind] * c(rr[[cc]])

  pp <- hr[[2]] / (hr[[1]] + hr[[2]])

  return(pp)
}
#+end_src

#+RESULTS:

#+begin_src R
set.seed(1)
num_iter <- nrow(mylist[[1]])
sim_data <- list()
for (item in 1:I) {
  start_time <- proc.time()
  stk_tt <- foreach(chain = 1:3, .combine = "rbind") %dopar% {
    out <- gethaz_item(mylist[[chain]], cname, item, N)
    time <- foreach(nn = 1:num_iter, .combine = "rbind") %do% {
      gen_surv_time(out, sj, H, N, nn)
    }
    pp <- gen_surv_pp(out, time, sj) %>% array(dim = dim(time))
    cbind(time, pp)
  }
  sim_data[[item]] <- stk_tt
  cat("\nelapsed time to simulate item", item, "\n")
  print(proc.time() - start_time)
}

save(sim_data, file = paste0(out_dir, "surv_sim.RData"))
#+end_src

#+begin_src R :tangle R/art-functions.R
## calculate baseline hazard and hazard ratio
## slow iteration
haz_fun_item <- function(sam, sj, item, N) {
  rel <- NULL
  for (k in 1:N) {
    param <- getparam(sam, sj, item, k)
    dist <- sqrt(rowSums((param$z - param$w)^2))
    rr <- exp(param$beta + param$theta - param$gamma * dist)
    rel <- rbind(rel, rr)
  }
  haz <- matrix(c(sj, 0, param$lambda[1, ], 0, param$lambda[2, ]), length(sj), 3)
  return(list(haz = haz, rel = rel))
}
#+end_src

#+begin_src R :tangle R/art-functions.R
## simulate survival time and response
## slow
gen_surv <- function(out, sj, N) {
  time <- numeric(N)
  for (k in 1:N) {
    hh <- cbind(sj, out$haz[, 2] * out$rel[k, 1] + out$haz[, 3] * out$rel[k, 2])
    time[k] <- timereg::rchaz(hh, n = 1, cum.hazard = FALSE)[, 2]
  }

  dd <- data.frame(time = time, status = rep(1, N))
  seg_temp <- survSplit(formula = Surv(time, status) ~ 1, cut = sj, data = dd, episode = "seg_g")
  seg_g <- seg_temp %>%
    filter(status == 1) %>%
    select(seg_g) %>%
    unlist()

  rr12 <- out$haz[seg_g, 2:3] * out$rel
  pp <- rr12[, 2] / rowSums(rr12)
  return(list(time = time, pp = pp))
}
#+end_src

#+RESULTS:

#+begin_src R :tangle no
mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()

for (item in 1:I){
time = sim_data[[item]][,1:251]
aa = mt[item,]
ss = 0
for (kk in 1:N) {
  ## print(sum(time[,kk] > aa[k]) / length(time[,kk]))
  ss = ss + sum(time[,kk] > aa[k]) / length(time[,kk])
  }
print(ss/N)
}
#+end_src

#+begin_src R :tangle no
## simluate survival time and competing events for all items and chains
## slow
sim_data <- list()
num_iter <- nrow(mylist[[1]])
for (item in 1:I) {
start_time <- proc.time()
stk_tt <-  foreach(chain = 1:3, .combine='cbind') %dopar% {
  foreach(ii=1:num_iter, .combine='cbind') %dopar% {
    out <- haz_fun_item(mylist[[chain]][ii,], sj, item, N)
    sim <- gen_surv(out, sj, N)
    cbind(sim$time,sim$pp)
  }
}
row.names(stk_tt) <- 1:N
sim_data[[item]] <- stk_tt
cat("\nelapsed time to simulate item",item,"\n")
print(proc.time() - start_time)
}
#+end_src
** load outputs
#+begin_src R :tangle R/load-outputs.R
mvar <- readr::read_csv(paste0(out_dir, "mvar.csv"), col_names = F) %>% as.matrix()
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

sj <- readr::read_csv(paste0(out_dir, "mlen.csv"), col_names = F) %>% as.matrix()
sj <- c(0, cumsum(sj))
H <- sj[2:(G + 1)] - sj[1:G]

cnames <- c(".chain", ".iteration")
for (c in 0:1) {
  for (i in 1:I) {
    for (g in 1:G) {
      cnames <- c(cnames, paste0("lambda.", c, ".", i, ".", g))
    }
  }
}

for (k in 1:N) {
  for (c in 0:1) {
    cnames <- c(cnames, paste0("theta.", k, ".", c))
  }
}
for (i in 1:I) {
  for (c in 0:1) {
    cnames <- c(cnames, paste0("beta.", i, ".", c))
  }
}

for (c in 0:1) {
  for (k in 1:N) {
    for (d in 1:2) {
      cnames <- c(cnames, paste0("z.", c, ".", k, ".", d))
    }
  }
}
for (c in 0:1) {
  for (i in 1:I) {
    for (d in 1:2) {
      cnames <- c(cnames, paste0("w.", c, ".", i, ".", d))
    }
  }
}

for (c in 0:1) {
  cnames <- c(cnames, paste0("gamma.", c))
}

cnames <- c(cnames, "sigma", "lp_")
#+end_src

#+RESULTS:
#+begin_example

[36m──[39m [1m[1mColumn specification[1m[22m [36m─────────────────────────────────────────────────────────────────────────────────[39m
cols(
  X1 = [32mcol_double()[39m,
  X2 = [32mcol_double()[39m,
  X3 = [32mcol_double()[39m,
  X4 = [32mcol_double()[39m
)

[36m──[39m [1m[1mColumn specification[1m[22m [36m─────────────────────────────────────────────────────────────────────────────────[39m
cols(
  X1 = [32mcol_double()[39m
)
#+end_example

#+BEGIN_SRC R :tangle R/load-outputs.R
## mythin = 10
## mystart = 5001
## myend = 25000

no_z1 <- !grepl("^z\\.1\\.", cnames)
no_w1 <- !grepl("^w\\.1\\.", cnames)

dlist <- list()

for (cid in 1:num_chain) {
  ## pisa-KR KR-sci data should skip 1000
  dlist[[cid]] <- readr::read_csv(paste0(out_dir, "sample_chain", cid, ".csv"), col_names = F, skip = 0) %>% as.data.frame()
  ## dlist[[cid]] = readr::read_csv(paste0(out_dir,"sample_chain",cid,".csv"), col_names=F) %>% as.data.frame()
  colnames(dlist[[cid]]) <- cnames
  if (!double_z && !double_w) {
    dlist[[cid]] <- dlist[[cid]][, no_z1 & no_w1] ## remove duplicates when single_z and single_w
  } else if (!double_w) {
    dlist[[cid]] <- dlist[[cid]][, no_w1] ## remove duplicates when single_w
  } else if (!double_z) {
    dlist[[cid]] <- dlist[[cid]][, no_z1] ## remove duplicates when single_z
  }
}

## mylist[[cid]] = mcmc(df, start = mystart, end = myend, thin = mythin)
#+END_SRC

#+RESULTS:

# TODO: This function is under revision!!
#+BEGIN_SRC R :tangle R/art-functions.R
my_procrustes <- function(Xstar, dlist, is_list = FALSE, my_translation = TRUE, my_scale = FALSE, my_reflect = TRUE) {
  posm <- 0
  if (is_list == TRUE) {
    num_chain <- length(dlist)
  } else {
    num_chain <- 1
  }
  for (i in 1:num_chain) {
    if (is_list == TRUE) {
      df <- dlist[[i]]
    } else {
      df <- dlist
    }

    num_samples <- nrow(df)

    z0dx <- grepl("^z\\.0\\.", colnames(df))
    z1dx <- grepl("^z\\.1\\.", colnames(df))
    w0dx <- grepl("^w\\.0\\.", colnames(df))
    w1dx <- grepl("^w\\.1\\.", colnames(df))

    no_z1 <- sum(z1dx) == 0
    no_w1 <- sum(w1dx) == 0

    num_w <- sum(w0dx) / 2
    num_z <- sum(z0dx) / 2
    w0 <- aperm(array(unlist(t(df[, w0dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    z0 <- aperm(array(unlist(t(df[, z0dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))

    w0star <- Xstar$w.0

    if (no_w1) {
      w1 <- NULL
    } else {
      w1star <- MCMCpack::procrustes(Xstar$w.1, w0star)$X.new
      w1 <- aperm(array(unlist(t(df[, w1dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    }
    if (no_z1) {
      z1 <- NULL
    } else {
      z1 <- aperm(array(unlist(t(df[, z1dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))
    }

    adx <- z0dx | z1dx | w0dx | w1dx

    mm <- foreach(k = 1:num_samples) %dopar% {
      pout <- MCMCpack::procrustes(w0[, , k], w0star)
      w0[, , k] <- pout$X.new
      z0[, , k] <- z0[, , k] %*% pout$R

      if (!no_w1) {
        pout <- MCMCpack::procrustes(w1[, , k], w1star)
        w1[, , k] <- pout$X.new
      }
      if (!no_z1) {
        z1[, , k] <- z1[, , k] %*% pout$R
      }
      rbind(z0[, , k], z1[, , k], w0[, , k], w1[, , k])
    }
    tmm <- lapply(mm, t)
    df[, adx] <- t(matrix(unlist(tmm), nrow = sum(adx)))

    posm <- posm + Reduce("+", mm) / num_samples
    if (is_list == TRUE) {
      dlist[[i]] <- df
    } else {
      dlist <- df
    }
  }

  posm <- posm / num_chain
  z0 <- posm[1:num_z, ]
  if (no_z1 && no_w1) {
    w0 <- posm[num_z + (1:num_w), ]
  } else if (no_z1 && !no_w1) {
    w0 <- posm[num_z + (1:num_w), ]
    w1 <- posm[num_z + num_w + (1:num_w), ]
  }

  if (!no_z1 && no_w1) {
    z1 <- posm[num_z + (1:num_z), ]
    w0 <- posm[2 * num_z + (1:num_w), ]
  } else if (!no_z1 && !no_w1) {
    z1 <- posm[num_z + (1:num_z), ]
    w0 <- posm[2 * num_z + (1:num_w), ]
    w1 <- posm[2 * num_z + num_w + (1:num_w), ]
  }
  return(list(dlist = dlist, z0 = z0, z1 = z1, w0 = w0, w1 = w1))
}
#+END_SRC
#+BEGIN_SRC R 
my_procrustes <- function(Xstar, dlist, is_list = FALSE, my_translation = TRUE, my_scale = FALSE, reflect = TRUE) {
  posm <- 0
  if (is_list == TRUE) {
    num_chain <- length(dlist)
  } else {
    num_chain <- 1
  }
  for (i in 1:num_chain) {
    if (is_list == TRUE) {
      df <- dlist[[i]]
    } else {
      df <- dlist
    }

    num_samples <- nrow(df)

    z0dx <- grepl("^z\\.0\\.", colnames(df))
    z1dx <- grepl("^z\\.1\\.", colnames(df))
    w0dx <- grepl("^w\\.0\\.", colnames(df))
    w1dx <- grepl("^w\\.1\\.", colnames(df))

    no_z1 <- sum(z1dx) == 0
    no_w1 <- sum(w1dx) == 0

    num_w <- sum(w0dx) / 2
    num_z <- sum(z0dx) / 2
    w0 <- aperm(array(unlist(t(df[, w0dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    z0 <- aperm(array(unlist(t(df[, z0dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))

    w0star <- Xstar$w.0

    if (no_w1) {
      w1 <- NULL
    } else {
      w1star <- MCMCpack::procrustes(Xstar$w.1, w0star, translation = my_translation, dilation = my_scale)$X.new
      w1 <- aperm(array(unlist(t(df[, w1dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    }
    if (no_z1) {
      z1 <- NULL
    } else {
      z1 <- aperm(array(unlist(t(df[, z1dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))
    }

    adx <- z0dx | z1dx | w0dx | w1dx

    mm <- foreach(k = 1:num_samples) %dopar% {
      pout <- MCMCpack::procrustes(w0[, , k], w0star, translation = my_translation, dilation = my_scale)
      w0[, , k] <- pout$X.new
      z0[, , k] <- t(t(pout$s * z0[, , k] %*% pout$R) + pout$tt)

      if (!no_w1) {
        pout <- MCMCpack::procrustes(w1[, , k], w1star, translation = my_translation, dilation = my_scale)
        w1[, , k] <- pout$X.new
      }
      if (!no_z1) {
        z1[, , k] <- t(t(pout$s * z1[, , k] %*% pout$R) + pout$tt)
      }
      rbind(z0[, , k], z1[, , k], w0[, , k], w1[, , k])
    }
    tmm <- lapply(mm, t)
    df[, adx] <- t(matrix(unlist(tmm), nrow = sum(adx)))

    posm <- posm + Reduce("+", mm) / num_samples
    if (is_list == TRUE) {
      dlist[[i]] <- df
    } else {
      dlist <- df
    }
  }

  posm <- posm / num_chain
  z0 <- posm[1:num_z, ]
  if (no_z1 && no_w1) {
    w0 <- posm[num_z + (1:num_w), ]
  } else if (no_z1 && !no_w1) {
    w0 <- posm[num_z + (1:num_w), ]
    w1 <- posm[num_z + num_w + (1:num_w), ]
  }

  if (!no_z1 && no_w1) {
    z1 <- posm[num_z + (1:num_z), ]
    w0 <- posm[2 * num_z + (1:num_w), ]
  } else if (!no_z1 && !no_w1) {
    z1 <- posm[num_z + (1:num_z), ]
    w0 <- posm[2 * num_z + (1:num_w), ]
    w1 <- posm[2 * num_z + num_w + (1:num_w), ]
  }
  return(list(dlist = dlist, z0 = z0, z1 = z1, w0 = w0, w1 = w1))
}
#+END_SRC

#+begin_src R :results none :tangle R/load-outputs.R
if (!HAS_REF) {
  Xstar <- find_xstar_inlist(dlist)
  readr::write_csv(as.data.frame(Xstar$z.0), paste0(out_dir, "z0star.csv"), col_names = FALSE)
  readr::write_csv(as.data.frame(Xstar$w.0), paste0(out_dir, "w0star.csv"), col_names = FALSE)
}
#+end_src

#+begin_src R :results none :tangle R/load-outputs.R
if (HAS_REF) {
  Xstar <- list()
  Xstar$z.0 <- readr::read_csv(paste0(ref_dir, "z0star.csv"), col_names = FALSE) %>% as.matrix()
  Xstar$w.0 <- readr::read_csv(paste0(ref_dir, "w0star.csv"), col_names = FALSE) %>% as.matrix()
}
#+end_src

#+BEGIN_SRC R :tangle R/load-outputs.R
matched <- my_procrustes(Xstar, dlist, is_list = T)
## , my_translation = TRUE, my_scale = FALSE)
mydf <- matched$dlist
mdf <- bind_rows(matched$dlist, .id = "column_label")
#+END_SRC

#+RESULTS:
: Error in { : task 1 failed - "non-conformable arrays"

#+BEGIN_SRC R :tangle R/load-outputs.R
mylist <- mcmc.list()
item <- 1
cname <- names(mydf[[1]])
mylist <- mcmc.list()
for (cid in 1:num_chain) {
  for (c in 0:1) {
    for (k in 1:N) {
      z <- mydf[[cid]][, stringr::str_which(cname, paste0("z\\.", c * double_z, "\\.", k, "\\.[1-2]"))]
      w <- mydf[[cid]][, stringr::str_which(cname, paste0("w\\.", c * double_w, "\\.", item, "\\."))]
      mydf[[cid]][[paste0("dist_z.", c, ".", k, "_", "w.", c, ".", item)]] <- sqrt(rowSums((z - w)^2))
    }
  }
  mylist[[cid]] <- mcmc(mydf[[cid]])
}
#+END_SRC

The posterior means of \beta, \theta, \lambda are exported to CSV files.
#+begin_src R :tangle R/write_summary.R
ss <- summary(mylist)
mm <- ss$statistics[, "Mean"]
rr <- c(grep("^beta", names(mm)), grep("^theta", names(mm)))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "beta_theta_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr <- grep("^lambda", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "lambda_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr <- grep("^^z\\.0\\.", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "z0_mean.csv"))
#+end_src

#+begin_src R :tangle R/write_summary.R
rr <- grep("^^z\\.0\\.", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "z0_mean.csv"))
#+end_src

#+BEGIN_SRC R :results none
## sink("output/mcmc_summary.txt")
cat("==================================")
cat("Rejection Rate")
cat("==================================")
rejectionRate(mylist)
cat("==================================")
cat("Effective Size")
cat("==================================")
effectiveSize(mylist)
cat("==================================")
cat("Summary")
cat("==================================")
summary(mylist)
## sink()
#+END_SRC

** latent space

HPD based latent plot
[[pdf:figure/latent_space_hpd.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
mcdf <- mcmc(mdf[, -1])
tn <- nrow(mcdf)
hpd <- apply(HPDinterval(mcdf, prob = 1 / tn), 1, median)

z0dx <- grepl("^z\\.0\\.", names(hpd))
z1dx <- grepl("^z\\.1\\.", names(hpd))
w0dx <- grepl("^w\\.0\\.", names(hpd))
w1dx <- grepl("^w\\.1\\.", names(hpd))

num_w <- sum(w0dx) / 2
num_z <- sum(z0dx) / 2
no_z1 <- sum(z1dx) == 0
no_w1 <- sum(w1dx) == 0
w0 <- matrix(hpd[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 <- NULL
} else {
  w1 <- matrix(hpd[w1dx], byrow = T, nrow = num_w, ncol = 2)
}
if (no_z1) {
  z1 <- NULL
} else {
  z1 <- matrix(hpd[z1dx], byrow = T, nrow = num_z, ncol = 2)
}

z0 <- matrix(hpd[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
myname <- c(1:N, paste0("I.", 1:I))

pdf("figure/latent_space_hpd.pdf")
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[pdf:figure/latent_space_med.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
med <- apply(mdf[, -1], 2, median)

z0dx <- grepl("^z\\.0\\.", names(med))
z1dx <- grepl("^z\\.1\\.", names(med))
w0dx <- grepl("^w\\.0\\.", names(med))
w1dx <- grepl("^w\\.1\\.", names(med))

num_w <- sum(w0dx) / 2
num_z <- sum(z0dx) / 2
no_z1 <- sum(z1dx) == 0
no_w1 <- sum(w1dx) == 0
w0 <- matrix(med[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 <- NULL
} else {
  w1 <- matrix(med[w1dx], byrow = T, nrow = num_w, ncol = 2)
}
if (no_z1) {
  z1 <- NULL
} else {
  z1 <- matrix(med[z1dx], byrow = T, nrow = num_z, ncol = 2)
}

z0 <- matrix(med[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
myname <- c(1:N, paste0("I.", 1:I))

pdf("figure/latent_space_med.pdf")
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2


[[file:figure/latent_space_mode.pdf]]
#+BEGIN_SRC R :tangle R/visual-latent-space-plot.R
if (!HAS_REF) {
  z0.star <- Xstar$z.0
  z1.star <- Xstar$z.1
  w0.star <- Xstar$w.0
  w1.star <- Xstar$w.1

  xmin <- min(z0.star[, 1], z1.star[, 1], w0.star[, 1], w1.star[, 1])
  ymin <- min(z0.star[, 2], z1.star[, 2], w0.star[, 2], w1.star[, 2])
  xmax <- max(z0.star[, 1], z1.star[, 1], w0.star[, 1], w1.star[, 1])
  ymax <- max(z0.star[, 2], z1.star[, 2], w0.star[, 2], w1.star[, 2])

  myname <- c(1:N, paste0("I.", 1:I))
  pdf("figure/latent_space_mode.pdf")
  print(lsjmplot(z0.star, w0.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  if (double_z && !double_w) {
    print(lsjmplot(z1.star, w0.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  } else if (double_z && double_w) {
    print(lsjmplot(z1.star, w1.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  } else if (!double_z && double_w) {
    print(lsjmplot(z0.star, w1.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  }

  dev.off(which = dev.cur())
}
#+END_SRC

#+RESULTS:
: pdf 
:   2


[[file:figure/latent_space_single.pdf]]
#+begin_src R
pdf("figure/latent_space_single.pdf")

k = 20

##df = mydf[[1]]
df = mydf[[2]]
num_samples = nrow(df)

z0dx = grepl("^z\\.0\\.", colnames(df))
z1dx = grepl("^z\\.1\\.", colnames(df))
w0dx = grepl("^w\\.0\\.", colnames(df))
w1dx = grepl("^w\\.1\\.", colnames(df))

num_w = sum(w0dx) / 2;
num_z = sum(z0dx) / 2;
aw0 = aperm( array(unlist( t(df[,w0dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
aw1 = aperm( array(unlist( t(df[,w1dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
az0 = aperm( array(unlist( t(df[,z0dx])), dim = c(2, num_z, num_samples)), c(2,1,3))
az1 = aperm( array(unlist( t(df[,z1dx])), dim = c(2, num_z, num_samples)), c(2,1,3))

z0 = az0[,,k]
z1 = az1[,,k]
w0 = aw0[,,k]
w1 = aw1[,,k]
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(1:N,paste0("I.",1:I))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf 
:   2

[[pdf:figure/latent_space_mean.pdf]]
#+begin_src R :tangle R/visual-latent-space-plot.R
pdf("figure/latent_space_mean.pdf")

z0 <- matched$z0
z1 <- matched$z1
w0 <- matched$w0
w1 <- matched$w1
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(1:N, paste0("I.", 1:I))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf 
:   2

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "verbal_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "verbal_pn_w.csv", col_names = TRUE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "opusIII_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "opusIII_pn_w.csv", col_names = TRUE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "chessB_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "chessB_pn_w.csv", col_names = TRUE)
#+END_SRC

#+RESULTS:

** trace plots
[[file:figure/lambda_mcmc_interval_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lambda_mcmc_interval_plot.pdf")
p0 <- mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.0\\.1\\.",
  transformations = "log"
)
## mcmc_areas(
##  lambda0.sam,
##  prob = 0.8, # 80% intervals
##  prob_outer = 0.99, # 99%
##  point_est = "mean"
## )

p1 <- mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.1\\.1\\.",
  transformations = "log"
)
print(p0)
print(p1)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2
[[file:figure/beta_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/beta_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^beta\\.[0-9]\\."
)
print(p)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/theta_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/theta_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^theta\\.[0-9]\\."
)
print(p)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/lambda_parcoord.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lambda_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^lambda\\.[0-1]\\.1\\.",
  transformations = "log"
)
print(p)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[pdf:figure/w_parcoord_plot.pdf::1]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/w_parcoord_plot.pdf")
p <- mcmc_parcoord(mylist,
  regex_pars = "^w\\.[0-1]\\.[1-5]\\."
)
print(p)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/dist_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/dist_mcmc_trace_plot.pdf")
p0 <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[0-2]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[3-6]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[7-9]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/lambda_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
colnames(df)[grepl("^w\\.1\\.", colnames(df))]


pdf("figure/lambda_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (item in 1:I) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^lambda\\.0\\.", item, "\\."),
    transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ", item, ".")))

  p <- mcmc_trace(mylist,
    regex_pars = paste0("^lambda\\.1\\.", item, "\\."),
    transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ", item, ".")))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: character(0)
: pdf 
:   2

[[file:figure/beta_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/beta_mcmc_trace_plot.pdf")
for (i in 1:I) {
  color_scheme_set("mix-blue-pink")
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^beta\\.", i, "\\."),
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  p + facet_text(size = 15)
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[pdf:figure/theta_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/theta_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (k in 1:50) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^theta\\.", k, "\\."),
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/gamma_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/gamma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
  regex_pars = "^gamma\\.",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/lp_sigma_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/lp_sigma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
  pars = c("sigma", "lp_"),
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2
*** latent space trace                                              :ARCHIVE:

[[pdf:figure/z_pairs_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/z_pairs_plot.pdf")
for (k in 1:min(N, 50)) {
  p <- mcmc_pairs(mylist,
    regex_pars = paste0("^z\\.[0-1]\\.", k, "\\."),
    off_diag_args = list(size = 0.05)
  )
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[pdf:figure/w_pairs_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/w_pairs_plot.pdf")
i_begin = 1
i_begin = i_begin + 1 * (var(mylist[[1]][, varnames(mylist)=="w.0.1.1"]) == 0) # start at item=2 if item=1 gives constant w.
for (i in i_begin:min(I, 50)) {
  p <- mcmc_pairs(mylist,
    regex_pars = paste0("^w\\.[0-1]\\.", i, "\\."),
    off_diag_args = list(size = 0.05)
  )
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

#+BEGIN_SRC R 
w = mylist[[1]][,grepl("^w\\.[0]\\.1\\.",cname)]
z = mylist[[1]][,grepl("^z\\.[0]\\.1\\.",cname)]

rowSums((z - w)^2)
#+END_SRC


[[file:figure/z_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
pdf("figure/z_mcmc_trace_plot.pdf")
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[0-2]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[3-6]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[7-9]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
print(p)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

[[file:figure/w_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/w_mcmc_trace_plot.pdf")
for (i in 1:min(I, 40)) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^w\\.[0-1]\\.", i, "\\."),
    ## transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: pdf 
:   2

** output analysis

#+BEGIN_SRC R :tangle R/CIF_posm.R
tmp <- foreach(v = 1:num_chain, .combine = "rbind") %dopar% apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp <- tmp[, 1:(which(colnames(mydf[[1]]) == "lp_"))]
  posm <- apply(tmp, 2, mean)
} else {
  posm <- tmp[1:(which(colnames(mydf[[1]]) == "lp_"))]
}

cname <- names(posm)
param <- getparam(posm, sj, i, k)
#+END_SRC

[[file:figure/tradeoff.pdf]]
#+BEGIN_SRC R :tangle R/CIF.R
## accuracy = foreach(k=1:N, .combine='rbind') %dopar% fun_accuracy_ick(t,i,k,posm,cname,sj)
pdf(paste0("figure/tradeoff.pdf"))
for (item in 1:I) {
  time <- 1:(sj[G] + 10)
  accuracy <- foreach(k = 1:N, .combine = "rbind") %dopar% {
    param <- getparam(posm, sj, item, k)
    eval_accuracy(param, time)
  }

  plotdf <- reshape::melt(accuracy, id.vars = c("time"))
  colnames(plotdf) <- c("person", "time", "accuracy")

  p <- ggplot(data = plotdf, aes(x = time, y = accuracy, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Plot of speed-accuracy tradeoff for item ", item, "."))
  print(p)
}
dev.off(which = dev.cur())

## system(paste0("open figure/tradeoff_", item, ".pdf")
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
getparam <- function(posm, sj, i, k) {
  cname <- names(posm)
  z <- posm[stringr::str_which(cname, paste0("z\\.[0-1]\\.", k, "\\.[1-2]"))] %>%
    matrix(nrow = 2, ncol = 2) %>%
    t()
  w <- posm[stringr::str_which(cname, paste0("w\\.[0-1]\\.", i, "\\.[1-2]"))] %>%
    matrix(nrow = 2, ncol = 2) %>%
    t()
  gamma <- posm[stringr::str_which(cname, paste0("gamma"))]
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\."))]
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\."))]
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.[0-1]\\.", i, "\\."))] %>%
    matrix(ncol = 2) %>%
    t()
  H <- sj[2:(G + 1)] - sj[1:G]
  res <- list(lambda = lambda, beta = beta, theta = theta, gamma = gamma, z = z, w = w, sj = sj, H = H)
  if (any(unlist(lapply(res, is.na)))) stop("Index out of range")
  ## should if be G+1? or G?
  ## if (ncol(lambda) != (G+1)) stop("ncol(lambda) != G+1")
  if (ncol(lambda) != (G)) {
    stop("ncol(lambda) != G")
  } else {
    return(res)
  }
}
#+END_SRC

#+BEGIN_SRC R
param = getparam(posm, sj, i, k)

ll = 0;
uu = 50

cumcicurve(param, 1, ll, uu, 50);
cumcifun(param, 1, ll, uu);
#+END_SRC

#+BEGIN_SRC R
##CIF = foreach (k=1:50, .combine='rbind') %dopar% {
##integrand <- function(t) {
##  fun_hazard_surv(t,i,k,posm,cname,sj)
##}
##CIF_k = foreach(t=1:200, .combine='c') %dopar% {
##  integrate(integrand, lower = t-1, upper = t)$value
##}
##cumsum(CIF_k)
##}
#+END_SRC

[[pdf:figure/CIF.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF.R
myN <- min(100, N)
maxt <- sj[G + 1] + 10
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF.pdf"))

for (item in 1:I) {
  CIF_T <- foreach(k = 1:myN, .combine = "rbind") %do% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(k = 1:myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), time)
  CIF_F <- data.frame(t(CIF_F), time)
  plot_T <- reshape::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "person", "CIF")
  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ", item, ")."))
  print(p)

  plot_F <- reshape::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "person", "CIF")
  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ", item, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

[[pdf:figure/CIF_person.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF_person.R
## choose a few people adn items from latent space
z0 <- matched$z0
w0 <- matched$w0
## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci
myI <- sort(c(8, 12, 14, 17, 1, 6, 13, 18)) ## pisa KR

which_z <- function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

myN <- NULL
for (i in 1:length(myI)) {
  myN <- c(myN, which_z(w0[myI[i], ], z0))
}
myN <- c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt <- sj[G + 1] + 10
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_person.pdf"))

for (k in myN) {
  CIF_T <- foreach(item = myI, .combine = "rbind") %do% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(item = myI, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), c(time))
  colnames(CIF_T) <- c(paste0("I", myI), "time")

  plot_T <- reshape2::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "item", "CIF")

  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = item)) +
    geom_line(aes(color = factor(item)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (person ", k, ")."))
  print(p)

  CIF_F <- data.frame(t(CIF_F), c(time))
  colnames(CIF_F) <- c(paste0("I", myI), "time")

  plot_F <- reshape2::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "item", "CIF")

  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = item)) +
    geom_line(aes(color = factor(item)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (person ", k, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: Error: object 'matched' not found
: Error: object 'matched' not found
: Error in which_z(w0[myI[i], ], z0) : object 'z0' not found
: Error in is.data.frame(x) : object 'z0' not found
: Error: object 'sj' not found
: Error in seq.default(0, maxt, (maxt)/num_seg) : object 'maxt' not found
: null device
:           1

[[pdf:figure/latent_space_person.pdf]]
#+begin_src R :tangle R/CIF_person.R
pdf("figure/latent_space_person.pdf")

z1 <- matched$z1
w1 <- matched$w1
z0 <- matched$z0[myN, ]
w0 <- matched$w0[myI, ]

xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(myN, paste0("I.", myI))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+BEGIN_SRC R :tangle R/CIF_person.R
system(paste0("rsync -v figure/CIF_person.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_person.pdf ", out_dir, "figure/"))
#+END_SRC

[[pdf:figure/latent_space_cl1.pdf]]
#+begin_src R :tangle R/CIF_cl.R
pdf("figure/latent_space_cl1.pdf")

## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci

## myN = c(23,37,20,27,33,36) ## marketing
## myI = 1:I # marketing

## myN = c(62,589,14,219,524,509,161,435,252,595) ## pisa KR
## myI = 1:I # pisa KR

## myN = c(518, 584, 370, 418, 79, 276, 572, 358, 73, 274) ## pisa
## myI = 1:I # pisa

myN <- c(270, 367, 712, 17, 615, 265, 653, 484, 155, 290) ## pisa KR sci
myI <- 1:I # pisa KR sci

z1 <- matched$z1
w1 <- matched$w1
z0 <- matched$z0[myN, ]
w0 <- matched$w0[myI, ]

xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(myN, paste0("I.", myI))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

[[pdf:figure/CIF_cl1.pdf::1]]
#+BEGIN_SRC R :tangle R/CIF_cl1.R
## choose a few people adn items from latent space

which_z <- function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

## myN = NULL
## for (i in 1:length(myI)) {
## myN = c(myN, which_z(w0[myI[i],],z0))
## }
## myN = c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt <- sj[G] + 500
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_cl1.pdf"))

for (item in myI) {
  CIF_T <- foreach(k = myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(k = myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), c(time))
  colnames(CIF_T) <- c(myN, "time")

  plot_T <- reshape2::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "person", "CIF")

  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ", item, ")."))
  print(p)

  CIF_F <- data.frame(t(CIF_F), c(time))
  colnames(CIF_F) <- c(myN, "time")

  plot_F <- reshape2::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "person", "CIF")

  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ", item, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+END_SRC

#+BEGIN_SRC R :tangle R/CIF_cl1.R
system(paste0("rsync -v figure/CIF_cl1.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_cl1.pdf ", out_dir, "figure/"))
#+END_SRC

#+BEGIN_SRC R
mN = length(myN)
mise = matrix(0,mN,mN)
for (kk in 1:(mN-1)) {
  for (ll in (kk+1):mN) {
    mise[ll,kk] = sum((CIF_T[,kk] - CIF_T[,ll])^2) / maxt
  }
}
#+END_SRC

#+BEGIN_SRC R
posm_CIF_T = CIF_T[,-ncol(CIF_T)]
num_iter = min(unlist(lapply(mydf,  nrow)))

mises = foreach(v=1:num_chain, .combine='rbind') %dopar% {
  foreach(nn = seq(1, num_iter, 10), .combine='rbind') %dopar% {
    CIF_T = foreach (k = myN, .combine='cbind') %dopar% {
      c(0,cumcicurve(getparam(unlist(mydf[[v]][nn,]), sj, item, k), 1, 0, maxt, num_seg))
    }
    colSums((posm_CIF_T - CIF_T)^2) / maxt
  }
}
#+END_SRC

#+BEGIN_SRC R
apply(mises, 2, median)
#+END_SRC

#+BEGIN_SRC R

sam = mydf[[v]][,1:( which( colnames(mydf[[v]]) == "lp_") )]

CIF_T = foreach (k = myN, .combine='rbind') %dopar% {
  c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
}

}
apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp = tmp[,1:( which( colnames(mydf[[1]]) == "lp_") )]
  posm = apply(tmp, 2, mean)
} else {
  posm = tmp[1:( which( colnames(mydf[[1]]) == "lp_") )]
}

cname = names(posm)
param = getparam(posm,sj,i,k)
#+END_SRC
** FDA
#+BEGIN_SRC R
library(fda)
library(funFEM)
##library(fda.usc)
#+END_SRC

[[file:figure/functionDA.pdf]]
#+BEGIN_SRC R
tmp = as.matrix(CIF_T)
y = tmp[, -ncol(tmp)]
x = tmp[, ncol(tmp)]

## basis <- create.polygonal.basis(x)
## basis <- create.bspline.basis(c(0, max(x)), nbasis=50, norder=4) #below 0 occurs
basis <- create.bspline.basis(c(0, max(x)), nbasis=10)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=99)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=10)
##basis = create.monomial.basis(c(0, max(x)), nbasis=10)
##basis = create.exponential.basis(c(0, max(x)), nbasis=9) # not work
fdobj <- smooth.basis(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd
##fdobj <- smooth.monotone(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd

pdf("figure/functionDA.pdf")
plot(fdobj)
dev.off(which = dev.cur())
#+END_SRC

#+BEGIN_SRC R
kran = 2:2
## res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)
## res = funFEM(fdobj,K=kran,model='AkjBk',crit="icl",init='hclust',lambda=0,disp=TRUE)
res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)

## plot(kran,res$plot$bic,type='b',xlab='K',main='ICL')
#+END_SRC

[[file:figure/functional-clustering.pdf]]
#+begin_src R
pdf("figure/functional-clustering.pdf")
par(mfrow=c(1,2))
plot(fdobj,col=res$cls,lwd=2,lty=1)
fdmeans = fdobj;
fdmeans$coefs = t(res$prms$my)
plot(fdmeans,col=1:max(res$cls),lwd=2)
dev.off(which = dev.cur())
#+end_src

* posterior checking
Rcpp probability distribution: https://teuder.github.io/rcpp4everyone_en/220_dpqr_functions.html
to test my code
1. Use the observed response time. See if the latent model has higher hazard for the true response on average. If not, possible errors in hazard calculation...
conclusion: =chessB_pn= works poor. =chessB_np= works a bit ok.

** with *no* time simulation
#+begin_src R :results none :tangle R/test_simcode.R
out_dir <- "chessB_pn/"
## out_dir <- "chessB_no_latent/"
## out_dir <- "chessB_np/"

mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()

num_chain <- 3
double_z <- 0
double_w <- 0
HAS_REF <- 0
## library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
## library(timereg)
## registerDoParallel(cores = detectCores() - 1)
registerDoParallel(2)
## stopImplicitCluster()

## setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")
source("R/load-outputs.R")

## save(mylist, file = paste0(out_dir,"mylist"))
#+end_src

#+begin_src R :results none :tangle R/test_simcode.R
set.seed(1)
num_iter <- nrow(mylist[[1]])
sim_data <- list()
mll  <- 99 * mi

for (item in 1:I) {
  start_time <- proc.time()
  stk_tt <- foreach(chain = 1:1, .combine = "rbind") %do% {
    out <- gethaz_item(mylist[[chain]], cname, item, N)
    time <- matrix(mt[item, ], nrow = num_iter, ncol = N, byrow=T)
    pp <- gen_surv_pp(out, time, sj) %>% array(dim = dim(time))
    ## cbind(time, pp)

  for (k in 1:N) {
    mll[item, k] = MLmetrics::LogLoss(pp[, k], mi[item, k])
    }

  }
  sim_data[[item]] <- stk_tt
  cat("\nelapsed time to simulate item", item, "\n")
  print(proc.time() - start_time)
}

save(mll,file = paste0(out_dir,"mll.RData"))
#+end_src

[[pdf:chessB_pn/LogLoss.pdf::1]]
[[pdf:chessB_np/LogLoss.pdf::1]]
[[pdf:chessB_np/LogLoss_by.pdf::1]]
[[pdf:chessB_no_latent/LogLoss.pdf::1]]
[[pdf:chessB_no_latent/LogLoss_by.pdf::1]]


#+begin_src R :tangle R/test_simcode.R
dll = t(mll)
colnames(dll) = row.names(mi) = 1:I
row.names(dll) = colnames(mi) = 1:N
d_long <- reshape2::melt(dll)
mi_long <- reshape2::melt(t(mi))
d_long = plyr::join(d_long, mi_long, by = c("Var1","Var2"))
names(d_long) = c("person","item","LogLoss","res")
d_long$res = factor(d_long$res, labels=c("incorrect","correct"))
ll_boxp <- ggplot(d_long, aes(x=item,y=LogLoss,fill=factor(item))) +  facet_wrap(~res) +
  geom_boxplot() + theme(legend.position = "none") + ylim(0, 10.5)

pdf(paste0(out_dir,"LogLoss_by.pdf"))
print(ll_boxp)
dev.off()
#+end_src

#+RESULTS:
: quartz
:      2
[[pdf:LogLoss_diff.pdf::1]]
[[pdf:LogLoss_diff_by.pdf::1]]
#+begin_src R
fname = "mll.RData"
pname = "LogLoss_diff_by.pdf"
#+end_src

#+begin_src R :tangle R/draw_logloss_diff_by.R
out_dir = "chessB_np/"
load(paste0(out_dir,fname))
dll = t(mll)
colnames(dll) = row.names(mi) = 1:I
row.names(dll) = colnames(mi) = 1:N
d_long <- reshape2::melt(dll)
mi_long <- reshape2::melt(t(mi))
d_long = plyr::join(d_long, mi_long, by = c("Var1","Var2"))

out_dir = "chessB_no_latent/"
load(paste0(out_dir,fname))
dll = t(mll)
colnames(dll) = 1:I
row.names(dll) = 1:N
no_long <- reshape2::melt(dll)
d_long = plyr::join(d_long, no_long, by = c("Var1","Var2"))

out_dir = "chessB_pn/"
load(paste0(out_dir,fname))
dll = t(mll)
colnames(dll) = 1:I
row.names(dll) = 1:N
np_long <- reshape2::melt(dll)
d_long = plyr::join(d_long, np_long, by = c("Var1","Var2"))

names(d_long) = c("person","item","LogLoss_np","res", "LogLoss_no", "LogLoss_pn")
d_long$LogLoss_diff_np = d_long$LogLoss_no - d_long$LogLoss_np
d_long$LogLoss_diff_pn = d_long$LogLoss_no - d_long$LogLoss_pn

d_long$res = factor(d_long$res, labels=c("incorrect","correct"))
ll_boxp_np_by <- ggplot(d_long, aes(x=item,y=LogLoss_diff_np,fill=factor(item))) + facet_wrap(~res) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - (-,+) log loss")+
  ylab("Difference in LogLoss")

ll_boxp_pn_by <- ggplot(d_long, aes(x=item,y=LogLoss_diff_pn,fill=factor(item))) + facet_wrap(~res) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - (+,-) log loss") +
    ylab("Difference in LogLoss")

ll_boxp_np <- ggplot(d_long, aes(x=item,y=LogLoss_diff_np,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - (-,+) log loss")+
  ylab("Difference in LogLoss")

ll_boxp_pn <- ggplot(d_long, aes(x=item,y=LogLoss_diff_pn,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - (+,-) log loss") +
    ylab("Difference in LogLoss")

pdf(pname)
print(ll_boxp_np_by)
print(ll_boxp_pn_by)
print(ll_boxp_np)
print(ll_boxp_pn)
dev.off()
#+end_src

#+begin_src R
out_dir = "chessB_np/"

dd_se = function(x) sd(x) / sqrt(N)
dd = d_long %>% group_by(item)
dif = dd %>% summarise_at(vars(LogLoss_diff_pn, LogLoss_diff_np),list(mean = mean, se = dd_se ))
prin = dif[,c(1,2,4,3,5)]
names(prin) = c("item", "pos_neg", "se_pn", "neg_pos",  "se_np")
round(prin,3) %>% knitr::kable()
readr::write_csv(prin, file = paste0(out_dir, "logloss_diff.csv"))
#+end_src

#+RESULTS:
#+begin_example


| item| pos_neg| se_pn| neg_pos| se_np|
|----:|-------:|-----:|-------:|-----:|
|    1|  -0.935| 0.039|   0.692| 0.041|
|    2|  -0.944| 0.038|   0.636| 0.040|
|    3|  -0.892| 0.040|   0.460| 0.040|
|    4|  -0.938| 0.038|   0.511| 0.040|
|    5|  -0.919| 0.039|   0.540| 0.040|
|    6|  -0.882| 0.040|   0.326| 0.038|
|    7|  -0.888| 0.039|   0.331| 0.037|
|    8|  -0.854| 0.041|   0.221| 0.035|
|    9|  -0.613| 0.045|   0.059| 0.029|
|   10|  -0.771| 0.043|   0.350| 0.040|
|   11|  -0.747| 0.043|   0.089| 0.031|
|   12|  -0.606| 0.045|   0.034| 0.026|
|   13|  -0.659| 0.043|   0.165| 0.033|
|   14|  -0.593| 0.045|   0.049| 0.028|
|   15|  -0.814| 0.042|   0.178| 0.033|
|   16|  -0.328| 0.043|  -0.013| 0.024|
|   17|  -0.413| 0.045|   0.118| 0.032|
|   18|  -0.289| 0.042|   0.120| 0.031|
|   19|  -0.412| 0.044|   0.087| 0.029|
|   20|  -0.100| 0.038|   0.048| 0.028|
|   21|  -0.942| 0.038|   0.575| 0.039|
|   22|  -0.838| 0.041|   0.374| 0.038|
|   23|  -0.800| 0.041|   0.349| 0.038|
|   24|  -0.320| 0.043|   0.021| 0.026|
|   25|  -0.768| 0.041|   0.331| 0.038|
|   26|  -0.316| 0.044|  -0.017| 0.023|
|   27|  -0.066| 0.033|   0.026| 0.025|
|   28|  -0.267| 0.044|   0.095| 0.030|
|   29|  -0.501| 0.044|   0.096| 0.031|
|   30|  -0.046| 0.033|   0.137| 0.032|
|   31|  -0.955| 0.038|   0.711| 0.041|
|   32|  -0.933| 0.038|   0.643| 0.040|
|   33|  -0.920| 0.039|   0.432| 0.039|
|   34|  -0.425| 0.044|  -0.009| 0.024|
|   35|  -0.510| 0.043|   0.065| 0.028|
|   36|  -0.473| 0.043|   0.100| 0.030|
|   37|  -0.135| 0.038|   0.008| 0.025|
|   38|  -0.257| 0.040|  -0.005| 0.024|
|   39|  -0.383| 0.044|   0.043| 0.027|
|   40|  -0.125| 0.037|   0.167| 0.033|
#+end_example

#+begin_src R
dd = d_long %>% group_by(item,res)
dif = dd %>% summarise_at(vars(LogLoss_diff_pn, LogLoss_diff_np),list(mean = mean, se = dd_se ))
prin_by = dif[,c(1,2,3,5,4,6)]
names(prin_by) = c("item", "res", "pos_neg", "se_pn", "neg_pos",  "se_np")
cbind(prin_by[,2], round(prin_by[,-2],3)) %>% knitr::kable()

readr::write_csv(prin_by, file = paste0(out_dir, "logloss_diff_by.csv"))
#+end_src

#+RESULTS:
#+begin_example


|res       | item| pos_neg| se_pn| neg_pos| se_np|
|:---------|----:|-------:|-----:|-------:|-----:|
|incorrect |    1|  -0.083| 0.014|  -0.126| 0.018|
|correct   |    1|  -0.970| 0.038|   0.726| 0.041|
|incorrect |    2|  -0.146| 0.019|  -0.318| 0.034|
|correct   |    2|  -0.995| 0.037|   0.696| 0.037|
|incorrect |    3|  -0.164| 0.015|  -0.270| 0.026|
|correct   |    3|  -1.051| 0.037|   0.620| 0.035|
|incorrect |    4|  -0.237| 0.009|  -0.398| 0.024|
|correct   |    4|  -1.033| 0.037|   0.634| 0.035|
|incorrect |    5|  -0.178| 0.016|  -0.332| 0.025|
|correct   |    5|  -1.012| 0.037|   0.650| 0.036|
|incorrect |    6|  -0.203| 0.010|  -0.318| 0.024|
|correct   |    6|  -1.109| 0.035|   0.542| 0.031|
|incorrect |    7|  -0.200| 0.013|  -0.324| 0.027|
|correct   |    7|  -1.109| 0.034|   0.541| 0.029|
|incorrect |    8|  -0.208| 0.012|  -0.292| 0.023|
|correct   |    8|  -1.174| 0.034|   0.474| 0.029|
|incorrect |    9|  -0.107| 0.016|  -0.149| 0.023|
|correct   |    9|  -1.317| 0.033|   0.348| 0.026|
|incorrect |   10|  -0.113| 0.016|  -0.161| 0.024|
|correct   |   10|  -1.078| 0.038|   0.589| 0.036|
|incorrect |   11|  -0.167| 0.014|  -0.221| 0.022|
|correct   |   11|  -1.278| 0.033|   0.372| 0.027|
|incorrect |   12|  -0.106| 0.018|  -0.154| 0.025|
|correct   |   12|  -1.325| 0.032|   0.305| 0.018|
|incorrect |   13|  -0.100| 0.018|  -0.155| 0.026|
|correct   |   13|  -1.170| 0.034|   0.458| 0.026|
|incorrect |   14|  -0.097| 0.016|  -0.143| 0.024|
|correct   |   14|  -1.329| 0.033|   0.335| 0.022|
|incorrect |   15|  -0.179| 0.014|  -0.253| 0.024|
|correct   |   15|  -1.208| 0.034|   0.444| 0.025|
|incorrect |   16|  -0.030| 0.019|  -0.065| 0.024|
|correct   |   16|  -1.466| 0.032|   0.184| 0.016|
|incorrect |   17|  -0.018| 0.020|  -0.055| 0.025|
|correct   |   17|  -1.198| 0.042|   0.461| 0.032|
|incorrect |   18|   0.015| 0.021|  -0.019| 0.025|
|correct   |   18|  -1.106| 0.040|   0.495| 0.034|
|incorrect |   19|  -0.012| 0.023|  -0.067| 0.027|
|correct   |   19|  -1.223| 0.030|   0.401| 0.023|
|incorrect |   20|   0.036| 0.021|   0.013| 0.024|
|correct   |   20|  -1.444| 0.058|   0.395| 0.051|
|incorrect |   21|  -0.193| 0.011|  -0.401| 0.032|
|correct   |   21|  -1.010| 0.036|   0.664| 0.035|
|incorrect |   22|  -0.132| 0.016|  -0.231| 0.030|
|correct   |   22|  -1.079| 0.035|   0.581| 0.031|
|incorrect |   23|  -0.114| 0.019|  -0.205| 0.029|
|correct   |   23|  -1.081| 0.033|   0.576| 0.031|
|incorrect |   24|  -0.020| 0.019|  -0.055| 0.025|
|correct   |   24|  -1.341| 0.036|   0.278| 0.023|
|incorrect |   25|  -0.105| 0.019|  -0.185| 0.026|
|correct   |   25|  -1.079| 0.033|   0.573| 0.033|
|incorrect |   26|  -0.029| 0.018|  -0.060| 0.024|
|correct   |   26|  -1.499| 0.037|   0.161| 0.016|
|incorrect |   27|   0.043| 0.022|   0.009| 0.026|
|correct   |   27|  -1.326| 0.029|   0.217| 0.021|
|incorrect |   28|   0.026| 0.023|  -0.013| 0.026|
|correct   |   28|  -1.242| 0.040|   0.456| 0.033|
|incorrect |   29|  -0.055| 0.019|  -0.096| 0.025|
|correct   |   29|  -1.233| 0.031|   0.412| 0.030|
|incorrect |   30|   0.076| 0.023|   0.045| 0.025|
|correct   |   30|  -0.907| 0.044|   0.786| 0.045|
|incorrect |   31|  -0.141| 0.006|  -0.259| 0.017|
|correct   |   31|  -0.969| 0.038|   0.727| 0.040|
|incorrect |   32|  -0.064| 0.021|  -0.249| 0.038|
|correct   |   32|  -0.989| 0.036|   0.700| 0.037|
|incorrect |   33|  -0.218| 0.013|  -0.352| 0.025|
|correct   |   33|  -1.065| 0.036|   0.594| 0.033|
|incorrect |   34|  -0.057| 0.018|  -0.094| 0.024|
|correct   |   34|  -1.414| 0.032|   0.221| 0.016|
|incorrect |   35|  -0.062| 0.019|  -0.113| 0.025|
|correct   |   35|  -1.247| 0.029|   0.359| 0.022|
|incorrect |   36|  -0.037| 0.020|  -0.089| 0.026|
|correct   |   36|  -1.201| 0.030|   0.415| 0.025|
|incorrect |   37|   0.022| 0.020|  -0.007| 0.025|
|correct   |   37|  -1.552| 0.045|   0.146| 0.021|
|incorrect |   38|  -0.012| 0.020|  -0.045| 0.025|
|correct   |   38|  -1.413| 0.024|   0.183| 0.014|
|incorrect |   39|  -0.028| 0.020|  -0.066| 0.025|
|correct   |   39|  -1.318| 0.035|   0.331| 0.024|
|incorrect |   40|   0.072| 0.023|   0.038| 0.026|
|correct   |   40|  -0.961| 0.041|   0.712| 0.039|
#+end_example


*** [2021-03-01 Mon] histogram of simulated survival time (correct vs incorrect)

[[pdf:chessB_np/hist_time.pdf::1]]
[[pdf:chessB_pn/hist_time.pdf::1]]
[[pdf:chessB_no_latent/hist_time.pdf::1]]
#+begin_src R
out_dir = "chessB_no_latent/"
out_dir = "chessB_np/"
out_dir = "chessB_pn/"

load(paste0(out_dir, "surv_sim.RData"))

pdf(paste0(out_dir,"hist_time.pdf"))
for (i in 1:I) {
 time = sim_data[[i]][, 1:251]
 time_cor = time[,mi[i,] == 1]
 time_incor = time[,mi[i,] == 0]
 par(mfrow = c(1,2))
 hist(time_cor,main=paste0("correct_item",i))
 hist(time_incor,main=paste0("incorrect_item",i))
 }
dev.off()
#+end_src

#+RESULTS:
: null device
:           1

*** TODO found discrepancy b/w log-likelihood. see if the diffence is consistent
#+begin_src R
num_iter <- nrow(mylist[[1]])
ll <- rep(0, num_iter)
for (nn in 1:3) {
  for (item in 1:I) {
    for (k in 1:N) {
      ll[nn] <- ll[nn] + eval_log_like(getparam(mylist[[1]][nn, ], sj, item, k), mi[item, k], mt[item, k])
    }
  }
}

#+end_src

#+RESULTS:

#+begin_src R
mylist[[1]][1:5,"lp_"] %>% diff()
ll[1:5] %>% diff()
#+end_src

#+RESULTS:
: [1]  31.5 -57.8  62.9 -21.5
: [1]    22.80881   -30.98535 33521.58194     0.00000
** with simulated time
#+begin_src R :results none
## out_dir = "chessb_np/"
## out_dir = "chessb_pn/"
## out_dir = "chessb_no_latent/"

lout = c("chessb_np/", "chessb_pn/", "chessb_no_latent/")
for (out_dir in lout) {

## log loss using simulated time
mll  <- 99 * mi

load(paste0(out_dir, "surv_sim.RData"))


for (item in 1:I) {
  pp = sim_data[[i]][, (N+1): (2*N)]
  for (k in 1:N) {
    mll[item, k] = MLmetrics::LogLoss(pp[, k], mi[item, k])
    }
  }

save(mll,file = paste0(out_dir,"simll.RData"))
  }
#+end_src

#+begin_src R
fname = "simll.RData"
pname = "sim_logloss_diff_by.pdf"
source("R/draw_logloss_diff_by.R")
#+end_src

#+RESULTS:

* custom functions
#+BEGIN_SRC R :tangle R/art-functions.R
fun_hazard_surv <- function(t, i, k, posm, cname, sj) {
  z <- posm[stringr::str_which(cname, paste0("z\\.[0-1]\\.", k, "\\.[1-2]"))] %>% matrix(ncol = 2)
  w <- rep(posm[stringr::str_which(cname, paste0("w\\.", i, "\\."))], 2) %>% matrix(ncol = 2)
  gamma <- posm[stringr::str_which(cname, paste0("gamma"))] %>% matrix(ncol = 2)
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\."))] %>% matrix(ncol = 2)
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\."))] %>% matrix(ncol = 2)
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.[0-1]\\.", i, "\\."))] %>% matrix(ncol = 2)

  G <- length(lambda[, 1])
  H <- sj[2:(G + 1)] - sj[1:G]

  seg <- 0
  for (g in 1:G) {
    seg <- seg + 1 * (t > sj[g])
  }
  out <- lambda[seg, 2] * exp(beta[, 2] + theta[, 2] - gamma[, 2] * sqrt(sum((z[, 2] - w[, 2])^2)))
  if (seg == 1) {
    for (c in 1:2) {
      out <- out * exp(
        -( (t - sj[seg]) * lambda[seg, c]) * exp(beta[, c] + theta[, c] - gamma[, c] * sqrt(sum((z[, c] - w[, c])^2)))
      )
    }
  } else {
    for (c in 1:2) {
      out <- out * exp(
        -( (t - sj[seg]) * lambda[seg, c] + sum(H[1:(seg - 1)] * lambda[1:(seg - 1), c])) * exp(beta[, c] + theta[, c] - gamma[, c] * sqrt(sum((z[, c] - w[, c])^2)))
      )
    }
  }
  names(out) <- NULL
  return(out)
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
fun_hazard_ick <- function(t, i, c, k, posm, cname, sj) {
  z <- posm[stringr::str_which(cname, paste0("z\\.", c, "\\.", k, "\\.[1-2]"))]
  w <- posm[stringr::str_which(cname, paste0("w\\.", i))]
  gamma <- posm[stringr::str_which(cname, paste0("gamma\\.", c))]
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\.", c))]
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\.", c))]
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.", c, "\\.", i, "\\."))]

  G <- length(lambda)
  seg <- 0 * t
  for (g in 1:G) {
    seg <- seg + 1 * (t > sj[g])
  }
  hazard <- lambda[seg] * exp(beta + theta - gamma * sum((z - w)^2))
  names(hazard) <- NULL
  return(hazard)
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
fun_accuracy_ick <- function(t, i, k, posm, cname, sj) {
  fun_hazard_ick(t, i, 1, k, posm, cname, sj) / (fun_hazard_ick(t, i, 1, k, posm, cname, sj) + fun_hazard_ick(t, i, 0, k, posm, cname, sj))
}
#+END_SRC

#+NAME: mdsplot
#+BEGIN_SRC R :tangle R/art-functions.R
library(ggplot2)
library(ggrepel)

lsjmplot <- function(z, w, myname = NULL, xlim = NA, ylim = NA, lab = "Coordinate") {

  ## extract objects

  x <- rbind(z, w)
  idx <- rep("w", nrow(x))
  idx[seq_len(nrow(z))] <- "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position", 1:ndim, sep = "")

  padding <- 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[, 1])) * padding
    x2 <- max(abs(position[, 1])) * padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[, 2])) * padding
    y2 <- max(abs(position[, 2])) * padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme <- theme(
    axis.line = element_line(colour = "black"),
    ## panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    ## panel.border = element_blank(),
    panel.background = element_blank()
  )

  ## plot
  pp <- ggplot(position, aes(x = position1, y = position2, colour = idx)) +
    theme(text = element_text(size = 20)) +
    ## geom_point()+
    xlim(x1, x2) +
    ylim(y1, y2) +
    xlab(paste(lab, " 1", sep = "")) +
    ylab(paste(lab, " 2", sep = "")) +
    ## xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype = 2) +
    geom_vline(xintercept = 0, color = "gray70", linetype = 2)
  ##  pp = pp + geom_text_repel(label=rownames(position), segment.color = "grey50", size=6)
  if (!is.null(myname)) {
    pp <- pp + geom_text(
      label = myname,
      ## segment.color = "grey50",
      check_overlap = FALSE, show.legend = FALSE, size = 2
    )
  } else {
    pp <- pp + geom_point()
  }
  pp + mytheme
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
library(ggplot2)
library(ggrepel)

cl_lsjmplot <- function(z, w, cl_z, cl_w, myname = NULL, xlim = NA, ylim = NA, lab = "Coordinate") {

  ## extract objects
  n_z <- nrow(z)
  n_w <- nrow(w)

  cl <- rbind(cl_z, cl_w)[[1]]
  cl <- as.factor(cl)
  cl_z <- cl[1:n_z]
  cl_w <- cl[(n_z + 1):length(cl)]
  x <- rbind(z, w)
  idx <- rep("w", nrow(x))
  idx[seq_len(nrow(z))] <- "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position", 1:ndim, sep = "")

  padding <- 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[, 1])) * padding
    x2 <- max(abs(position[, 1])) * padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[, 2])) * padding
    y2 <- max(abs(position[, 2])) * padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme <- theme(
    axis.line = element_line(colour = "black"),
    ## panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    ## panel.border = element_blank(),
    panel.background = element_blank()
  )

  position$idx <- idx

  ## plot
  pp <- ggplot(subset(position, idx == "z"), aes(x = position1, y = position2, colour = cl_z)) +
    ## theme(text=element_text(size=20)) +
    ## geom_point()+
    xlim(x1, x2) +
    ylim(y1, y2) +
    xlab(paste(lab, " 1", sep = "")) +
    ylab(paste(lab, " 2", sep = "")) +
    ## xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype = 2) +
    geom_vline(xintercept = 0, color = "gray70", linetype = 2) +
    mytheme
  pp <- pp + geom_point()
  pp +
    geom_text(
      data = subset(position, idx == "w"), aes(x = position1, y = position2, label = (1:n_w), colour = cl_w),
      ## segment.color = "grey50",
      check_overlap = FALSE, show.legend = FALSE, size = 4
    )
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
find_xstar <- function(df) {
  num_samples <- nrow(df)

  z0dx <- grepl("^z\\.0\\.", colnames(df))
  z1dx <- grepl("^z\\.1\\.", colnames(df))
  w0dx <- grepl("^w\\.0\\.", colnames(df))
  w1dx <- grepl("^w\\.1\\.", colnames(df))
  adx <- z0dx | z1dx | w0dx | w1dx

  mlp_ <- max(df$lp_)
  star <- min(which.max(df$lp_))
  lpos <- df[, adx]
  Xstar <- list()
  Xstar$z.0 <- matrix(unlist(df[star, z0dx]), byrow = T, ncol = 2)
  if (sum(z1dx) == 0) {
    Xstar$z.1 <- NULL
  } else {
    Xstar$z.1 <- matrix(unlist(df[star, z1dx]), byrow = T, ncol = 2)
  }
  if (sum(w1dx) == 0) {
    Xstar$w.1 <- NULL
  } else {
    Xstar$w.1 <- matrix(unlist(df[star, w1dx]), byrow = T, ncol = 2)
  }
  Xstar$w.0 <- matrix(unlist(df[star, w0dx]), byrow = T, ncol = 2)
  return(list(lp_ = mlp_, Xstar = Xstar))
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
find_xstar_inlist <- function(mydf) {
  num_chain <- length(mydf)
  mlp <- -Inf
  for (i in 1:num_chain) {
    slist <- find_xstar(mydf[[i]])
    if (slist$lp_ > mlp) Xstar <- slist$Xstar
  }
  return(Xstar)
}
#+END_SRC

#+BEGIN_SRC R :tangle R/art-functions.R
do_procrustes <- function(Xstar, mydf, is_list = FALSE, translation = TRUE, scale = FALSE, reflect = TRUE) {
  posm <- 0
  if (is_list == TRUE) {
    num_chain <- length(mydf)
  } else {
    num_chain <- 1
  }
  for (i in 1:num_chain) {
    if (is_list == TRUE) {
      df <- mydf[[i]]
    } else {
      df <- mydf
    }

    num_samples <- nrow(df)

    z0dx <- grepl("^z\\.0\\.", colnames(df))
    z1dx <- grepl("^z\\.1\\.", colnames(df))
    wdx <- grepl("^w", colnames(df))
    adx <- z0dx | z1dx | wdx
    N <- sum(z0dx) / 2
    nall <- sum(adx) / 2

    mlp_ <- max(df$lp_)
    star <- min(which.max(df$lp_))
    lpos <- df[, adx]

    ## mm = list()
    ## for (k in 1:num_samples) {
    ##   X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
    ##   ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation)$X.new #MCMCpack
    ##   mm[[k]] = vegan::procrustes(X, Xstar, scale = scale)$Yrot #vegan
    ##   df[k,adx] = mm[[k]] %>% t() %>% c()
    ## }

    mm <- foreach(k = 1:num_samples) %dopar% {
      ## X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
      ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation = scale)$X.new #MCMCpack
      ## vegan::procrustes(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2) ), scale = scale)$Yrot #vegan
      shapes::procOPA(Xstar, t(matrix(unlist(lpos[k, ]), nrow = 2)), scale = scale, reflect = reflect)$Bhat # shapes
    }
    tmm <- lapply(mm, t)
    df[, adx] <- t(matrix(unlist(tmm), nrow = sum(adx)))


    posm <- posm + Reduce("+", mm) / num_samples
    if (is_list == TRUE) {
      mydf[[i]] <- df
    } else {
      mydf <- df
    }
  }

  posm <- posm / num_chain
  z0 <- posm[1:N, ]
  if (sum(z1dx) == 0) {
    w <- posm[-(1:N), ]
    z1 <- NULL
  } else {
    z1 <- posm[(N + 1):(2 * N), ]
    w <- posm[-(1:(2 * N)), ]
  }
  return(list(mydf = mydf, z0 = z0, z1 = z1, w = w))
}
#+END_SRC

* lintr
#+begin_src emacs-lisp
(setq flycheck-checker-error-threshold 700)
#+end_src

#+RESULTS:
: 700

#+begin_src sh :eval no :tangle .lintr
linters: with_defaults(line_length_linter(120), assignment_linter = NULL, object_name_linter = NULL)
#+end_src

* build R package
#+begin_src R
devtools::build('~/Dropbox/research/lsjm-art/lsjm-code/art')
#+end_src

#+begin_src R
install.packages("art_1.0.tar.gz", repos = NULL, type="source")
library(art)
#+end_src

#+RESULTS:
#+begin_example
Installing package into '/usr/local/lib/R/4.0/site-library'
(as 'lib' is unspecified)
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
,* installing *source* package 'art' ...
,** using staged installation
,** libs
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library


/usr/local/bin/ccache /usr/local/opt/llvm/bin/clang++ -std=c++14 -I"/usr/local/Cellar/r/4.0.3/lib/R/include" -DNDEBUG  -I'/usr/local/lib/R/4.0/site-library/Rcpp/include' -I'/usr/local/lib/R/4.0/site-library/RcppEigen/include' -I'/usr/local/lib/R/4.0/site-library/RcppNumerical/include' -I'/usr/local/lib/R/4.0/site-library/RcppParallel/include' -I'/usr/local/lib/R/4.0/site-library/StanHeaders/include' -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -I/usr/local/include -I/usr/local/opt/llvm/include -I/usr/local/opt/openssl/include -I/usr/local/opt/gettext/include	-I/usr/local/opt/tcl-tk/include   -I'/usr/local/lib/R/4.0/site-library/RcppParallel/include' -D_REENTRANT -DSTAN_THREADS   -I"/usr/local/lib/R/4.0/site-library/StanHeaders/include/src" -fPIC  -g -O3 -Wall -pedantic -mtune=native -pipe -c RcppExports.cpp -o RcppExports.o
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:1:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Core:535:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:2:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/LU:47:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:3:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Cholesky:12:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Jacobi:29:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:3:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Cholesky:43:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/QR:17:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Householder:27:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:5:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SVD:48:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:6:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Geometry:58:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:7:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Eigenvalues:58:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:26:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseCore:66:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:27:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/OrderingMethods:71:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:29:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseCholesky:43:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:32:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseQR:35:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:33:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/IterativeLinearSolvers:46:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:32:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/CholmodSupport:45:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:35:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/KroneckerProduct:34:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:39:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/Polynomials:135:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:40:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/SparseExtra:51:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from RcppExports.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:26:
In file included from /usr/local/lib/R/4.0/site-library/Rcpp/include/Rcpp.h:57:
/usr/local/lib/R/4.0/site-library/Rcpp/include/Rcpp/DataFrame.h:136:18: warning: unused variable 'data' [-Wunused-variable]
            SEXP data = Parent::get__();
                 ^
18 warnings generated.
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library


/usr/local/bin/ccache /usr/local/opt/llvm/bin/clang++ -std=c++14 -I"/usr/local/Cellar/r/4.0.3/lib/R/include" -DNDEBUG  -I'/usr/local/lib/R/4.0/site-library/Rcpp/include' -I'/usr/local/lib/R/4.0/site-library/RcppEigen/include' -I'/usr/local/lib/R/4.0/site-library/RcppNumerical/include' -I'/usr/local/lib/R/4.0/site-library/RcppParallel/include' -I'/usr/local/lib/R/4.0/site-library/StanHeaders/include' -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -I/usr/local/include -I/usr/local/opt/llvm/include -I/usr/local/opt/openssl/include -I/usr/local/opt/gettext/include	-I/usr/local/opt/tcl-tk/include   -I'/usr/local/lib/R/4.0/site-library/RcppParallel/include' -D_REENTRANT -DSTAN_THREADS   -I"/usr/local/lib/R/4.0/site-library/StanHeaders/include/src" -fPIC  -g -O3 -Wall -pedantic -mtune=native -pipe -c comprisk.cpp -o comprisk.o
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:1:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Core:535:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:2:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/LU:47:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:3:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Cholesky:12:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Jacobi:29:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:3:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Cholesky:43:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/QR:17:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Householder:27:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:5:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SVD:48:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:6:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Geometry:58:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:30:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Dense:7:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Eigenvalues:58:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:26:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseCore:66:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:27:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/OrderingMethods:71:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:29:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseCholesky:43:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:32:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/SparseQR:35:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:31:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/Sparse:33:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/IterativeLinearSolvers:46:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:32:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/CholmodSupport:45:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:35:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/KroneckerProduct:34:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:39:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/Polynomials:135:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:25:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigenForward.h:40:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/SparseExtra:51:
/usr/local/lib/R/4.0/site-library/RcppEigen/include/unsupported/Eigen/../../Eigen/src/Core/util/ReenableStupidWarnings.h:10:30: warning: pragma diagnostic pop could not pop, no matching push [-Wunknown-pragmas]
    #pragma clang diagnostic pop
                             ^
In file included from comprisk.cpp:4:
In file included from /usr/local/lib/R/4.0/site-library/RcppNumerical/include/RcppNumerical.h:10:
In file included from /usr/local/lib/R/4.0/site-library/RcppEigen/include/RcppEigen.h:26:
In file included from /usr/local/lib/R/4.0/site-library/Rcpp/include/Rcpp.h:57:
/usr/local/lib/R/4.0/site-library/Rcpp/include/Rcpp/DataFrame.h:136:18: warning: unused variable 'data' [-Wunused-variable]
            SEXP data = Parent::get__();
                 ^
18 warnings generated.
/usr/local/bin/ccache /usr/local/opt/llvm/bin/clang -I"/usr/local/Cellar/r/4.0.3/lib/R/include" -DNDEBUG  -I'/usr/local/lib/R/4.0/site-library/Rcpp/include' -I'/usr/local/lib/R/4.0/site-library/RcppEigen/include' -I'/usr/local/lib/R/4.0/site-library/RcppNumerical/include' -I'/usr/local/lib/R/4.0/site-library/RcppParallel/include' -I'/usr/local/lib/R/4.0/site-library/StanHeaders/include' -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -I/usr/local/include -I/usr/local/opt/llvm/include -I/usr/local/opt/openssl/include -I/usr/local/opt/gettext/include	-I/usr/local/opt/tcl-tk/include   -fPIC  -g -O3 -Wall -pedantic -mtune=native -pipe -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -c init.c -o init.o
init.c:1:1: warning: ISO C requires a translation unit to contain at least one declaration [-Wempty-translation-unit]
1 warning generated.
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
/usr/local/bin/ccache /usr/local/opt/llvm/bin/clang++ -std=c++14 -dynamiclib -Wl,-headerpad_max_install_names -undefined dynamic_lookup -single_module -multiply_defined suppress -L/usr/local/Cellar/r/4.0.3/lib/R/lib -L/usr/local/opt/gettext/lib -L/usr/local/opt/readline/lib -L/usr/local/lib -L/usr/local/opt/llvm/lib -Wl,-rpath,/usr/local/opt/llvm/lib -o art.so RcppExports.o comprisk.o init.o -L/usr/local/lib/R/4.0/site-library/RcppParallel/lib/ -Wl,-rpath,/usr/local/lib/R/4.0/site-library/RcppParallel/lib/ -ltbb -ltbbmalloc -L/usr/local/Cellar/r/4.0.3/lib/R/lib -lR -lintl -Wl,-framework -Wl,CoreFoundation
installing to /usr/local/lib/R/4.0/site-library/00LOCK-art/00new/art/libs
,** R
,** byte-compile and prepare package for lazy loading
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
,** help
,*** installing help indices
,** building package indices
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
,** testing if installed package can be loaded from temporary location
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library/00LOCK-art/00new
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
,** checking absolute paths in shared objects and dynamic libraries
,** testing if installed package can be loaded from final location
Using libraries at paths:
- /usr/local/lib/R/4.0/site-library
- /usr/local/Cellar/r/4.0.3/lib/R/library
,** testing if installed package keeps a record of temporary installation path
,* DONE (art)
#+end_example

*** function to get param from MCMC sample
#+begin_src R
srow = mylist[[1]][1, ]

## extract parameters from a row of MCMC samples
row_to_param <- function(srow, cname, I, N, G) {

  z <- srow[stringr::str_which(cname, paste0("^z\\."))]
  w <- srow[stringr::str_which(cname, paste0("^w\\."))]

  z = matrix(z, ncol = 2,  byrow = T)
  w = matrix(w, ncol = 2,  byrow = T)

  beta <- srow[stringr::str_which(cname, paste0("^beta\\."))]
  beta = matrix(beta, ncol = 2, byrow = T)

  theta <- srow[stringr::str_which(cname, paste0("^theta\\."))] ## (theta.k.0 theta.k.1)
  theta =  matrix(theta, ncol = 2, byrow = T)

  gamma <- srow[stringr::str_which(cname, paste0("gamma\\."))]

  lambda <- srow[stringr::str_which(cname, paste0("^lambda\\.[0-1]\\."))]
  lambda =  matrix(lambda, ncol = G, byrow = T)

  out <- list(z = z, w = w, beta = beta, theta = theta, gamma = gamma, lambda = lambda)

  return(out)

}

fun_segH = function(mt, sj) {

  seg = matrix(findInterval(mt, sj),  ncol = ncol(mt))

}

#+end_src
* COMMENT Local Variables
# Local Variables:
# org-babel-default-header-args:R: ((:session . "*R-Org*") (:export . "both") (:results . "output replace"))
# eval: (flyspell-mode -1)
# eval: (spell-fu-mode -1)
# End:
