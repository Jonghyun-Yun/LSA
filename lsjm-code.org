#+title: LSJM Code for accuracy and RT
#+author: Jonghyun Yun
#+email: jonghyun.yun@gmail.com

#+options:   H:10 num:nil toc:nil \n:nil @:t ::t |:t ^:nil ^:{} -:t f:t *:t <:t ':nil -:nil pri:t
#+options:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

#+startup: overview inlineimages logdone indent

#+setupfile: ~/setup/my-theme-readtheorg.setup
#+setupfile: ~/org/latex_header.setup
#+setupfile: ~/org/orgmode_header.setup

#+property: header-args :eval never-export
#+property: header-args:R :session *R-Org* :exports both :noweb yes
#+property: header-args:jupyter-python :session *jupyter-lsjm* :kernel tf :async yes

* References
#+bibliography: ~/Zotero/myref.bib
#+pandoc_options: csl:~/Zotero/styles/chicago-author-date.csl

# for html export with bib
# bibliographystyle:unsrt
# bibliography:~/Zotero/myref.bib

#+latex: \begingroup
#+latex: \renewcommand{\section}[2]{}%
#+latex: \printbibliography[sorting=ydnt, heading=none, type=article] % for biblatex, comment out everything else
#+latex: \endgroup
* prerequisite
required package intallation scripts
#+begin_src R
## install.packages("coda")
install.packages("dplyr")
install.packages("stringr")
install.packages("magrittr")
install.packages("bayesplot")
install.packages("foreach")
install.packages("doParallel")
install.packages("reshape2")
install.packages("readr")
install.packages("data.table")
install.packages("survival")
install.packages(c("ggplot2","ggrepel","fda","funFEM"))
#+end_src

#+begin_src R :results none
## Rcpp::sourceCpp("comprisk.cpp")
install.packages("art_0.1.2.tar.gz", repos = NULL, type="source")
detach(package:art)
library(art)
#+end_src

#+begin_src R :tangle R/prerequisite.R
require(magrittr)
require(dplyr)
#+end_src

#+begin_src R :tangle R/art-functions.R
source("R/prerequisite.R")
#+end_src

* PISA2015 data
** pisa2015/README.txt
- pisa2015: math
#+begin_src sh :results output
cat ../pisa2015/README.txt
#+end_src

** notebook
#+begin_src R
source('R/pisa-preprocess.R')
source('R/pisa-init.R')
#+end_src

#+begin_src R :results none :tangle R/pisa-preprocess.R
## pick_person = 1:592
pick_person = 1:592
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/pisa2015/US_PISA2015.rdata")
df = as_tibble(US_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+end_src

#+begin_src R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+end_src

#+begin_src R :results none :tangle R/pisa-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

di01 = di01[pick_person,pick_item]
dt01 = dt01[pick_person,pick_item]
#+end_src

** boxplot :ARCHIVE:
#+begin_src R
library(reshape2)

di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+end_src

#+begin_src R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 99))
#+end_src

#+begin_src R
rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01, aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
#+end_src

[[file:figure/RTs_S01.pdf]]

#+begin_src R
pdf("figure/RTs_S01.pdf")
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+end_src
** numeric ID
#+begin_src R :tangle R/pisa-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+end_src

#+begin_src R :tangle R/pisa-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+end_src

** knot selection
#+begin_src R :tangle R/pisa-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
*** To export long format data for STAN
#+begin_src R
library(survival)
status = !(dit01$res == 99)

tmp <- survival::survSplit(formula = Surv(time, status) ~ ., data = dit01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         len = time - tstart,
         status_T = 1 * (status == 1 & res == 1),
         status_F = 1 * (status == 1 & res == 0)
         ) %>%
  as_tibble
to_stan = tmp %>% mutate(seg_g = seg_g - 1) %>% dplyr::select(stuid, item, time, seg_g, len, status_F, status_T)
## tmp %>% dplyr::select(res,status,status_T,status_F)
#+end_src

#+begin_src R
## data and fixed parameters
I = nrow(tab_item)
N = nrow(tab_stuid)
C = 2

L = nrow(to_stan)
G = ncut

with(to_stan,
     rstan::stan_rdump(c('I','N','C','L','G','stuid','item', 'G', 'seg_g','len','status_F','status_T'),"pisa_data.R"))

#+end_src

*** To export short format data for STAN

#+begin_src R
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)
tt01 = data.frame(time = c(as.matrix(tt01)), status = 1)

tmp <- survival::survSplit(formula = survival::Surv(time, status) ~ ., data = tt01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 1,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+end_src

#+begin_src R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2

G = ncut + 1

rstan::stan_rdump(c('I','N','C','G', 'mseg','mlen', 'mh', 'mt','mi'),"pisa_short.R")

#+end_src

*** to export short format data for C++
#+begin_src R :tangle R/pisa-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+end_src

#+begin_src R :tangle R/pisa-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+begin_src R :tangle R/pisa-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)

source("R/write-prior.R")
#+end_src

#+begin_src R :tangle R/pisa-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** not used
#+begin_src R
item <- pull(info, Item)
time <- pull(info, Time)
cname <- colnames(df)
#+end_src

#+begin_src R
item = item[info$Cluster_A == "S01"]
time = time[info$Cluster_A == "S01"]
yi = df[,cname %in% item]
yt = df[,cname %in% time]

idx = !apply(yi,1,function(x) all(is.na(x)))
yi = yi[idx,]
yt = yt[idx,]
yi[is.na(yi)] = 99
yi[yi == 2] = 1
#+end_src


#+begin_src R
boxplot(yt)
#+end_src

** init
#+begin_src R :results none :tangle R/pisa-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

* opusIII-matrices-data.dat
#+begin_src R :results none
source("R/opusIII-preprocess.R")
source("R/opusIII-init.R")
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
num_person = 504 ## max 504: do not change
num_item =35 ## max 35

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
opusIII = readr::read_delim("data/opusIII-matrices-data.dat"," ")
df = as_tibble(opusIII[,-1])[,1:4] ## drop row names
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+end_src

** knot selection
#+begin_src R :tangle R/opusIII-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

** survSplit
#+begin_src R :results none :tangle R/opusIII-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/opusIII-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #

source("R/write-data.R")
#+end_src

#+begin_src R :results none :tangle R/opusIII-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** boxplot
#+begin_src R :results code
dit = plyr::join(di, dt, by = c("person","item"))
myacc = dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(accuracy = T / (T +F))
#+end_src

#+RESULTS:
#+begin_src R
`summarise()` ungrouping output (override with `.groups` argument)
#+end_src

#+begin_src R
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=time,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(time),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
acc_plot <- ggplot(myacc, aes(x=item,y=accuracy)) +
  geom_text_repel(label=1:I, segment.color = "grey50", size=3) +
  labs(title="Accuracy")
#+end_src

#+RESULTS:

[[file:figure/RTnACC.pdf]]

#+begin_src R
pdf("figure/RTnACC.pdf")
rt_boxp
acc_plot
logrt_boxp
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: null device
:           1

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/opusIII-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)

source("R/write-prior.R")
#+end_src

** init
#+begin_src R :results none :tangle R/opusIII-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** diffused prior
#+begin_src R :results none :tangle R/opusIII_noinfo-preprocess.R
source("R/opusIII-preprocess.R")

mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
l_c = 2
l_m = ((G - 1) / (quantile(time, 0.75)  * (G - 1:G + 0.5)))
a_lambda = matrix(l_m/l_c, I, G, byrow=T)
b_lambda = matrix(1 / l_c,I,G)
## a_lambda = matrix(0.0001, I, G, byrow=T)
## b_lambda = matrix(0.0001, I, G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(10000.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(10000.0),N,2)
jump_theta = matrix(0.2,N,2)

a_sigma = 0.0001
b_sigma = 0.0001

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(2.0),1,2)
jump_gamma = matrix(0.01,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.15,I,2)

source("R/write-prior.R")
#+end_src

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+begin_src R :results none :tangle R/opusIII_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

* verbalIntelligence.dat

#+begin_src R :results none :tangle no :results output :session
source("R/verbal-preprocess.R")
source("R/verbal-init.R")
#+end_src

#+begin_src R :tangle R/verbal-preprocess.R
num_person = 726 ## max 726: do not change
num_item = 34 ## max 34

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+RESULTS:

#+begin_src R :results none :tangle R/verbal-preprocess.R
verbal = readr::read_delim("data/verbalIntelligence.dat"," ")
df = as_tibble(verbal[,-1])[,1:4] ## drop row names
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+end_src

#+begin_src R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+end_src

#+begin_src R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(685,137,610,724,703)])
#+end_src

#+begin_src R
di %>% filter(item %in% to_chrID(c(12,17,20),tab_item)) %>% filter(person %in% tab_person$chr[c(680,629,600,691,601)])
#+end_src

** knot selection
#+begin_src R :tangle R/verbal-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

** survSplit
#+begin_src R :results none :tangle R/verbal-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
item <- pull(tmp, item)
person <- pull(tmp, person)
seg_g <- pull(tmp, seg_g)
H <- pull(tmp, len)
#+end_src

#+begin_src R :tangle R/verbal-preprocess.R
mi <- reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[, -1]
mt <- reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[, -1]
mNA <- mi
mNA[!is.na(mNA)] <- 1
mNA[is.na(mNA)] <- 0
mseg <- reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[, -1]
mh <- reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[, -1]
mlen <- sj[2:(ncut + 1)] - sj[1:(ncut)]

mi[is.na(mi)] <- -99
mt[is.na(mt)] <- -99
mseg[is.na(mseg)] <- -99
mh[is.na(mh)] <- -99
#+end_src

#+RESULTS:
: Using response as value column: use value.var to override.
: Using time as value column: use value.var to override.
: Using seg_g as value column: use value.var to override.
: Using len as value column: use value.var to override.

#+begin_src R :results none :tangle R/verbal-preprocess.R
## data and fixed parameters
I <- nrow(mt)
N <- ncol(mt)
C <- 2
G <- ncut #

source("R/write-data.R")
#+end_src

#+begin_src R :results none :tangle R/write-data.R
readr::write_csv(data.frame(I = I, N = N, C = C, G = G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen), "input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg), "input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh), "input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt), "input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi), "input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA), "input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/verbal-preprocess.R
mtab_sj <- t(apply(mseg, 1, function(x) tab_sj(x, G)))

tmp_0 <- mseg
tmp_0[mi == 1] <- -99
tmp_1 <- mseg
tmp_1[mi == 0] <- -99
mIY <- rbind(t(apply(tmp_0, 1, function(x) tab_IY(x, G))), t(apply(tmp_1, 1, function(x) tab_IY(x, G))))

readr::write_csv(as.data.frame(mtab_sj), "input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY), "input/mIY.csv", col_names = FALSE)
#+end_src

** boxplot
#+begin_src R :results code
dit = plyr::join(di, dt, by = c("person","item"))
myacc = dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(accuracy = T / (T +F))
#+end_src

#+RESULTS:
#+begin_src R
`summarise()` ungrouping output (override with `.groups` argument)
#+end_src

#+RESULTS:
: Error: unexpected symbol in "`summarise()` ungrouping"

#+begin_src R
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=time,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(time),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
acc_plot <- ggplot(myacc, aes(x=item,y=accuracy)) +
  geom_text_repel(label=1:I, segment.color = "grey50", size=3) +
  labs(title="Accuracy")
#+end_src

#+RESULTS:

[[file:figure/RTnACC.pdf]]

#+begin_src R
pdf("figure/RTnACC.pdf")
rt_boxp
acc_plot
logrt_boxp
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: null device
:           1

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/verbal-preprocess.R
mvar <- readr::read_csv("input/mvar.csv", col_names = FALSE) %>% as.matrix()
I <- mvar[1, 1]
N <- mvar[1, 2]
C <- mvar[1, 3]
G <- mvar[1, 4]
## lambda
a_lambda <- matrix(0.1, I, G)
b_lambda <- matrix(0.1, I, G)
jump_lambda <- matrix(0.5, I, G)

mu_beta <- matrix(0.0, I, 2)
sigma_beta <- matrix(sqrt(1.0), I, 2)
jump_beta <- matrix(0.25, I, 2)

mu_theta <- matrix(0.0, N, 2)
sigma_theta <- matrix(sqrt(1.0), N, 2)
jump_theta <- matrix(1.0, N, 2)

a_sigma <- 1.0
b_sigma <- 1.0

mu_gamma <- matrix(0.0, 1, 2)
sigma_gamma <- matrix(sqrt(1.0), 1, 2)
jump_gamma <- matrix(1.0, 1, 2)

mu_z <- matrix(0.0, N, 2)
sigma_z <- matrix(sqrt(1.0), N, 2)
jump_z <- matrix(1.0, N, 2)

mu_w <- matrix(0.0, I, 2)
sigma_w <- matrix(sqrt(1.0), I, 2)
jump_w <- matrix(0.5, I, 2)

source("R/write-prior.R")
#+end_src

** init
#+begin_src R :results none :tangle R/verbal-init.R
mvar <- as.matrix(readr::read_csv("input/mvar.csv", col_names = F))
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

set.seed(as.numeric(Sys.time()))

set.seed(as.numeric(Sys.time()))

init_lambda <- matrix(1, nrow = 2 * I, ncol = G)
init_beta <- 0 * matrix(rnorm(2 * I), ncol = 2)
init_theta <- 0 * matrix(rnorm(2 * N), ncol = 2)
init_gamma <- 1 * matrix(c(1, 1), ncol = 1)
init_w <- 0 * matrix(rnorm(2 * 2 * I), ncol = 2)
init_z <- 0 * matrix(rnorm(2 * 2 * N), ncol = 2)

source("R/write-init.R")
#+end_src

** diffused prior
#+begin_src R :results none :tangle R/verbal_noinfo-preprocess.R
source("R/verbal-preprocess.R")

mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
l_c = 2
l_m = ((G - 1) / (quantile(time, 0.75)  * (G - 1:G + 0.5)))
a_lambda = matrix(l_m/l_c, I, G, byrow=T)
b_lambda = matrix(1 / l_c,I,G)
## a_lambda = matrix(0.0001, I, G, byrow=T)
## b_lambda = matrix(0.0001, I, G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(10000.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(10000.0),N,2)
jump_theta = matrix(0.2,N,2)

a_sigma = 0.0001
b_sigma = 0.0001

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(2.0),1,2)
jump_gamma = matrix(0.01,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.15,I,2)

source("R/write-prior.R")
#+end_src

** initialization for Gamma(0) = 1, Gamma(1) = -1
#+begin_src R :results none :tangle R/verbal_pn-init.R
mvar <- as.matrix(readr::read_csv("input/mvar.csv", col_names = F))
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda <- matrix(1, nrow = 2 * I, ncol = G)
init_beta <- 0 * matrix(rnorm(2 * I), ncol = 2)
init_theta <- 0 * matrix(rnorm(2 * N), ncol = 2)
init_gamma <- 1 * matrix(c(1, -1), ncol = 1)
init_w <- 0 * matrix(rnorm(2 * 2 * I), ncol = 2)
init_z <- 0 * matrix(rnorm(2 * 2 * N), ncol = 2)

source("R/write-init.R")
#+end_src

* Duolingo
- sentence tranlation test using Duolingo app
- unlimited time: use 200s to censor response time. RT > 200s -> no response = incorrect
- data has been pre-processed by "김현주 <hyunjookim11@naver.com>"

#+begin_src R :results none
source("R/duolingo-preprocess.R")
source("R/duolingo-init.R")
#+end_src
** description

#+begin_src R :results none :tangle R/duolingo-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
dit <- readr::read_csv("data/0427_duolingo_info.csv")[,c(1,2,4,3)]
colnames(dit) = c("person","item","resp","RT")
#+end_src

Reponse time >= 200s are treated as no response.
#+begin_src R :tangle R/duolingo-preprocess.R
dit$resp[dit$RT > 200] <- 0
dit$RT[dit$RT > 200] <- 200
#+end_src

#+RESULTS:

** knot selection
#+begin_src R :tangle R/duolingo-preprocess.R
time = pull(dit, RT)
item = pull(dit, item)
resp = pull(dit, resp)

ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

#+begin_src R
checksj = 0
tab0 = table(findInterval(time[resp == 0], sj), item[resp==0])
tab1 = table(findInterval(time[resp == 1], sj), item[resp==1])
sjtab = list(tab0,tab1)
  for (c in 1:2) {
  checksj = checksj + sum(sjtab[[c]]==0)
}
if (checksj > 0) {
print(tab0)
print(tab1)
  cat(checksj,"\n")
  stop("there exists an interval(s) with no observation.")
  }
#+end_src

#+RESULTS:
#+begin_example

    ¡Duerme! ¿Dónde es mi clase? Adentro y afuera Buena pregunta El internet
  1       13                   0                2              6           3
  2        6                   0                6              1           2
  3        7                   5               11              6           0
  4        2                  14                6             10           0
  5        1                  13               15              2           1

    Ella está escribiendo. Hola y adiós. La cuenta por favor.
  1                      1            13                    1
  2                      2            18                    4
  3                      5            32                    5
  4                      9            20                   12
  5                     10            15                    6

    La ensalada tiene cebollas. Me gustan los animales.
  1                           1                       0
  2                           1                       0
  3                           2                       1
  4                          21                       0
  5                          36                      10

    Rojo y azul son colores. Un plátano Yo amo mi carrera. Yo como un plátano.
  1                        0          2                  0                   2
  2                        1          1                  6                   3
  3                        4          2                 25                   7
  4                        7          3                 20                   5
  5                       26          0                 22                  11

    Yo estoy bien. Yo hago zapatos. Yo sé inglés. Yo tengo una buena idea.
  1             10                3             2                        0
  2             15                5             2                        1
  3             17                7             6                        8
  4             11                9            11                       14
  5             27                5            14                       20

    ¡Duerme! ¿Dónde es mi clase? Adentro y afuera Buena pregunta El internet
  1       69                   2               11             64          79
  2       32                   8               20             27          33
  3        9                  22               26             18          19
  4        5                  53               35             11           9
  5        7                  34               19              6           5

    Ella está escribiendo. Hola y adiós. La cuenta por favor.
  1                     31            10                    7
  2                     38            19                   23
  3                     21             8                   33
  4                     19             9                   29
  5                     15             7                   31

    La ensalada tiene cebollas. Me gustan los animales.
  1                           0                      27
  2                           5                      36
  3                          18                      29
  4                          31                      28
  5                          36                      20

    Rojo y azul son colores. Un plátano Yo amo mi carrera. Yo como un plátano.
  1                        1         83                  3                   3
  2                        3         31                 13                  39
  3                       22         22                 14                  36
  4                       52          4                 21                  29
  5                       35          3                 27                  16

    Yo estoy bien. Yo hago zapatos. Yo sé inglés. Yo tengo una buena idea.
  1             11               31            33                        0
  2             18               35            31                        8
  3             11               26            20                       27
  4              9               20            13                       42
  5             22               10            19                       31
13
Error: there exists an interval(s) with no observation.
#+end_example

** survSplit
#+begin_src R :results none :tangle R/duolingo-preprocess.R
library(survival)
status = rep(1, nrow(dit))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/duolingo-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+RESULTS:
: Using response as value column: use value.var to override.
: Using time as value column: use value.var to override.
: Using seg_g as value column: use value.var to override.
: Using len as value column: use value.var to override.

#+begin_src R :results none :tangle R/duolingo-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #

source("R/write-data.R")
#+end_src

#+begin_src R :results none :tangle R/duolingo-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** boxplot
#+begin_src R :results code
myacc = dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(accuracy = T / (T +F))
#+end_src

#+RESULTS:
#+begin_src R
`summarise()` ungrouping output (override with `.groups` argument)
#+end_src

#+RESULTS:
: Error: unexpected symbol in "`summarise()` ungrouping"

#+begin_src R
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=time,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(time),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
acc_plot <- ggplot(myacc, aes(x=item,y=accuracy)) +
  geom_text_repel(label=1:I, segment.color = "grey50", size=3) +
  labs(title="Accuracy")
#+end_src

#+RESULTS:

[[file:figure/RTnACC.pdf]]

#+begin_src R
pdf("figure/RTnACC.pdf")
logrt_boxp
acc_plot
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: null device
:           1

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/duolingo-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(1.0,I,G)
b_lambda = matrix(1.0,I,G)
jump_lambda = matrix(0.25,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(0.25,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(0.05,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.25,I,2)

source("R/write-prior.R")
#+end_src

** init
#+begin_src R :results none :tangle R/duolingo-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source('R/write-init.R')
#+end_src

** diffused prior
#+begin_src R :results none :tangle R/duolingo_noinfo-preprocess.R
source("R/duolingo-preprocess.R")

mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
l_c = 2
l_m = ((G - 1) / (quantile(time, 0.75)  * (G - 1:G + 0.5)))
a_lambda = matrix(l_m/l_c, I, G, byrow=T)
b_lambda = matrix(1 / l_c,I,G)
## a_lambda = matrix(0.0001, I, G, byrow=T)
## b_lambda = matrix(0.0001, I, G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(10000.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(10000.0),N,2)
jump_theta = matrix(0.2,N,2)

a_sigma = 0.0001
b_sigma = 0.0001

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(2.0),1,2)
jump_gamma = matrix(0.01,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.15,I,2)

source("R/write-prior.R")
#+end_src

** Choose-a-move test B: pn Gamma(0) = 1, Gamma(1) = -1
#+begin_src R :results none :tangle R/duolingo_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** COMMENT Choose-a-move test B: no_latent Gamma(0) = 0, Gamma(1) = 0
#+begin_src R :results none :tangle R/duolingo_no_latent-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 0*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

* Marketing :ARCHIVE:
** description

Here is the description of the dataset: Each row of the data represents one fixation.  The duration of the fixation is given by the column labeled "event_duration" and is in units of milliseconds.  The variable ~choice~ indicates the choice that the subject made in that trial, 1 is left and 0 is right. The variable "roi" indicates whether the fixation was to the left ("1) or the right ("2").  The variable ~rt~ is the reaction time for the trial. "fix_num" is the number of the fixation within the trial, with 1 being first fixation, 2 being second fixation etc.  Similarly, "rev_fix_num" is the number of the fixation but going backwards from the last fixation, so 1 is the last fixation, 2 is the second-to-last fixation, etc.

Please ignore the variables "corr_fix_duration", "computed_rt" and "temp", I either did not end up using those or they were temporary variables.

## processing model for choice (left or right)
- 1: subject: person
- 2: trial: item
- 7: rt: response time
- 8: choice; response

#+begin_src R
source("R/marketing-preprocess.R")
source("R/marketing-init.R")
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
df <- foreign::read.dta("data/fixations_final.dta")[,c(1,2,8,7)] %>% as_tibble %>% distinct
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+end_src

#+begin_src R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+end_src

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+begin_src R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)

source("R/write-prior.R")
#+end_src

** init
#+begin_src R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src
** boxplot

#+begin_src R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+end_src

[[file:figure/boxplot_ART.pdf]]
#+begin_src R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+end_src

* Smith and Krajbich                                         :ATTACH:ARCHIVE:
:PROPERTIES:
:ID:       d0a1e4f9-326e-4950-8d12-d805efe8950a
:END:
[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;1][In the two-food task (Figure 1b), subjects were presented with two previously rated food items, one on each side of the computer screen, and asked to choose the one they would like to eat most at the end of the experiment. Only positively rated (i.e., rating 0) food items were included in this task, to ensure that subjects were choosing between items that were relevant to them. These posi tively rated items were randomly selected, subject to the con straints that (a) no item could be shown more than seven times and (b) the value difference between the items could not exceed five.]]

[[skim:///Users/yunj/Dropbox/MobileOrg/.attach/E9/b2bce3-9166-40d2-874f-7bbbb27393ea/smith_krajbich_2018_jepg.pdf::4;;2][Many subjects (two-food: n 􏰂 22; food-risk: n 􏰂 39) did not have enough positively rated food items to generate 200 valid trials in each of the food choice tasks, so these subjects completed as many constraint-satisfying trials as were generated (two-food: M 􏰂 171.3; food-risk: M 􏰂 146.7). In the food tasks, we limited the difference in value between the options in order to increase the experiment’s efficiency by focusing on trials with nontrivial decisions. This also facilitates the model fitting procedure, which relies on the RT distributions of “correct” and “error” choices.]]

** description
[[mu4e:msgid:15884427-B662-4EF9-A15A-EA609676DECF@g.ucla.edu][Re: new marketing data]]
[[mu4e:msgid:D5AF8D06-A080-44CA-96F7-386165ED972F@g.ucla.edu][new marketing data]]

It should be formatted similarly to the previous one. Each row is a fixation/dwell.  A few notes:
"LeftRight" - 1 is left, 2 is right
"ROI" - 1 is left, 2 is right
"DwellLength" is the duration of the dwell/fixation in seconds

You can also see that there are columns for the names of the snack foods in each trial.  If you need more information than this, let me know.  I could provide you with a link to the images of the items.  You would just need to link the images to the names.

LeftRight is the choice variable - 1 means left choice, 2 means right choice
FoodLeft and FoodRight are just unique food identifiers.  They should be redundant with the food names.
ValueLeft and ValueRight are the independent ratings of the foods on the left and right.  Subjects should generally be choosing the item with the higher value.
DwellLength is the fixation/dwell time for that particular fixation/dwell. The units are seconds.

*Plan*: "correctness" is defined by the choice of higher valued food. Exclude cases with the same valued food. "item" is defined using the value difference (not exceed 5).

#+begin_src R
source("R/twofood-preprocess.R")
source("R/twofood-init.R")
#+end_src

#+begin_src R :results none :tangle R/twofood-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/twofood-preprocess.R
## fix_num and roi vary per item and person -> it might mean something, but I drop them (used distinct without these columns)
load("data/SmithKrajbich2018.RData")
#+end_src

#+begin_src R :results none :tangle R/twofood-preprocess.R
df = data %>% select(SubjectNumber, LeftRight, RT, ValueLeft, ValueRight)
df = distinct(df)
names(df) = c("person", "item", "resp", "RT" )
name_item = unique(df$item)
name_person = unique(df$person)
pick_item = df$item %in% name_item
#+end_src

#+begin_src R :results none :tangle R/twofood-preprocess.R
df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+end_src

#+begin_src R :results none
tab_item = tabulate_id(name_item)
tab_person = tabulate_id(name_person)
#+end_src

** knot selection
#+begin_src R :tangle R/marketing-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

** survSplit
#+begin_src R :results none :tangle R/marketing-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/marketing-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/marketing-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/marketing-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)

source("R/write-prior.R")
#+end_src

** init
#+begin_src R :results none :tangle R/marketing-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/marketing-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src
** boxplot

#+begin_src R :results value :tangle R/marketing-preprocess.R
df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+end_src

[[file:figure/boxplot_ART.pdf]]
#+begin_src R :tangle R/marketing-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+end_src

* Chess proficiency (this is for Chees A)                    :ATTACH:ARCHIVE:
:PROPERTIES:
:ID:       aaa8e8c6-ea9b-47b0-8901-047b0388e662
:END:
[[mu4e:msgid:380ABC3A-4965-4B3A-9B29-D3F370AAF0E8@g.ucla.edu][New data - chess proficiency]]

http://users.fmg.uva.nl/hvandermaas/chesshtml/act.htm
** description

- Choose-a-move test A (test B is a parallel version of A)
  A1 - A40: 1 if correct (the correct answer is vastly superior to all other legal moves)
  AR1 - AR40: RT (< 30s; or no response)
  1-20: tactical items
  21-30: positional items
  31-40: endgame items
  Item difficulty increased within each set
  Missingness in RT -> should be excluded

- Predict-a-move test
  items are related. no unique solution. points of merit on a scale from 0 to 5.

#+begin_src R :results none
source("R/chess-preprocess.R")
source("R/chess-init.R")
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+end_src

#+begin_src R :tangle R/chess-preprocess.R
dt = cbind(PPNR, chess[,grepl("AR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("A[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+end_src

#+RESULTS:
: [1] TRUE

** knot selection
#+begin_src R :tangle R/chess-preprocess.R
time = pull(dit, RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

** survSplit
#+begin_src R :results none :tangle R/chess-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/chess-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/chess-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.5,I,2)
#+end_src

#+begin_src R :results none :tangle R/chess-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+end_src

** init
#+begin_src R :results none :tangle R/chess-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/chess-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src
** boxplot
#+begin_src R :results value :tangle R/chess-preprocess.R
dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
#+end_src

[[file:figure/boxplot_ART.pdf]]
#+begin_src R :tangle R/chess-preprocess.R
pdf("figure/boxplot_ART.pdf")
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=RT,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+end_src

* Choose-a-move test B
See [[id:aaa8e8c6-ea9b-47b0-8901-047b0388e662][Chess proficiency (this is for Chees A)]]
** description

#+begin_src R :results none
source("R/chessB-preprocess.R")
source("R/chessB-init.R")
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
setwd("~/research/lsjm-art/lsjm-code")

library(dplyr)
library(magrittr)

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
library(foreign)
chess <- read.spss("data/opennkweb.sav", to.data.frame = TRUE)
dataset.labels <- as.data.frame(attr(chess, "variable.labels"))
PPNR = chess[,1]
#+end_src

#+begin_src R :tangle R/chessB-preprocess.R
dt = cbind(PPNR, chess[,grepl("BR[1-9]+", names(chess))]) %>% na.omit
di = cbind(PPNR, chess[,grepl("B[1-9]+", names(chess))]) %>% filter(PPNR %in% dt$PPNR)

delo = cbind(PPNR, chess['ELO']) %>% filter(PPNR %in% dt$PPNR)

nitem = 40
nperson = nrow(di)

di_long <- reshape2::melt(di, id.vars=c("PPNR"))
dt_long <- reshape2::melt(dt, id.vars=c("PPNR"))

identical(di_long[,1],dt_long[,1])

dit = cbind(di_long, dt_long[,3])
colnames(dit) = c("person","item","resp","RT")

tab_item = data.frame(chr = colnames(di)[-1], num = 1:nitem)

dit$item = to_numID(dit$item, tab_item)
#+end_src

#+RESULTS:
: [1] TRUE

** knot selection
#+begin_src R :tangle R/chessB-preprocess.R
time = pull(dit, RT)
item = pull(dit, item)
resp = pull(dit, resp)

ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:

#+begin_src R
checksj = 0
tab0 = table(findInterval(time[resp == 0], sj), item[resp==0])
tab1 = table(findInterval(time[resp == 1], sj), item[resp==1])
sjtab = list(tab0,tab1)
  for (c in 1:2) {
  checksj = checksj + sum(sjtab[[c]]==0)
}
if (checksj > 0) {
print(tab0)
print(tab1)
  cat(checksj,"\n")
  stop("there exists an interval(s) with no observation.")
  }
#+end_src

#+RESULTS:
#+begin_example

      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
  1   6   6  15   0   2   3   3   3   3   1   4   1   3   1   1   1   2   3   1
  2   2   6  10   4   6  13   4   7  14   5   3  16  21   5   1  15   8  35   5
  3   2   3  14   8  14  17  12  22  26  14  26  44  44  16  16  64  19  54  28
  4   0   0   6  13   4  18  20  30  57  30  50  49  27  29  21  67  40  39  39
  5   0   0   0   5   2  12  22  21  46  30  37  38  25  99  57  52  98  52  95

     20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
  1   4   4   4   8   8   3   3   7   1   2   7   0   4   1  40  15  21  34  16
  2   3   6  17  14  27  13  17  25   2   7  35   2   9  14  68  53  60  58  59
  3  10   4  23  28  45  14  36  63  24  23  55   0   2  15  53  53  41  53  67
  4  42   5  12  12  65  26  64  66  45  49  70   0   0   9  17  21  29  37  36
  5 169   2   8  11  49  24  82  70 121  75  53   2   0   4   5  14   6  44  29

     39  40
  1  37   5
  2  82  30
  3  29  21
  4  23  49
  5  11  98

      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
  1 156 180  84  70 122  62  39  40   3   4  34   3   9   3   3   2   4   3   0
  2  70  50 100  93  77  87  83  78  29  46  50  31  46  23  42  12  17  13   8
  3  12   6  17  44  20  28  38  30  32  46  32  32  33  34  66  24  20  19   9
  4   3   0   4  12   3  10  22  16  29  52  12  27  25  22  30  12  19  13  33
  5   0   0   1   2   1   1   8   4  12  23   3  10  18  19  14   2  24  20  33

     20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38
  1   0  73  26  11   1   7   1   0   0   2   3 150 133  75  13   8   1   9   0
  2   6  91  48  55   8  45  10   4   5  18  11  83  83  85  23  21  21  10   9
  3   2  45  63  66  16  57  19   6  13  29   8  13  14  31  17  33  37   1  13
  4   2  17  39  36  17  46  11   3  21  21   6   1   4  14  12  18  21   3  14
  5  13   4  11  10  15  16   8   7  19  25   3   0   2   3   3  15  14   2   8

     39  40
  1  19   1
  2  16   5
  3  20   7
  4   9  18
  5   5  17
20
Error: there exists an interval(s) with no observation.
#+end_example

** survSplit
#+begin_src R :results none :tangle R/chessB-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dit$item, person = dit$person, time = dit$RT, response = dit$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
#+end_src

#+begin_src R :tangle R/chessB-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+end_src

#+RESULTS:
: Using response as value column: use value.var to override.
: Using time as value column: use value.var to override.
: Using seg_g as value column: use value.var to override.
: Using len as value column: use value.var to override.

#+begin_src R :results none :tangle R/chessB-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mNA),"input/mNA.csv", col_names = FALSE)
#+end_src

#+begin_src R :results none :tangle R/chessB-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** boxplot
#+begin_src R :results code
myacc = dit %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1)) %>% mutate(accuracy = T / (T +F))
#+end_src

#+RESULTS:
#+begin_src R
`summarise()` ungrouping output (override with `.groups` argument)
#+end_src

#+begin_src R
rt_boxp <- ggplot(dit, aes(x=factor(resp),y=time,fill=factor(resp)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit, aes(x=factor(resp),y=log(time),fill=factor(resp)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
acc_plot <- ggplot(myacc, aes(x=item,y=accuracy)) +
  geom_text_repel(label=1:I, segment.color = "grey50", size=3) +
  labs(title="Accuracy")
#+end_src

#+RESULTS:

[[file:figure/RTnACC.pdf]]

#+begin_src R
pdf("figure/RTnACC.pdf")
rt_boxp
acc_plot
logrt_boxp
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: null device
:           1

** prior & jump
This is to export hyper-parameters and jumping rule
#+begin_src R :results none :tangle R/chessB-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(1.0,I,G)
b_lambda = matrix(1.0,I,G)
jump_lambda = matrix(0.25,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(1.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(1.0),N,2)
jump_theta = matrix(0.25,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(1.0),1,2)
jump_gamma = matrix(0.05,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.25,I,2)
#+end_src

#+begin_src R :results none :tangle R/write-prior.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+end_src

** init
#+begin_src R :results none :tangle R/chessB-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/write-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src

** diffused prior
#+begin_src R :results none :tangle R/chessB_noinfo-preprocess.R
source("R/chessB-preprocess.R")

mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
l_c = 2
l_m = ((G - 1) / (quantile(time, 0.75)  * (G - 1:G + 0.5)))
a_lambda = matrix(l_m/l_c, I, G, byrow=T)
b_lambda = matrix(1 / l_c,I,G)
## a_lambda = matrix(0.0001, I, G, byrow=T)
## b_lambda = matrix(0.0001, I, G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(sqrt(10000.0),I,2)
jump_beta = matrix(0.25,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(sqrt(10000.0),N,2)
jump_theta = matrix(0.2,N,2)

a_sigma = 0.0001
b_sigma = 0.0001

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(sqrt(2.0),1,2)
jump_gamma = matrix(0.01,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(sqrt(1.0),N,2)
jump_z = matrix(0.5,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(sqrt(1.0),I,2)
jump_w = matrix(0.15,I,2)

source("R/write-prior.R")
#+end_src

** Choose-a-move test B: pp Gamma(0) = 1, Gamma(1) = 1
#+begin_src R :results none :tangle R/chessB_pp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: np (default) Gamma(0) = -1, Gamma(1) = 1
#+begin_src R :results none :tangle R/chessB_np-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, 1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: nn Gamma(0) = -1, Gamma(1) = -1
#+begin_src R :results none :tangle R/chessB_nn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: pn Gamma(0) = 1, Gamma(1) = -1
#+begin_src R :results none :tangle R/chessB_pn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: no_latent Gamma(0) = 0, Gamma(1) = 0
#+begin_src R :results none :tangle R/chessB_no_latent-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 0*matrix(c(1, -1), ncol = 1);

init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: fn (free gamma0) Gamma(0) > 0, Gamma(1) = -1
:PROPERTIES:
:ID:       f4cdf66c-59ff-4569-9fec-04baa3f2b694
:END:
#+begin_src R :results none :tangle R/chessB_fn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, -1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: fp (free gamma0) Gamma(0) > 0, Gamma(1) = 1
:PROPERTIES:
:ID:       3d57be6d-547d-40a8-81a1-43b45124dd57
:END:
#+begin_src R :results none :tangle R/chessB_fp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: pf (free gamma1) Gamma(0) = 1, Gamma(1) > 0
:PROPERTIES:
:ID:       dc374dfa-1995-4432-9929-038f3c5c52e0
:END:
#+begin_src R :results none :tangle R/chessB_pf-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: nf (free gamma1) Gamma(0) = -1, Gamma(1) > 0
:PROPERTIES:
:ID:       9b975f46-8639-4b53-8ee6-0eb16721eb63
:END:
#+begin_src R :results none :tangle R/chessB_nf-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*2*I), ncol = 2);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: nn (free gamma1) Gamma(0) = -1, Gamma(1) = -1
#+begin_src R :results none :tangle R/chessB_double_nn-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(-1, -1), ncol = 1);

init_w = 1*matrix(rnorm(2*I), nrow = 2*I, ncol = 2, byrow=TRUE);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

** Choose-a-move test B: pp (free gamma1) Gamma(0) = 1, Gamma(1) = 1
#+begin_src R :results none :tangle R/chessB_double_pp-init.R
mvar = as.matrix( readr::read_csv("input/mvar.csv", col_names=F) )
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);

init_gamma = 1*matrix(c(1, 1), ncol = 1);

init_w = 1*matrix(rnorm(2*I), nrow = 2*I, ncol = 2, byrow=TRUE);
init_z = 1*matrix(rnorm(2*2*N), ncol = 2);

source("R/write-init.R")
#+end_src

* MATH: Korea_PISA2015
** notebook
#+begin_src R
source('R/pisa-KR-preprocess.R')
source('R/pisa-KR-init.R')
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-preprocess.R
## pick_person = 1:615
pick_person = 1:615
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:21

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)

load("data/Korea_PISA2015.rdata")
df = as_tibble(Korea_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+end_src

#+begin_src R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

## exclude no person / no item
## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+begin_src R :tangle R/art-functions.R
tabulate_id <- function(chrid) {
  ## reference table of charactor and numeric id
  chr <- sort(unique(chrid))
  out <- data.frame(chr = chr, num = seq_len(length(chr)))
  return(out)
}
to_numID <- function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID <- function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+end_src

#+begin_src R :tangle R/pisa-KR-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+end_src

#+begin_src R :tangle R/pisa-KR-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+end_src

** knot selection
#+begin_src R :tangle R/pisa-KR-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+begin_src R :tangle R/pisa-KR-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+end_src

#+begin_src R :tangle R/pisa-KR-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut #
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+begin_src R :tangle R/pisa-KR-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+end_src

#+begin_src R :tangle R/pisa-KR-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+end_src

#+begin_src R :tangle R/pisa-KR-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** init
#+begin_src R :results none :tangle R/pisa-KR-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src

* Science: Korea_PISA2018                                           :ARCHIVE:
** notebook
#+begin_src R
source('R/pisa-KR-sci2018-preprocess.R')
source('R/pisa-KR-sci2018-init.R')
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-sci2018-preprocess.R
## pick_person = 1:798
pick_person = 1:798
## pick_item = 1:23 # (it seems like the first cluster)
pick_item = 1:23

ncut = 5 # segment # in piecewise approximation

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("R/art-functions.R")

library(dplyr)
library(magrittr)
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-sci2018-preprocess.R
load("data/Korea_PISA2018.rdata")
df = as_tibble(Korea_2018)
## info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
## polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
## pdx = which(colnames(df) %in% polytomous)
## pdx = c(pdx,pdx + 184)
## df[,-pdx]
#+end_src


#+begin_src R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-sci2018-preprocess.R
di = df[,1:(115 + 3)]
dt = df[,c(1:3,(115+4):233)]
its = c()
dt01 = dt[,pick_item] %>% na.omit
di01 = di[,pick_item] %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[is.na(di01)] = 999
di01[di01 == 2] = 1

## drop plytomous
di01 = di01[,-c(11,14,15)]
dt01 = dt01[,-c(11,14,15)]

## di01 = di01[pick_person,pick_item]
## dt01 = dt01[pick_person,pick_item]
#+end_src

** numeric ID
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+end_src

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+end_src

** knot selection
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src

** survSplit
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
library(survival)
tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
nitem = ncol(tt01)

tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble

mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
#+end_src

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
## data and fixed parameters
I = nrow(mt)
N = ncol(mt)
C = 2
G = ncut
#+end_src

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "input/mvar.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mlen),"input/mlen.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mseg),"input/mseg.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mh),"input/mh.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mt),"input/mt.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mi),"input/mi.csv", col_names = FALSE)
#+end_src

This is to export hyper-parameters and jumping rule
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
mvar = readr::read_csv("input/mvar.csv", col_names=FALSE) %>% as.matrix()
I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

## lambda
a_lambda = matrix(0.1,I,G)
b_lambda = matrix(0.1,I,G)
jump_lambda = matrix(0.5,I,G)

mu_beta = matrix(0.0,I,2)
sigma_beta = matrix(1.0,I,2)
jump_beta = matrix(0.1,I,2)

mu_theta = matrix(0.0,N,2)
sigma_theta = matrix(1.0,N,2)
jump_theta = matrix(1.0,N,2)

a_sigma = 1.0
b_sigma = 1.0

mu_gamma = matrix(0.0,1,2)
sigma_gamma = matrix(1.0,1,2)
jump_gamma = matrix(1.0,1,2)

mu_z = matrix(0.0,N,2)
sigma_z = matrix(1.0,N,2)
jump_z = matrix(1.0,N,2)

mu_w = matrix(0.0,I,2)
sigma_w = matrix(1.0,I,2)
jump_w = matrix(0.5,I,2)
#+end_src

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"input/pj_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"input/pj_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"input/pj_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"input/pj_sigma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"input/pj_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"input/pj_z.csv", col_names = FALSE)
readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"input/pj_w.csv", col_names = FALSE)
#+end_src

#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
mtab_sj = t( apply(mseg, 1, function(x) tab_sj(x,G)) )

tmp_0 = mseg; tmp_0[mi==1] = -99;
tmp_1 = mseg; tmp_1[mi==0] = -99;

mIY = rbind( t( apply(tmp_0, 1, function(x) tab_IY(x,G)) ), t( apply(tmp_1, 1, function(x) tab_IY(x,G)) ))

readr::write_csv(as.data.frame(mtab_sj),"input/mtab_sj.csv", col_names = FALSE)
readr::write_csv(as.data.frame(mIY),"input/mIY.csv", col_names = FALSE)
#+end_src

** init
#+begin_src R :results none :tangle R/pisa-KR-sci2018-init.R
mvar = as.matrix(readr::read_csv("input/mvar.csv", col_names=F))
I = mvar[1]
N = mvar[2]
G = mvar[4]

set.seed(as.numeric(Sys.time()))

init_lambda = matrix(1, nrow = 2*I, ncol = G);
init_beta = 0*matrix(rnorm(2*I), ncol = 2);
init_theta = 0*matrix(rnorm(2*N), ncol = 2);
init_gamma = 1*matrix(c(1, 1), ncol = 1);
init_w = 0*matrix(rnorm(2*2*I), ncol = 2);
init_z = 0*matrix(rnorm(2*2*N), ncol = 2);
#+end_src

#+begin_src R :results none :tangle R/pisa-KR-sci2018-init.R
readr::write_csv(as.data.frame(init_lambda), "input/init_lambda.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_beta), "input/init_beta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_theta), "input/init_theta.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_gamma), "input/init_gamma.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_w), "input/init_w.csv", col_names = FALSE)
readr::write_csv(as.data.frame(init_z), "input/init_z.csv", col_names = FALSE)
#+end_src

** boxplot

#+begin_src R :results value :tangle R/pisa-KR-sci2018-preprocess.R
di01_long <- reshape2::melt(di01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- reshape2::melt(dt01 %>% dplyr::select(-schid, -stuid), id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+end_src

#+begin_src R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 999))
#+end_src

[[file:figure/boxplot_ART.pdf]]
#+begin_src R :tangle R/pisa-KR-sci2018-preprocess.R
pdf("figure/boxplot_ART.pdf")
## rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
## geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01[,4:6], aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
## print(rt_boxp)
print(logrt_boxp)
dev.off(which = dev.cur())
#+end_src

* C++ MCMC output
** Shell to run C++
#+begin_src sh :tangle run.sh
#!/usr/bin/env bash
out_dir="duolingo_pn_ncut5_zero_beta_noinfo_lc2/"
prename="R/duolingo_noinfo-preprocess.R"
initname="R/duolingo_pn-init.R"
n_chain=2

echo "================================"
echo "Output dir:" $out_dir
echo "preprocessing:" $prename
echo "initializing:" $initname
echo "n_chain:" $n_chain
echo "================================"

export STAN_NUM_THREADS=2
mkdir -p output
rm output/*
rm input/*

Rscript $prename
cp input/{mvar,mlen,mseg,mh,mi,mt}.csv output/
cp run.sh output/
cp $prename output/
cp $initname output/

for ((v = 1; v <= $n_chain; v++))
do
    Rscript $initname
    ./main initialize parallel single_w single_z sparse latent gamma true single no_ars nonzero_theta zero_beta lambda_free $v 10000 10000 10
done
## explain comandline arguments:
 # continue initialize -> start new chains?
 # parallel serial -> parallel computation?
 # single_w double_w
 # single_z double_z
 # full sparse -> missing or not
 # latent no_latent -> update latent space?
 # gamma no_gamma -> update gamma?
 # true false -> can I play with the gamma sign?
 # correct incorrect single both -> gamma for what process?
 # do_ars no_ars -> ARS for gamma
 # zero_theta nonzero_theta -> theta.k.0 are zero
 # double_beta single_beta

mkdir -p $out_dir
mv output/* $out_dir
Rscript R/run-analysis.R $out_dir $n_chain
echo "Outputs are moved to" $out_dir"."
echo "================================"
#+end_src

#+begin_src R :tangle no
#!/usr/bin/env bash
out_dir="chessB_double_no_ncut5_zero_beta_noinfo_lc2/"
prename="R/chessB_noinfo-preprocess.R"
initname="R/chessB_no_latent-init.R"
n_chain=2

echo "================================"
echo "Output dir:" $out_dir
echo "preprocessing:" $prename
echo "initializing:" $initname
echo "n_chain:" $n_chain
echo "================================"

export STAN_NUM_THREADS=2
mkdir -p output
rm output/*
rm input/*

Rscript $prename
cp input/{mvar,mlen}.csv output/
cp run.sh output/
cp $prename output/
cp $initname output/

for ((v = 1; v <= $n_chain; v++))
do
    Rscript $initname
    ./main initialize parallel double_w double_z full no_latent no_gamma true both no_ars nonzero_theta zero_beta lambda_free $v 10000 10000 10
done
## explain comandline arguments:
 # continue initialize -> start new chains?
 # parallel serial -> parallel computation?
 # single_w double_w
 # single_z double_z
 # full sparse -> missing or not
 # latent no_latent -> update latent space?
 # gamma no_gamma -> update gamma?
 # true false -> can I play with the gamma sign?
 # correct incorrect false -> gamma for what process?
 # do_ars no_ars -> ARS for gamma
 # zero_theta nonzero_theta -> theta.k.0 are zero
 # double_beta single_beta

mkdir -p $out_dir
mv output/* $out_dir
Rscript R/run-analysis.R $out_dir $n_chain 0 0
echo "Outputs are moved to" $out_dir"."
echo "================================"
#+end_src

* Using R
** Initiate R analysis + prerequites
#+begin_src R :tangle R/run-analysis.R
#!/usr/bin/env Rscript
args <- commandArgs(trailingOnly = TRUE)
# test if there is at least one argument: if not, return an error

## default
double_z <- 0
double_w <- 0

HAS_REF <- 0
ref_dir <- ""

if (length(args) == 0) {
  stop("At least one argument must be supplied (input file).n", call. = FALSE)
} else if (length(args) == 2) {
  # default output file
  num_chain <- as.numeric(args[2])
} else if (length(args) >= 3) {
  # default output file
  num_chain <- as.numeric(args[2])
  double_w <- 1 * (args[3] == "1")
  double_z <- 1 * (args[4] == "1")
} else if (length(args) == 1) {
  # default output file
  num_chain <- 3
}
out_dir <- args[1]
## out_dir <- "chessB-singleZ-singleW/"
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir, "figure/"))
#+end_src

set the output directory. run the chain of analytic tools. move the results to the output dir.
#+begin_src R :results none
## out_dir="chessB_pn_ncut5_zero_beta_noinfo_lc2/"
out_dir="chessB_new_sigma_update_pn_ncut5_zero_beta_noinfo_lc2/"
## out_dir="verbal_pn_ncut5_zero_beta_noinfo_lc2/"
## out_dir="opusIII_pn_ncut5_zero_beta_noinfo_lc2/"

num_chain <- 1; HAS_REF <- 0;
system(paste0("rm figure/*.pdf"))
source("R/art-analysis.R")
system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir,"figure/"))
#+end_src

load library, functions, scripts, etc.
#+begin_src R :results none :tangle R/Renviron.R
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
##registerDoParallel(cores = detectCores() - 1)
stopImplicitCluster()
registerDoParallel(2)

setwd("~/workspace/lsjm-code")

source("R/art-functions.R")
#+end_src

#+begin_src R :results none :tangle R/art-analysis.R
source("R/Renviron.R")
source('R/load-outputs.R')
## source('R/write_summary.R')
source('R/visual-latent-space-plot.R')
source('R/visual-trace-plot.R')
## source('R/CIF_posm.R')
## source('R/CIF.R')
#+end_src

print average acceptance rate per type of quantities: \lambda, \beta, \theta, z, w, \gamma, \sigma
#+begin_src sh
cat output/summary.csv
#+end_src

** example to extract w0 and z0
:PROPERTIES:
:header-args:R: :tangle R/latent_post_mean.R
:END:
This is an example to extract the Procrustean matched coordinates of the latent space.
#+begin_src R
out_dir <- "duolingo_pn_ncut5_zero_beta_noinfo_lc2/"
num_chain <- 2
HAS_REF <- 0

source("R/Renviron.R")
source("R/load-outputs.R")

z0 <- matched$z0
w0 <- matched$w0

readr::write_csv(as.data.frame(w0), paste0(out_dir, "w0.csv"))
readr::write_csv(as.data.frame(z0), paste0(out_dir, "z0.csv"))
#+end_src

** Biclustering example
:PROPERTIES:
:EXPORT_FILE_NAME: biclustering_example
:END:

Method: cite:dhillon_co-clustering_2001
Dhillon, I. S., Co-clustering documents and words using bipartite spectral graph partitioning, In , Proceedings of the Seventh {{ACM SIGKDD}} International Conference on {{Knowledge}} Discovery and Data Mining (pp. 269–274) (2001). {New York, NY, USA}: {Association for Computing Machinery}.

Code: https://scikit-learn.org/stable/modules/biclustering.html
https://scikit-learn.org/stable/auto_examples/bicluster/plot_bicluster_newsgroups.html#sphx-glr-auto-examples-bicluster-plot-bicluster-newsgroups-py
*** initialization
=w0= and =z0= are matrices for latent item and respondent coordinates.
#+begin_src R :results none
out_dir <- "chessB_pn/"
num_chain <- 3
double_z <- 0
double_w <- 0
HAS_REF <- 0
library(art)
library(coda)
library(dplyr)
library(stringr)
library(magrittr)
library(bayesplot)
library(foreach)
library(doParallel)
## registerDoParallel(cores = detectCores() - 1)
stopImplicitCluster()
registerDoParallel(2)

setwd("/Users/yunj/Dropbox/research/lsjm-art/lsjm-code")

w0 <- readr::read_csv(paste0(out_dir, "w0.csv"))
z0 <- readr::read_csv(paste0(out_dir, "z0.csv"))
#+end_src

*** calculate Euclidean distance and Gaussian distance over all item-respondent pairs
- =dist_zw.csv= Euclidean dist
- =rbf_dist_zw.csv= Gaussian dist
#+begin_src R
D <- matrix(0, nrow = nrow(z0), ncol = nrow(w0))
for (i in 1:nrow(D)) {
  for (j in 1:ncol(D)) {
    D[i, j] <- sqrt(sum((z0[i, ] - w0[j, ])^2))
  }
}

RBF_D <- exp(-1 / 2 * D)
readr::write_csv(as.data.frame(D), paste0(out_dir, "dist_zw.csv"))
readr::write_csv(as.data.frame(RBF_D), paste0(out_dir, "rbf_dist_zw.csv"))
#+end_src


#+begin_src emacs-lisp :exports none
;; python
(require 'conda)
(conda-env-activate "tf")
#+end_src

*** biclustering using Python
See https://scikit-learn.org/stable/modules/biclustering.html for the spectral co-clustering method we implement below: ( https://scikit-learn.org/stable/auto_examples/bicluster/plot_spectral_coclustering.html#sphx-glr-auto-examples-bicluster-plot-spectral-coclustering-py)

#+name: 184db033-517c-4a42-b7dc-5999752f3fd6
#+begin_src jupyter-python :tangle latent-biclustering.py
import numpy as np
from matplotlib import pyplot as plt

from sklearn.cluster import SpectralCoclustering
from sklearn.metrics import consensus_score

import pandas as pd
D = pd.read_csv('chessB_pn/rbf_dist_zw.csv', sep=',',header=0)
data = D.values

plt.matshow(data, cmap=plt.cm.Blues)
plt.title("Original dataset")
#+end_src

#+RESULTS: 184db033-517c-4a42-b7dc-5999752f3fd6
:RESULTS:
: Text(0.5, 1.05, 'Original dataset')
[[file:./.ob-jupyter/5c410dc2c8c9bfc6c337607fd33e76ea2dbf1260.png]]
:END:

#+name: 9ec5811f-af20-43af-9d7a-b81193dd62ec
#+begin_src jupyter-python :tangle latent-biclustering.py
# row_idx = np.linspace(0,(data.shape[0]-1), num=data.shape[0]).astype(int)
# col_idx = np.linspace(0,(data.shape[1]-1), num=data.shape[1]).astype(int)
K = 2

model = SpectralCoclustering(n_clusters=K, random_state=0)
model.fit(data)

fit_data = data[np.argsort(model.row_labels_)]
fit_data = fit_data[:, np.argsort(model.column_labels_)]

plt.matshow(fit_data, cmap=plt.cm.Blues)
plt.title("After biclustering; rearranged to show biclusters")
#+end_src

#+RESULTS: 9ec5811f-af20-43af-9d7a-b81193dd62ec
:RESULTS:
: Text(0.5, 1.05, 'After biclustering; rearranged to show biclusters')
[[file:./.ob-jupyter/2358ac0c34e1b2d3ce346e94cce645b368b615be.png]]
:END:

#+name: 8eb17f79-bd45-4d6c-bb93-9df2515a0065
#+begin_src jupyter-python :tangle latent-biclustering.py
df_row = pd.DataFrame(model.row_labels_)
df_col = pd.DataFrame(model.column_labels_)

# save the dataframe as a csv file
df_row.to_csv("chessB_pn/cl_row" + str(K) + ".csv")
df_col.to_csv("chessB_pn/cl_col" + str(K) + ".csv")
#+end_src

#+RESULTS: 8eb17f79-bd45-4d6c-bb93-9df2515a0065

*** back to R for visualization
#+begin_src R :results none
source("R/art-functions.R")

K <- 2

w0 <- readr::read_csv(paste0(out_dir, "w0.csv"))
z0 <- readr::read_csv(paste0(out_dir, "z0.csv"))

cl_z <- readr::read_csv(paste0(out_dir, "cl_row", K, ".csv"))[, 2]
cl_w <- readr::read_csv(paste0(out_dir, "cl_col", K, ".csv"))[, 2]

xmin <- min(z0[, 1], w0[, 1])
ymin <- min(z0[, 2], w0[, 2])
xmax <- max(z0[, 1], w0[, 1])
ymax <- max(z0[, 2], w0[, 2])

pdf(paste0(out_dir, "spc_cl_dist_rbf", K, ".pdf"))

print(cl_lsjmplot(z0, w0, cl_z, cl_w, xlim = c(xmin, xmax), ylim = c(ymin, ymax)))

dev.off(which = dev.cur())
#+end_src

** load outputs
This section contains scripts to create an mcmc object. 1) read MCMC samples, 2) set their column names, and 3) Procrustean matching.
#+begin_src R :tangle R/load-outputs.R
mvar <- readr::read_csv(paste0(out_dir, "mvar.csv"), col_names = F) %>% as.matrix()
I <- mvar[1]
N <- mvar[2]
G <- mvar[4]

sj <- readr::read_csv(paste0(out_dir, "mlen.csv"), col_names = F) %>% as.matrix()
sj <- c(0, cumsum(sj))
H <- sj[2:(G + 1)] - sj[1:G]

cnames <- c(".chain", ".iteration")

## CSVFormat prints by row-major order!
for (c in 0:1) {
  for (i in 1:I) {
    for (g in 1:G) {
      cnames <- c(cnames, paste0("lambda.", c, ".", i, ".", g))
    }
  }
}

for (k in 1:N) {
  for (c in 0:1) {
    cnames <- c(cnames, paste0("theta.", k, ".", c))
  }
}
for (i in 1:I) {
  for (c in 0:1) {
    cnames <- c(cnames, paste0("beta.", i, ".", c))
  }
}

for (c in 0:1) {
  for (k in 1:N) {
    for (d in 1:2) {
      cnames <- c(cnames, paste0("z.", c, ".", k, ".", d))
    }
  }
}

for (c in 0:1) {
  for (i in 1:I) {
    for (d in 1:2) {
      cnames <- c(cnames, paste0("w.", c, ".", i, ".", d))
    }
  }
}

for (c in 0:1) {
  cnames <- c(cnames, paste0("gamma.", c))
}

cnames <- c(cnames, "sigma", "lp_")
#+end_src

#+begin_src R :tangle R/load-outputs.R
## mythin = 10
## mystart = 5001
## myend = 25000

no_z1 <- !grepl("^z\\.1\\.", cnames)
no_w1 <- !grepl("^w\\.1\\.", cnames)

dlist <- list()

for (cid in 1:num_chain) {
  ## pisa-KR KR-sci data should skip 1000
  dlist[[cid]] <- readr::read_csv(paste0(out_dir, "sample_chain", cid, ".csv"), col_names = F, skip = 0) %>% as.data.frame()
  ## dlist[[cid]] = readr::read_csv(paste0(out_dir,"sample_chain",cid,".csv"), col_names=F) %>% as.data.frame()
  colnames(dlist[[cid]]) <- cnames
  ## if (!double_z && !double_w) {
  ##   dlist[[cid]] <- dlist[[cid]][, no_z1 & no_w1] ## remove duplicates when single_z and single_w
  ## } else if (!double_w) {
  ##   dlist[[cid]] <- dlist[[cid]][, no_w1] ## remove duplicates when single_w
  ## } else if (!double_z) {
  ##   dlist[[cid]] <- dlist[[cid]][, no_z1] ## remove duplicates when single_z
  ## }
}

## determine double z,w
 double_z = 1
 double_w = 1

z0 = dlist[[1]][,grepl("^z\\.0\\.", cnames)]
z1 = dlist[[1]][,grepl("^z\\.1\\.", cnames)]
w0 = dlist[[1]][,grepl("^w\\.0\\.", cnames)]
w1 = dlist[[1]][,grepl("^w\\.1\\.", cnames)]

if (sum((z0-z1)^2) < 1.0e-20) double_z = 0
if (sum((w0-w1)^2) < 1.0e-20) double_w = 0
## mylist[[cid]] = mcmc(df, start = mystart, end = myend, thin = mythin)
#+end_src

# TODO: This function is under revision!!
#+begin_src R :tangle R/art-functions.R
my_procrustes <- function(Xstar, dlist, is_list = FALSE, bind_zw = FALSE, my_translation = TRUE, my_scale = FALSE, my_reflect = TRUE) {
  posm <- 0
  if (is_list == TRUE) {
    num_chain <- length(dlist)
  } else {
    num_chain <- 1
  }
  for (i in 1:num_chain) {
    if (is_list == TRUE) {
      df <- dlist[[i]]
    } else {
      df <- dlist
    }

    num_samples <- nrow(df)

    z0dx <- grepl("^z\\.0\\.", colnames(df))
    z1dx <- grepl("^z\\.1\\.", colnames(df))
    w0dx <- grepl("^w\\.0\\.", colnames(df))
    w1dx <- grepl("^w\\.1\\.", colnames(df))

    no_z1 <- sum(z1dx) == 0
    no_w1 <- sum(w1dx) == 0

    num_w <- sum(w0dx) / 2
    num_z <- sum(z0dx) / 2
    w0 <- aperm(array(unlist(t(df[, w0dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    z0 <- aperm(array(unlist(t(df[, z0dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))

    w0star <- Xstar$w.0
    z0star <- Xstar$z.0

    if (no_w1) {
      w1 <- NULL
    } else {
      if (no_z1) stop('require double_z = 1')
      sout = MCMCpack::procrustes(Xstar$w.1, w0star)
      w1star <- sout$X.new
      w1 <- aperm(array(unlist(t(df[, w1dx])), dim = c(2, num_w, num_samples)), c(2, 1, 3))
    }
    if (no_z1) {
      z1 <- NULL
    } else {
      z1star = Xstar$z.1 %*% sout$R + rep(sout$tt, each = num_z)
      z1 <- aperm(array(unlist(t(df[, z1dx])), dim = c(2, num_z, num_samples)), c(2, 1, 3))
    }

    adx <- z0dx | z1dx | w0dx | w1dx

    xstar0 = rbind(w0star,z0star)
    xstar1 = rbind(w1star,z1star)

    mm <- foreach(k = 1:num_samples) %dopar% {
      if (!bind_zw) {
        pout <- MCMCpack::procrustes(w0[, , k], w0star)
        w0[, , k] <- pout$X.new
        z0[, , k] <- z0[, , k] %*% pout$R + rep(pout$tt, each = num_z)
      } else {
        bout <- MCMCpack::procrustes(rbind(w0[, , k],z0[,,k]), xstar0)
        w0[, , k] <- bout$X.new[1:num_w, ]
        z0[, , k] <- bout$X.new[(num_w+1):(num_w+num_z), ]
        }

        if (!no_w1 & !bind_zw) {
          pout <- MCMCpack::procrustes(w1[, , k], w1star)
          w1[, , k] <- pout$X.new
          }
      if (!no_z1 & !bind_zw) {
          z1[, , k] <- z1[, , k] %*% pout$R + rep(pout$tt, each = num_z)
        }
      if (!no_w1 & bind_zw) {
        bout <- MCMCpack::procrustes(rbind(w1[, , k],z1[,,k]), xstar1)
        w1[, , k] <- bout$X.new[1:num_w, ]
        z1[, , k] <- bout$X.new[(num_w+1):(num_w+num_z), ]
      }
        rbind(z0[, , k], z1[, , k], w0[, , k], w1[, , k])
      }
      tmm <- lapply(mm, t)
      df[, adx] <- t(matrix(unlist(tmm), nrow = sum(adx)))

      posm <- posm + Reduce("+", mm) / num_samples
      if (is_list == TRUE) {
        dlist[[i]] <- df
      } else {
        dlist <- df
      }
    }

    posm <- posm / num_chain
    z0 <- posm[1:num_z, ]
    if (no_z1 && no_w1) {
      w0 <- posm[num_z + (1:num_w), ]
    } else if (no_z1 && !no_w1) {
      w0 <- posm[num_z + (1:num_w), ]
      w1 <- posm[num_z + num_w + (1:num_w), ]
    }

    if (!no_z1 && no_w1) {
      z1 <- posm[num_z + (1:num_z), ]
      w0 <- posm[2 * num_z + (1:num_w), ]
    } else if (!no_z1 && !no_w1) {
      z1 <- posm[num_z + (1:num_z), ]
      w0 <- posm[2 * num_z + (1:num_w), ]
      w1 <- posm[2 * num_z + num_w + (1:num_w), ]
    }
    return(list(dlist = dlist, z0 = z0, z1 = z1, w0 = w0, w1 = w1))
  }
#+end_src

#+begin_src R :results none :tangle R/load-outputs.R
if (!HAS_REF) {
  Xstar <- find_xstar_inlist(dlist)
  readr::write_csv(as.data.frame(Xstar$z.0), paste0(out_dir, "z0star.csv"), col_names = FALSE)
  readr::write_csv(as.data.frame(Xstar$w.0), paste0(out_dir, "w0star.csv"), col_names = FALSE)
}
#+end_src

#+begin_src R :results none :tangle R/load-outputs.R
if (HAS_REF) {
  Xstar <- list()
  Xstar$z.0 <- readr::read_csv(paste0(ref_dir, "z0star.csv"), col_names = FALSE) %>% as.matrix()
  Xstar$w.0 <- readr::read_csv(paste0(ref_dir, "w0star.csv"), col_names = FALSE) %>% as.matrix()
}
#+end_src

#+begin_src R :tangle R/load-outputs.R
matched <- my_procrustes(Xstar, dlist, is_list = T, bind_zw = T)
## , my_translation = TRUE, my_scale = FALSE)
mydf <- matched$dlist
mdf <- bind_rows(matched$dlist, .id = "column_label")
#+end_src

#+RESULTS:

#+begin_src R :tangle R/load-outputs.R
mylist <- mcmc.list()
item <- 1
cname <- names(mydf[[1]])
mylist <- mcmc.list()
for (cid in 1:num_chain) {
  for (c in 0:1) {
    for (k in 1:N) {
      z <- mydf[[cid]][, stringr::str_which(cname, paste0("z\\.", c,  "\\.", k, "\\.[1-2]"))]
      w <- mydf[[cid]][, stringr::str_which(cname, paste0("w\\.", c,  "\\.", item, "\\."))]
      mydf[[cid]][[paste0("dist_z.", c, ".", k, "_", "w.", c, ".", item)]] <- sqrt(rowSums((z - w)^2))
    }
  }
  mylist[[cid]] <- mcmc(mydf[[cid]])
}
#+end_src

#+RESULTS:

The posterior means of \beta, \theta, \lambda are exported to CSV files.
#+begin_src R :tangle R/write_summary.R
ss <- summary(mylist)
mm <- ss$statistics[, "Mean"]
rr <- c(grep("^beta", names(mm)), grep("^theta", names(mm)))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "beta_theta_mean.csv"))
#+end_src

#+RESULTS:

#+begin_src R :tangle R/write_summary.R
rr <- grep("^lambda", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "lambda_mean.csv"))
#+end_src

#+RESULTS:

#+begin_src R :tangle R/write_summary.R
rr <- grep("^z\\.0\\.", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "z0_mean.csv"))
#+end_src

#+RESULTS:

#+begin_src R :tangle R/write_summary.R
rr <- grep("^w\\.0\\.", names(mm))
dout <- data.frame(vname = names(mm[rr]), mean = mm[rr])
readr::write_csv(dout, paste0(out_dir, "w0_mean.csv"))
#+end_src

#+RESULTS:

#+begin_src R :results none
## sink("output/mcmc_summary.txt")
cat("==================================")
cat("Rejection Rate")
cat("==================================")
rejectionRate(mylist)
cat("==================================")
cat("Effective Size")
cat("==================================")
effectiveSize(mylist)
cat("==================================")
cat("Summary")
cat("==================================")
summary(mylist)
## sink()
#+end_src

** latent space visualization

HPD based latent plot
[[pdf:figure/latent_space_hpd.pdf::1]]
#+begin_src R :tangle R/visual-latent-space-plot.R
mcdf <- mcmc(mdf[, -1])
tn <- nrow(mcdf)
hpd <- apply(HPDinterval(mcdf, prob = 1 / tn), 1, median)

z0dx <- grepl("^z\\.0\\.", names(hpd))
z1dx <- grepl("^z\\.1\\.", names(hpd))
w0dx <- grepl("^w\\.0\\.", names(hpd))
w1dx <- grepl("^w\\.1\\.", names(hpd))

num_w <- sum(w0dx) / 2
num_z <- sum(z0dx) / 2
no_z1 <- sum(z1dx) == 0
no_w1 <- sum(w1dx) == 0
w0 <- matrix(hpd[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 <- NULL
} else {
  w1 <- matrix(hpd[w1dx], byrow = T, nrow = num_w, ncol = 2)
}
if (no_z1) {
  z1 <- NULL
} else {
  z1 <- matrix(hpd[z1dx], byrow = T, nrow = num_z, ncol = 2)
}

z0 <- matrix(hpd[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
myname <- c(1:N, paste0("I.", 1:I))

pdf("figure/latent_space_hpd.pdf")
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[pdf:figure/latent_space_med.pdf::1]]
#+begin_src R :tangle R/visual-latent-space-plot.R
med <- apply(mdf[, -1], 2, median)

z0dx <- grepl("^z\\.0\\.", names(med))
z1dx <- grepl("^z\\.1\\.", names(med))
w0dx <- grepl("^w\\.0\\.", names(med))
w1dx <- grepl("^w\\.1\\.", names(med))

num_w <- sum(w0dx) / 2
num_z <- sum(z0dx) / 2
no_z1 <- sum(z1dx) == 0
no_w1 <- sum(w1dx) == 0
w0 <- matrix(med[w0dx], byrow = T, nrow = num_w, ncol = 2)
if (no_w1) {
  w1 <- NULL
} else {
  w1 <- matrix(med[w1dx], byrow = T, nrow = num_w, ncol = 2)
}
if (no_z1) {
  z1 <- NULL
} else {
  z1 <- matrix(med[z1dx], byrow = T, nrow = num_z, ncol = 2)
}

z0 <- matrix(med[z0dx], byrow = T, nrow = num_z, ncol = 2)
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
myname <- c(1:N, paste0("I.", 1:I))

pdf("figure/latent_space_med.pdf")
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2


[[file:figure/latent_space_mode.pdf]]
#+begin_src R :tangle R/visual-latent-space-plot.R
if (!HAS_REF) {
  z0.star <- Xstar$z.0
  z1.star <- Xstar$z.1
  w0.star <- Xstar$w.0
  w1.star <- Xstar$w.1

  xmin <- min(z0.star[, 1], z1.star[, 1], w0.star[, 1], w1.star[, 1])
  ymin <- min(z0.star[, 2], z1.star[, 2], w0.star[, 2], w1.star[, 2])
  xmax <- max(z0.star[, 1], z1.star[, 1], w0.star[, 1], w1.star[, 1])
  ymax <- max(z0.star[, 2], z1.star[, 2], w0.star[, 2], w1.star[, 2])

  myname <- c(1:N, paste0("I.", 1:I))
  pdf("figure/latent_space_mode.pdf")
  print(lsjmplot(z0.star, w0.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  if (double_z && !double_w) {
    print(lsjmplot(z1.star, w0.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  } else if (double_z && double_w) {
    print(lsjmplot(z1.star, w1.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  } else if (!double_z && double_w) {
    print(lsjmplot(z0.star, w1.star, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
  }

  dev.off(which = dev.cur())
}
#+end_src

#+RESULTS:
: pdf
:   2


[[file:figure/latent_space_single.pdf]]
#+begin_src R
pdf("figure/latent_space_single.pdf")

k = 20

##df = mydf[[1]]
df = mydf[[2]]
num_samples = nrow(df)

z0dx = grepl("^z\\.0\\.", colnames(df))
z1dx = grepl("^z\\.1\\.", colnames(df))
w0dx = grepl("^w\\.0\\.", colnames(df))
w1dx = grepl("^w\\.1\\.", colnames(df))

num_w = sum(w0dx) / 2;
num_z = sum(z0dx) / 2;
aw0 = aperm( array(unlist( t(df[,w0dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
aw1 = aperm( array(unlist( t(df[,w1dx])), dim = c(2, num_w, num_samples)), c(2,1,3))
az0 = aperm( array(unlist( t(df[,z0dx])), dim = c(2, num_z, num_samples)), c(2,1,3))
az1 = aperm( array(unlist( t(df[,z1dx])), dim = c(2, num_z, num_samples)), c(2,1,3))

z0 = az0[,,k]
z1 = az1[,,k]
w0 = aw0[,,k]
w1 = aw1[,,k]
xmin = min(z0[,1],z1[,1],w0[,1],w1[,1])
ymin = min(z0[,2],z1[,2],w0[,2],w1[,2])
xmax = max(z0[,1],z1[,1],w0[,1],w1[,1])
ymax = max(z0[,2],z1[,2],w0[,2],w1[,2])

myname = c(1:N,paste0("I.",1:I))
print(lsjmplot(z0,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
if (double_z && !double_w) {
  print(lsjmplot(z1,w0,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0,w1,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[pdf:figure/latent_space_mean.pdf]]
#+begin_src R :tangle R/visual-latent-space-plot.R
pdf("figure/latent_space_mean.pdf")

z0 <- matched$z0
z1 <- matched$z1
w0 <- matched$w0
w1 <- matched$w1
xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(1:N, paste0("I.", 1:I))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

#+begin_src R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "verbal_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "verbal_pn_w.csv", col_names = TRUE)
#+end_src

#+RESULTS:

#+begin_src R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "opusIII_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "opusIII_pn_w.csv", col_names = TRUE)
#+end_src

#+RESULTS:

#+begin_src R
readr::write_csv(data.frame(x=z0[,1], y=z0[,2]), "chessB_pn_z.csv", col_names = TRUE)
readr::write_csv(data.frame(x=w0[,1], y=w0[,2]), "chessB_pn_w.csv", col_names = TRUE)
#+end_src

#+RESULTS:

** MCMC trace plots
[[file:figure/lambda_mcmc_interval_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/lambda_mcmc_interval_plot.pdf")
p0 <- mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.0\\.1\\.",
  transformations = "log"
)
## mcmc_areas(
##  lambda0.sam,
##  prob = 0.8, # 80% intervals
##  prob_outer = 0.99, # 99%
##  point_est = "mean"
## )

p1 <- mcmc_intervals(
  mylist,
  regex_pars = "^lambda\\.1\\.1\\.",
  transformations = "log"
)
print(p0)
print(p1)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2
[[file:figure/beta_parcoord.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/beta_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^beta\\.[0-9]\\."
)
print(p)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/theta_parcoord.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/theta_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^theta\\.[0-9]\\."
)
print(p)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/lambda_parcoord.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/lambda_parcoord.pdf")
p <- bayesplot::mcmc_parcoord(mylist,
  regex_pars = "^lambda\\.[0-1]\\.1\\.",
  transformations = "log"
)
print(p)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[pdf:figure/w_parcoord_plot.pdf::1]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/w_parcoord_plot.pdf")
p <- mcmc_parcoord(mylist,
  regex_pars = "^w\\.[0-1]\\.[1-5]\\."
)
print(p)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/dist_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/dist_mcmc_trace_plot.pdf")
p0 <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[0-2]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[3-6]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
p <- mcmc_trace(mylist,
  regex_pars = "^dist_z.[0-1]\\.[7-9]_w",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/lambda_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
colnames(df)[grepl("^w\\.1\\.", colnames(df))]


pdf("figure/lambda_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (item in 1:I) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^lambda\\.0\\.", item, "\\."),
    transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ", item, ".")))

  p <- mcmc_trace(mylist,
    regex_pars = paste0("^lambda\\.1\\.", item, "\\."),
    transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ", item, ".")))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: character(0)
: pdf
:   2

[[file:figure/beta_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/beta_mcmc_trace_plot.pdf")
for (i in 1:I) {
  color_scheme_set("mix-blue-pink")
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^beta\\.", i, "\\."),
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  p + facet_text(size = 15)
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[pdf:figure/theta_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/theta_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
for (k in 1:50) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^theta\\.", k, "\\."),
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/gamma_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/gamma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
  regex_pars = "^gamma\\.",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/lp_sigma_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/lp_sigma_mcmc_trace_plot.pdf")
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(mylist,
  pars = c("sigma", "lp_"),
  facet_args = list(nrow = 2, labeller = label_parsed)
)
print(p <- p + facet_text(size = 15))
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

*** latent space trace

[[pdf:figure/z_pairs_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/z_pairs_plot.pdf")
for (k in 1:min(N, 50)) {
  p <- mcmc_pairs(mylist,
    regex_pars = paste0("^z\\.[0-1]\\.", k, "\\."),
    off_diag_args = list(size = 0.05)
  )
  print(p)
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[pdf:figure/w_pairs_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/w_pairs_plot.pdf")
i_begin = 1
i_begin = i_begin + 1 * (var(mylist[[1]][, varnames(mylist)=="w.0.1.1"]) == 0) # start at item=2 if item=1 gives constant w.
for (i in i_begin:min(I, 50)) {
  p <- mcmc_pairs(mylist,
    regex_pars = paste0("^w\\.[0-1]\\.", i, "\\."),
    off_diag_args = list(size = 0.05)
  )
  print(p)
}
dev.off(which = dev.cur())
#+end_src

#+begin_src R
w = mylist[[1]][,grepl("^w\\.[0]\\.1\\.",cname)]
z = mylist[[1]][,grepl("^z\\.[0]\\.1\\.",cname)]

rowSums((z - w)^2)
#+end_src


[[file:figure/z_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
pdf("figure/z_mcmc_trace_plot.pdf")
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[0-2]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[3-6]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
  regex_pars = "^z.[0-1]\\.[7-9]\\.",
  ## transformations = "log",
  facet_args = list(nrow = 2, labeller = label_parsed)
)
p + facet_text(size = 15)
print(p)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

[[file:figure/w_mcmc_trace_plot.pdf]]
#+begin_src R :tangle R/visual-trace-plot.R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/w_mcmc_trace_plot.pdf")
for (i in 1:min(I, 40)) {
  p <- mcmc_trace(mylist,
    regex_pars = paste0("^w\\.[0-1]\\.", i, "\\."),
    ## transformations = "log",
    facet_args = list(nrow = 2, labeller = label_parsed)
  )
  print(p <- p + facet_text(size = 15))
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: pdf
:   2

** output analysis

#+begin_src R :tangle R/CIF_posm.R
tmp <- foreach(v = 1:num_chain, .combine = "rbind") %dopar% apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp <- tmp[, 1:(which(colnames(mydf[[1]]) == "lp_"))]
  posm <- apply(tmp, 2, mean)
} else {
  posm <- tmp[1:(which(colnames(mydf[[1]]) == "lp_"))]
}

cname <- names(posm)
param <- getparam(posm, sj, i, k)
#+end_src

[[file:figure/tradeoff.pdf]]
#+begin_src R :tangle R/CIF.R
## accuracy = foreach(k=1:N, .combine='rbind') %dopar% fun_accuracy_ick(t,i,k,posm,cname,sj)
pdf(paste0("figure/tradeoff.pdf"))
for (item in 1:I) {
  time <- 1:(sj[G] + 10)
  accuracy <- foreach(k = 1:N, .combine = "rbind") %dopar% {
    param <- getparam(posm, sj, item, k)
    eval_accuracy(param, time)
  }

  plotdf <- reshape::melt(accuracy, id.vars = c("time"))
  colnames(plotdf) <- c("person", "time", "accuracy")

  p <- ggplot(data = plotdf, aes(x = time, y = accuracy, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Plot of speed-accuracy tradeoff for item ", item, "."))
  print(p)
}
dev.off(which = dev.cur())

## system(paste0("open figure/tradeoff_", item, ".pdf")
#+end_src

#+begin_src R :tangle R/art-functions.R
getparam <- function(posm, sj, i, k) {
  cname <- names(posm)
  z <- posm[stringr::str_which(cname, paste0("z\\.[0-1]\\.", k, "\\.[1-2]"))] %>%
    matrix(nrow = 2, ncol = 2) %>%
    t()
  w <- posm[stringr::str_which(cname, paste0("w\\.[0-1]\\.", i, "\\.[1-2]"))] %>%
    matrix(nrow = 2, ncol = 2) %>%
    t()
  gamma <- posm[stringr::str_which(cname, paste0("gamma"))]
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\."))]
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\."))]
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.[0-1]\\.", i, "\\."))] %>%
    matrix(ncol = 2) %>%
    t()
  H <- sj[2:(G + 1)] - sj[1:G]
  res <- list(lambda = lambda, beta = beta, theta = theta, gamma = gamma, z = z, w = w, sj = sj, H = H)
  if (any(unlist(lapply(res, is.na)))) stop("Index out of range")
  ## should if be G+1? or G?
  ## if (ncol(lambda) != (G+1)) stop("ncol(lambda) != G+1")
  if (ncol(lambda) != (G)) {
    stop("ncol(lambda) != G")
  } else {
    return(res)
  }
}
#+end_src

#+begin_src R
param = getparam(posm, sj, i, k)

ll = 0;
uu = 50

cumcicurve(param, 1, ll, uu, 50);
cumcifun(param, 1, ll, uu);
#+end_src

#+begin_src R
##CIF = foreach (k=1:50, .combine='rbind') %dopar% {
##integrand <- function(t) {
##  fun_hazard_surv(t,i,k,posm,cname,sj)
##}
##CIF_k = foreach(t=1:200, .combine='c') %dopar% {
##  integrate(integrand, lower = t-1, upper = t)$value
##}
##cumsum(CIF_k)
##}
#+end_src

[[pdf:figure/CIF.pdf::1]]
#+begin_src R :tangle R/CIF.R
myN <- min(100, N)
maxt <- sj[G + 1] + 10
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF.pdf"))

for (item in 1:I) {
  CIF_T <- foreach(k = 1:myN, .combine = "rbind") %do% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(k = 1:myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), time)
  CIF_F <- data.frame(t(CIF_F), time)
  plot_T <- reshape::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "person", "CIF")
  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ", item, ")."))
  print(p)

  plot_F <- reshape::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "person", "CIF")
  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = FALSE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ", item, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+end_src

[[pdf:figure/CIF_person.pdf::1]]
#+begin_src R :tangle R/CIF_person.R
## choose a few people adn items from latent space
z0 <- matched$z0
w0 <- matched$w0
## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci
myI <- sort(c(8, 12, 14, 17, 1, 6, 13, 18)) ## pisa KR

which_z <- function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

myN <- NULL
for (i in 1:length(myI)) {
  myN <- c(myN, which_z(w0[myI[i], ], z0))
}
myN <- c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt <- sj[G + 1] + 10
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_person.pdf"))

for (k in myN) {
  CIF_T <- foreach(item = myI, .combine = "rbind") %do% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(item = myI, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), c(time))
  colnames(CIF_T) <- c(paste0("I", myI), "time")

  plot_T <- reshape2::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "item", "CIF")

  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = item)) +
    geom_line(aes(color = factor(item)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (person ", k, ")."))
  print(p)

  CIF_F <- data.frame(t(CIF_F), c(time))
  colnames(CIF_F) <- c(paste0("I", myI), "time")

  plot_F <- reshape2::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "item", "CIF")

  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = item)) +
    geom_line(aes(color = factor(item)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (person ", k, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: Error: object 'matched' not found
: Error: object 'matched' not found
: Error in which_z(w0[myI[i], ], z0) : object 'z0' not found
: Error in is.data.frame(x) : object 'z0' not found
: Error: object 'sj' not found
: Error in seq.default(0, maxt, (maxt)/num_seg) : object 'maxt' not found
: null device
:           1

[[pdf:figure/latent_space_person.pdf]]
#+begin_src R :tangle R/CIF_person.R
pdf("figure/latent_space_person.pdf")

z1 <- matched$z1
w1 <- matched$w1
z0 <- matched$z0[myN, ]
w0 <- matched$w0[myI, ]

xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(myN, paste0("I.", myI))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

#+begin_src R :tangle R/CIF_person.R
system(paste0("rsync -v figure/CIF_person.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_person.pdf ", out_dir, "figure/"))
#+end_src

[[pdf:figure/latent_space_cl1.pdf]]
#+begin_src R :tangle R/CIF_cl.R
pdf("figure/latent_space_cl1.pdf")

## myI = sort(c(35,7,6,24,28,29,8,27,13,15)) ## opus
## myI = sort(c(32,24,30,8,2,15,6,12,5,20,7,26,21,31)) ## verbal
## myI = sort(c(17,14,3,2,15,9,10,13,11)) ## pisa
## myI = sort(c(8,9,5,4,13,2,3,15)) ## pisa KR sci

## myN = c(23,37,20,27,33,36) ## marketing
## myI = 1:I # marketing

## myN = c(62,589,14,219,524,509,161,435,252,595) ## pisa KR
## myI = 1:I # pisa KR

## myN = c(518, 584, 370, 418, 79, 276, 572, 358, 73, 274) ## pisa
## myI = 1:I # pisa

myN <- c(270, 367, 712, 17, 615, 265, 653, 484, 155, 290) ## pisa KR sci
myI <- 1:I # pisa KR sci

z1 <- matched$z1
w1 <- matched$w1
z0 <- matched$z0[myN, ]
w0 <- matched$w0[myI, ]

xmin <- min(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymin <- min(z0[, 2], z1[, 2], w0[, 2], w1[, 2])
xmax <- max(z0[, 1], z1[, 1], w0[, 1], w1[, 1])
ymax <- max(z0[, 2], z1[, 2], w0[, 2], w1[, 2])

myname <- c(myN, paste0("I.", myI))
print(lsjmplot(z0, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
if (double_z && !double_w) {
  print(lsjmplot(z1, w0, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (double_z && double_w) {
  print(lsjmplot(z1, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
} else if (!double_z && double_w) {
  print(lsjmplot(z0, w1, xlim = c(xmin, xmax), ylim = c(ymin, ymax), myname))
}
dev.off(which = dev.cur())
#+end_src

[[pdf:figure/CIF_cl1.pdf::1]]
#+begin_src R :tangle R/CIF_cl1.R
## choose a few people adn items from latent space

which_z <- function(w, z) {
  which.min(colSums((t(z) - w)^2))
}

## myN = NULL
## for (i in 1:length(myI)) {
## myN = c(myN, which_z(w0[myI[i],],z0))
## }
## myN = c(myN, which.min(rowSums(z0^2)), which.max(rowSums(z0^2)))

maxt <- sj[G] + 500
num_seg <- 100
time <- seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF_cl1.pdf"))

for (item in myI) {
  CIF_T <- foreach(k = myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

  CIF_F <- foreach(k = myN, .combine = "rbind") %dopar% {
    c(0, cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
  }

  CIF_T <- data.frame(t(CIF_T), c(time))
  colnames(CIF_T) <- c(myN, "time")

  plot_T <- reshape2::melt(CIF_T, id.vars = "time")
  colnames(plot_T) <- c("time", "person", "CIF")

  p <- ggplot(data = plot_T, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ", item, ")."))
  print(p)

  CIF_F <- data.frame(t(CIF_F), c(time))
  colnames(CIF_F) <- c(myN, "time")

  plot_F <- reshape2::melt(CIF_F, id.vars = c("time"))
  colnames(plot_F) <- c("time", "person", "CIF")

  p <- ggplot(data = plot_F, aes(x = time, y = CIF, group = person)) +
    geom_line(aes(color = factor(person)), show.legend = TRUE) +
    ylim(0, 1) +
    ## geom_line(group="3", col="red") +
    ## scale_colour_grey() +
    theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ", item, ")."))
  print(p)
}
dev.off(which = dev.cur())
#+end_src

#+begin_src R :tangle R/CIF_cl1.R
system(paste0("rsync -v figure/CIF_cl1.pdf ", out_dir, "figure/"))
system(paste0("rsync -v figure/latent_space_cl1.pdf ", out_dir, "figure/"))
#+end_src

#+begin_src R
mN = length(myN)
mise = matrix(0,mN,mN)
for (kk in 1:(mN-1)) {
  for (ll in (kk+1):mN) {
    mise[ll,kk] = sum((CIF_T[,kk] - CIF_T[,ll])^2) / maxt
  }
}
#+end_src

#+begin_src R
posm_CIF_T = CIF_T[,-ncol(CIF_T)]
num_iter = min(unlist(lapply(mydf,  nrow)))

mises = foreach(v=1:num_chain, .combine='rbind') %dopar% {
  foreach(nn = seq(1, num_iter, 10), .combine='rbind') %dopar% {
    CIF_T = foreach (k = myN, .combine='cbind') %dopar% {
      c(0,cumcicurve(getparam(unlist(mydf[[v]][nn,]), sj, item, k), 1, 0, maxt, num_seg))
    }
    colSums((posm_CIF_T - CIF_T)^2) / maxt
  }
}
#+end_src

#+begin_src R
apply(mises, 2, median)
#+end_src

#+begin_src R

sam = mydf[[v]][,1:( which( colnames(mydf[[v]]) == "lp_") )]

CIF_T = foreach (k = myN, .combine='rbind') %dopar% {
  c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
}

}
apply(mydf[[v]], 2, mean)
if (num_chain > 1) {
  tmp = tmp[,1:( which( colnames(mydf[[1]]) == "lp_") )]
  posm = apply(tmp, 2, mean)
} else {
  posm = tmp[1:( which( colnames(mydf[[1]]) == "lp_") )]
}

cname = names(posm)
param = getparam(posm,sj,i,k)
#+end_src
** FDA
#+begin_src R
library(fda)
library(funFEM)
##library(fda.usc)
#+end_src

[[file:figure/functionDA.pdf]]
#+begin_src R
tmp = as.matrix(CIF_T)
y = tmp[, -ncol(tmp)]
x = tmp[, ncol(tmp)]

## basis <- create.polygonal.basis(x)
## basis <- create.bspline.basis(c(0, max(x)), nbasis=50, norder=4) #below 0 occurs
basis <- create.bspline.basis(c(0, max(x)), nbasis=10)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=99)
##basis <- create.fourier.basis(c(0, max(x)), nbasis=10)
##basis = create.monomial.basis(c(0, max(x)), nbasis=10)
##basis = create.exponential.basis(c(0, max(x)), nbasis=9) # not work
fdobj <- smooth.basis(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd
##fdobj <- smooth.monotone(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd

pdf("figure/functionDA.pdf")
plot(fdobj)
dev.off(which = dev.cur())
#+end_src

#+begin_src R
kran = 2:2
## res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)
## res = funFEM(fdobj,K=kran,model='AkjBk',crit="icl",init='hclust',lambda=0,disp=TRUE)
res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)

## plot(kran,res$plot$bic,type='b',xlab='K',main='ICL')
#+end_src

[[file:figure/functional-clustering.pdf]]
#+begin_src R
pdf("figure/functional-clustering.pdf")
par(mfrow=c(1,2))
plot(fdobj,col=res$cls,lwd=2,lty=1)
fdmeans = fdobj;
fdmeans$coefs = t(res$prms$my)
plot(fdmeans,col=1:max(res$cls),lwd=2)
dev.off(which = dev.cur())
#+end_src

* WAIT simulation of survival times
:PROPERTIES:
:header-args:R: :tangle R/sim_surv_data.R
:END:
- State "WAIT"       from              [2021-02-19 Fri 03:55] \\
  see if it can be run in another machine
1. get break points for time
2. fix item, get item parameters + piecewise constant rates
3. calculate relative risk for each type (for all persons)
4. simulate survival time -> response
5. repeat for all items (40)
6. repeat for many MCMC samples (10000?)

Run =R/sim_surv_data.R= for the simulation, and find relevant data as
follows:
   #+begin_src R :tangle no
   time = sim_data[[item]][,1:251]
   pp = sim_data[[item]][,252:502]

   mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
   mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()
   #+end_src

- ~iter~: MCMC iteration
- ~time[iter, person]~: simulated survival time t
- ~pp[iter, person]~: simulated conditional probability of correct response given time t
- ~mi[item,person]~: observed response (1: correct, 0: incorrect)
- ~mt[item,person]~: observed time

The =RData= will be saved in =chessB_pn=. To run the simulation with no
distance term, set =out_dir <- "chessB_no_latent/"= in =R/sim_surv_data.R=.

#+begin_src R :results none
## out_dir <- "chessB_pn/"
## out_dir <- "chessB_np/"
out_dir <- "chessB_no_latent/"

## out_dir <- "chessB_pn_ncut2_zero_beta/"
out_dir <- "chessB_no_latent_ncut2_zero_beta/"
## out_dir <- "chessB_np_ncut2_zero_beta/"
## out_dir <- "chessB_no_latent_ncut2_zero_beta/"
out_dir <- "chessB_swdz_pp_ncut5_zero_beta/"
## out_dir <- "chessB_double_pp_ncut2_zero_beta/"

out_dir <- "chessB_double_nn_ncut5_zero_beta_noinfo_lc2/"
out_dir <- "chessB_double_pp_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_nn_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_pn_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_pp_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_swdz_nn_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_swdz_pp_ncut5_zero_beta_noinfo_lc2/"
## out_dir <- "chessB_no_latent_ncut5_zero_beta_noinfo_lc2/"
out_dir = "chessB_np_ncut5_zero_beta_noinfo_lc2/"
out_dir="chessB_np_ncut5_zero_beta_noinfo_lc2/"

num_chain <- 2
HAS_REF <- 0

source("R/Renviron.R")
source("R/load-outputs.R")
#+end_src

#+begin_src R :results none :tangle R/wrap_param.R
mi <- readr::read_csv(file = paste0(out_dir, "mi.csv"), col_names = F) %>% as.matrix()
mt <- readr::read_csv(file = paste0(out_dir, "mt.csv"), col_names = F) %>% as.matrix()
mseg <- readr::read_csv(file = paste0(out_dir, "mseg.csv"), col_names = F) %>% as.matrix()
mh <- readr::read_csv(file = paste0(out_dir, "mh.csv"), col_names = F) %>% as.matrix()

sam = NULL
vv = 1
while (vv <= num_chain) {
sam <- rbind(sam, mylist[[vv]])
vv = vv + 1
}

## distance calculation can be fully vectorized (and storing z), but I don't have time for this.
z <- sam[, stringr::str_which(cname, paste0("^z\\.[0-1]\\."))] %>% as.matrix()
w <- sam[, stringr::str_which(cname, paste0("^w\\.[0-1]\\."))] %>% as.matrix()
## beta <- sam[, stringr::str_which(cname, paste0("^beta\\.", item, "\\."))]

## correction for single z or w
if (ncol(z) < 2 * 2 * N) z <- cbind(z, z)
if (ncol(w) < 2 * 2 * I) w <- cbind(w, w)

theta <- sam[, stringr::str_which(cname, paste0("^theta\\."))] %>% as.matrix() ## (theta.k.0 theta.k.1)
gamma <- sam[, stringr::str_which(cname, paste0("gamma\\."))] %>% as.matrix()

lambda <- sam[, stringr::str_which(cname, paste0("^lambda\\.[0-1]\\."))] %>% as.matrix()

param <- list(I = as.integer(I), N = as.integer(N), G = as.integer(G), seg = as.matrix(mseg), H = as.matrix(mh), len = as.integer(diff(sj)), sj = as.numeric(sj), Y = mi)
#+end_src

#+begin_src R :tangle R/art-functions.R
eval_DIC = function(lambda, theta, z, w, gamma, param) {
  mlambda = rbind(apply(lambda,2,mean), lambda)
  mtheta = rbind(apply(theta,2,mean), theta)
  mz = rbind(apply(z,2,mean), z)
  mw = rbind(apply(w,2,mean), w)
  mgamma = rbind(apply(gamma,2,mean), gamma)

  mloglike = art::get_loglike(mlambda, mtheta, mz, mw, mgamma, param)
  ll = mloglike[2:length(mloglike)]
  pd2 = 0.5 * var(-2*ll)
  pd1 = mean(-2*ll) - (-2 * mloglike[1])
  DIC2 = -2*mloglike[1] + 2*pd2
  DIC1 = -2*mloglike[1] + 2*pd1
  return(list(loglike=ll, DIC1=DIC1, DIC2 = DIC2))
}
#+end_src

#+RESULTS:

#+begin_src R :tangle R/art-functions.R
gethaz_item <- function(sam, cname, item, N, double_w, double_z) {
  num_iter <- nrow(sam)
  d_zw <- list()
  d_zw[[1]] = d_zw[[2]] = matrix(0, num_iter, N)

  for (k in 1:N) {
    ## distance calculation can be fully vectorized (and storing z), but I don't have time for this.
    z <- sam[, stringr::str_which(cname, paste0("^z\\.", 0, "\\.", k, "\\.[1-2]"))]
    w <- sam[, stringr::str_which(cname, paste0("^w\\.", 0, "\\.", item, "\\."))]
    d_zw[[1]][, k] <- sqrt(rowSums((z - w)^2))
  }
  if (!double_w & !double_z){
  d_zw[[2]] = d_zw[[1]]
} else if (double_w & double_z) {
  for (k in 1:N) {
    ## distance calculation can be fully vectorized (and storing z), but I don't have time for this.
    z <- sam[, stringr::str_which(cname, paste0("^z\\.", 1, "\\.", k, "\\.[1-2]"))]
    w <- sam[, stringr::str_which(cname, paste0("^w\\.", 1, "\\.", item, "\\."))]
    d_zw[[2]][, k] <- sqrt(rowSums((z - w)^2))
  }
} else if (!double_w & double_z) {
  for (k in 1:N) {
    ## distance calculation can be fully vectorized (and storing z), but I don't have time for this.
    z <- sam[, stringr::str_which(cname, paste0("^z\\.", 1, "\\.", k, "\\.[1-2]"))]
    w <- sam[, stringr::str_which(cname, paste0("^w\\.", 0, "\\.", item, "\\."))]
    d_zw[[2]][, k] <- sqrt(rowSums((z - w)^2))
  }
}

beta <- sam[, stringr::str_which(cname, paste0("^beta\\.", item, "\\."))]

theta_temp <- sam[, stringr::str_which(cname, paste0("^theta\\."))] ## (theta.k.0 theta.k.1)
teq <- seq(1, ncol(theta_temp), 2)
gamma <- theta <- lambda <- rr <- log_rr <- list()
theta[[1]] <- theta_temp[, teq]
theta[[2]] <- theta_temp[, -teq]

gamma <- sam[, stringr::str_which(cname, paste0("gamma\\."))]

lambda_temp <- sam[, stringr::str_which(cname, paste0("^lambda\\.[0-1]\\.", item, "\\."))]
leq <- 1:(ncol(lambda_temp)/2)
lambda[[1]] <- lambda_temp[, leq]
lambda[[2]] <- lambda_temp[, -leq]

for (cc in 1:2) {
 log_rr[[cc]] <- beta[, cc] + theta[[cc]] - gamma[,cc] * d_zw[[cc]]
 rr[[cc]] <- exp(log_rr[[cc]])
}

res <- list(lambda = lambda, rr = rr, log_rr = log_rr,  theta = theta)
return(res)
}
#+end_src

#+RESULTS:

#+begin_src R :tangle R/art-functions.R
gen_surv_time <- function(out, sj, N, nn) {
  rr <- out$rr
  lambda <- out$lambda
  mj <- length(sj)
  len = diff(sj)

  haz <- lambda[[1]][nn, ] %o% rr[[1]][nn, ] + lambda[[2]][nn, ] %o% rr[[2]][nn, ]
  logS <- -rexp(N)
  ## logS <- -rep(1,N)
  cumhaz <- rbind(rep(0, N), apply(haz * len, 2, cumsum))
  vtime <- numeric(N)

  ## cat(cumhaz[, 1],"\n")
  ## cat(-logS[1],"\n")

  for (kk in 1:N) {
    ss <- findInterval(-logS[kk], cumhaz[, kk])
    if (ss != mj) {
      vtime[kk] <- sj[ss] - (logS[kk] + cumhaz[ss, kk]) / haz[ss, kk]
    } else {
      vtime[kk] <- sj[ss]
    }
  }
  return(vtime)
}
#+end_src

#+RESULTS:

#+begin_src R :tangle R/art-functions.R
gen_surv_pp <- function(out, time, sj) {
  rr <- out$rr
  lambda <- out$lambda
  num_iter <- nrow(time)
  hr <- list()
  seg_g <- findInterval(time, sj)
  mg <- length(sj)
  seg_g[seg_g == mg] <- (mg - 1)

  ## m is the number of rows in the matrix, r and c are row and column numbers respectively, and ind the linear index:
  ## ind = (c-1)*m + r
  ind <- (seg_g - 1) * num_iter + 1:num_iter

  for (cc in 1:2) hr[[cc]] <- lambda[[cc]][ind] * c(rr[[cc]])

  pp <- hr[[2]] / (hr[[1]] + hr[[2]])

  return(pp)
}
#+end_src

#+RESULTS:

#+begin_src R
## see get_hazitem() for "out"
chain = 1
sam = mylist[[chain]][seq(1, nrow(mylist[[chain]]), 50), ]
num_iter = nrow(sam)

mloglike = foreach(ii = 1:I, .combine="cbind") %dopar% {
out <- gethaz_item(sam, cname, ii, N, double_w, double_z)

seg_i = unlist(mseg[ii,])
H_i = mh[ii,]

resp_i = mi[ii,]
time_i = mt[ii,]

get_ll(out, resp_i, time_i, sj, H_i, seg_i, loglike = NULL)
}

loglike = rowSums(mloglike)

#+end_src

#+RESULTS:

#+begin_src R :tangle R/art-functions.R
## log-likelihood, native R, use get_loglike() instead.
get_ll <- function(out, resp_i, time_i, sj, H_i, seg_i, loglike = NULL) {

  rr = out$rr
  log_rr = out$log_rr
  lambda = out$lambda

  num_iter = nrow(rr[[1]])
  loglike = numeric(num_iter)

  slam = hlam = list()

  for (cc in 1:2) {

  hlam[[cc]] = t( t(lambda[[cc]]) * mlen)
  slam[[cc]] = rbind(0, apply(hlam[[cc]],  1,  cumsum))

  for (nn in 1:num_iter) {
    loglike[nn] = loglike[nn] - sum((slam[[cc]][(seg_i+1), nn] + H_i * lambda[[cc]][nn, (seg_i+1)]) * rr[[cc]][nn, ]) + sum((log(lambda[[cc]][nn, (seg_i+1)]) + log_rr[[cc]][nn, ])[resp_i == (cc - 1)] ) # log(S(t)) + log(h(t)) for event cc
  }
}
return(loglike)
  }
#+end_src

#+RESULTS:

#+begin_src R
set.seed(1)
num_iter <- nrow(mylist[[1]])
sim_data <- list()
len = diff(sj)
num_chain = 1

for (ii in 1:I) {
  start_time <- proc.time()
  stk_tt <- foreach(chain = 1:num_chain, .combine = "rbind") %dopar% {
    out <- gethaz_item(mylist[[chain]], cname, ii, N, double_w, double_z)
    time <- foreach(nn = 1:num_iter, .combine = "rbind") %do% {
      gen_surv_time(out, sj,N, nn)
    }
    pp <- gen_surv_pp(out, time, sj) %>% array(dim = dim(time))
    cbind(time, pp)
  }
  sim_data[[ii]] <- stk_tt
  cat("\nelapsed time to simulate item", ii, "\n")
  print(proc.time() - start_time)
}

save(sim_data, file = paste0(out_dir, "surv_sim.RData"))
#+end_src

#+begin_src R :tangle R/art-functions.R
## calculate baseline hazard and hazard ratio
## slow iteration
haz_fun_item <- function(sam, sj, item, N) {
  rel <- NULL
  for (k in 1:N) {
    param <- getparam(sam, sj, item, k)
    dist <- sqrt(rowSums((param$z - param$w)^2))
    rr <- exp(param$beta + param$theta - param$gamma * dist)
    rel <- rbind(rel, rr)
  }
  haz <- matrix(c(sj, 0, param$lambda[1, ], 0, param$lambda[2, ]), length(sj), 3)
  return(list(haz = haz, rel = rel))
}
#+end_src

#+begin_src R :tangle R/art-functions.R
## simulate survival time and response
## slow
gen_surv <- function(out, sj, N) {
  time <- numeric(N)
  for (k in 1:N) {
    hh <- cbind(sj, out$haz[, 2] * out$rel[k, 1] + out$haz[, 3] * out$rel[k, 2])
    time[k] <- timereg::rchaz(hh, n = 1, cum.hazard = FALSE)[, 2]
  }

  dd <- data.frame(time = time, status = rep(1, N))
  seg_temp <- survSplit(formula = Surv(time, status) ~ 1, cut = sj, data = dd, episode = "seg_g")
  seg_g <- seg_temp %>%
    filter(status == 1) %>%
    select(seg_g) %>%
    unlist()

  rr12 <- out$haz[seg_g, 2:3] * out$rel
  pp <- rr12[, 2] / rowSums(rr12)
  return(list(time = time, pp = pp))
}
#+end_src

#+RESULTS:

#+begin_src R :tangle no
mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()

for (item in 1:I){
time = sim_data[[item]][,1:251]
aa = mt[item,]
ss = 0
for (kk in 1:N) {
  ## print(sum(time[,kk] > aa[k]) / length(time[,kk]))
  ss = ss + sum(time[,kk] > aa[k]) / length(time[,kk])
  }
print(ss/N)
}
#+end_src

#+begin_src R :tangle no
## simluate survival time and competing events for all items and chains
## slow
sim_data <- list()
num_iter <- nrow(mylist[[1]])
for (item in 1:I) {
start_time <- proc.time()
stk_tt <-  foreach(chain = 1:3, .combine='cbind') %dopar% {
  foreach(ii=1:num_iter, .combine='cbind') %dopar% {
    out <- haz_fun_item(mylist[[chain]][ii,], sj, item, N)
    sim <- gen_surv(out, sj, N)
    cbind(sim$time,sim$pp)
  }
}
row.names(stk_tt) <- 1:N
sim_data[[item]] <- stk_tt
cat("\nelapsed time to simulate item",item,"\n")
print(proc.time() - start_time)
}
#+end_src

* posterior checking
Rcpp probability distribution: https://teuder.github.io/rcpp4everyone_en/220_dpqr_functions.html
to test my code
1. Use the observed response time. See if the latent model has higher hazard for the true response on average. If not, possible errors in hazard calculation...
conclusion: =chessB_pn= works poor. =chessB_np= works a bit ok.

** with *no* time simulation
#+begin_src R :results none
## out_dir <- "chessB_pn/"
## out_dir <- "chessB_no_latent/"
## out_dir <- "chessB_np/"

## out_dir <- "chessB_pn_ncut2_zero_beta/"
out_dir <- "chessB_no_latent_ncut2_zero_beta/"
## out_dir <- "chessB_np_ncut2_zero_beta/"
## out_dir <- "chessB_no_latent_ncut2_zero_beta/"
out_dir <- "chessB_swdz_pp_ncut2_zero_beta/"
out_dir <- "chessB_swdz_nn_ncut2_zero_beta/"
## out_dir <- "chessB_double_pp_ncut2_zero_beta/"
## out_dir <- "chessB_double_nn_ncut2_zero_beta/"
## out_dir="chessB_pp_ncut2_zero_beta_noinfo_lc2/"
out_dir="chessB_no_latent_ncut5_zero_beta_noinfo_lc2/"
## out_dir="chessB_nn_ncut2_zero_beta_noinfo_lc2/"
## out_dir="chessB_nn_ncut5_zero_beta_noinfo_lc2/"
out_dir="chessB_pn_ncut5_zero_beta_noinfo_lc2/"

num_chain <- 1
HAS_REF <- 0
#+end_src

#+begin_src R :results none :tangle R/test_simcode.R
source("R/Renviron.R")

mt = readr::read_csv(file="chessB_pn/input/mt.csv", col_names=F) %>% as.matrix()
mi = readr::read_csv(file="chessB_pn/input/mi.csv", col_names=F) %>% as.matrix()

system(paste0("rm figure/*.pdf"))

source("R/load-outputs.R")
source("R/visual-latent-space-plot.R")

system(paste0("mkdir -p ", out_dir, "figure/"))
system(paste0("rsync -rv figure/*.pdf ", out_dir, "figure/"))
## save(mylist, file = paste0(out_dir,"mylist"))
#+end_src

#+begin_src R :results none :tangle R/test_simcode.R
source("R/wrap_param.R")

set.seed(1)
num_iter <- nrow(mylist[[1]])
sim_data <- list()
mll  <- mauc <- matrix(0, num_iter, I)

for (ii in 1:I) {
  start_time <- proc.time()
  ## stk_tt <- foreach(chain = 1:1, .combine = "rbind") %do% {
    ## out <- gethaz_item(mylist[[chain]], cname, ii, N, double_w, double_z)
    ## time <- matrix(mt[ii, ], nrow = num_iter, ncol = N, byrow=T)
    ## pp <- gen_surv_pp(out, time, sj) %>% array(dim = dim(time))
    pp <- art::rcpp_gen_surv_pp(lambda, theta, z, w, gamma, param, ii)
    ## cbind(time, pp)

  for (nn in 1:num_iter) {
    mll[nn, ii] = MLmetrics::LogLoss(pp[nn, ], mi[ii, ])
    mauc[nn, ii] = MLmetrics::AUC(pp[nn, ], mi[ii, ])
    }

  ## }
  ## sim_data[[item]] <- stk_tt
  cat("\nelapsed time to simulate item", ii, "\n")
  print(proc.time() - start_time)
}

mm = eval_DIC(lambda, theta, z, w, gamma, param)
mlike=mm$loglike
mmet = list(mll=mll,mauc=mauc,mlike=mm$loglike)
## save(mmet, file = paste0(out_dir,"mll_auc.RData"))
#+end_src

#+begin_src R :tangle R/test_simcode.R
dll = t(mll)
dauc = t(mauc)
colnames(mauc) = colnames(mll) = row.names(mi) = 1:I
## row.names(dauc) = row.names(dll) = colnames(mi) = 1:num_iter
dauc = reshape2::melt(mauc)
dll <- reshape2::melt(mll)
## mi_long <- reshape2::melt(t(mi))
dd = plyr::join(dll, dauc, by = c("Var1","Var2"))
names(dd) = c("iter","item","LogLoss","AUC")

save(dd, file = paste0(out_dir,"dll_auc.RData"))

ll_boxp <- ggplot(dd, aes(x=item,y=LogLoss,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(0, 1)

auc_boxp <- ggplot(dd, aes(x=item,y=AUC,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(0, 1)

llike_boxp <- ggplot(data.frame(LogLike = mlike), aes(y=LogLike)) + geom_boxplot() + theme(legend.position = "none") + ggtitle(concat_summary(mlike,0)) + theme(plot.title = element_text(size=10))

pdf(paste0(out_dir,"figure/cmetrics.pdf"))
print(ll_boxp)
print(auc_boxp)
print(llike_boxp)
dev.off()
#+end_src

#+begin_src R :tangle R/test_simcode.R
sink(paste0(out_dir,"analysis-output.txt"))

cat("=============================\n")
cat("log-likelihood\n")
cat("=============================\n")
summary(mlike)

cat("=============================\n")
cat("DIC\n")
cat("=============================\n")
cat("DIC1, DIC2\n")
cat(paste0(round(mm$DIC1,2),","),round(mm$DIC2,2),"\n")

sink()
#+end_src

#+RESULTS:
: pdf
:   3

#+begin_src R :tangle R/art-functions.R
## concat summary results to one line string
concat_summary = function(obj, d) {
  res = NULL
  summ = round(summary(obj),d)
  for (k in 1:6) {
    res = paste0(res, names(summ)[k],": ",summ[k], " ")
  }
  return(res)
 }
#+end_src

#+RESULTS:

#+begin_src R :results none :tangle R/diff_metrics.R
out_dir="chessB_no_latent_ncut5_zero_beta_noinfo_lc2/"
## out_dir="chessB_nn_ncut2_zero_beta_noinfo_lc2/"

num_chain <- 1
HAS_REF <- 0
source("R/test_simcode.R")

## fname = paste0(out_dir,"dll_auc.RData")
## if (file.exists(fname)) load(file = fname) else source("R/test_simcode.R")

ddd = dd # baseline to ddd

lout = NULL
lout=c(lout,"chessB_double_pp_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_double_nn_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_double_np_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_double_pn_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_np_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_pn_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_pp_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_nn_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_swdz_nn_ncut5_zero_beta_noinfo_lc2/")
lout=c(lout,"chessB_swdz_pp_ncut5_zero_beta_noinfo_lc2/")

## fname = paste0(out_dir,"dll_auc.RData")
## if (file.exists(fname)) load(file = fname) else source("R/test_simcode.R")

num_chain <- 1
HAS_REF <- 0

for (out_dir in lout) {

source("R/test_simcode.R")
ddd$dLogLoss = ddd$LogLoss - dd$LogLoss
ddd$dAUC = ddd$AUC - dd$AUC

## logloss (smaller, better)
ll_boxp <- ggplot(ddd, aes(x=item,y=dLogLoss,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(-0.25, 0.25)

## AUC (larger, better)
auc_boxp <- ggplot(ddd, aes(x=item,y=dAUC,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(-0.25, 0.25)

pdf(paste0(out_dir,"dmetrics.pdf"))
print(ll_boxp)
print(auc_boxp)
dev.off()

cat("Plot(s) are saved in",out_dir,"\n")
cat("=================================\n")

sink("loglikelihood.txt", append=TRUE)
cat(out_dir,"\n")
summary(mlike)
cat("=============================\n")

sink()

sink("DIC.txt", append=TRUE)
cat("out_dir, DIC1, DIC2\n")
cat(paste0(out_dir,","),paste0(round(mm$DIC1,2),","),round(mm$DIC2,2),"\n")

sink()
}
#+end_src

[[pdf:LogLoss_diff.pdf::1]]
[[pdf:LogLoss_diff_by.pdf::1]]
#+begin_src R
fname = "mll.RData"
pname = "LogLoss_diff_by.pdf"
lout = c("chessB_np/", "chessB_no_latent/", "chessB_pn/")
#+end_src

#+begin_src R :tangle R/draw_logloss_diff_by.R
row.names(mi) = 1:I
colnames(mi) = 1:N
d_long <- reshape2::melt(t(mi))

### lout: list of output directory

for (out_dir in lout) {
load(paste0(out_dir,fname))
dll = t(mll)
colnames(dll) = 1:I
row.names(dll) = 1:N
d_add <- reshape2::melt(dll)
d_long = plyr::join(d_long, d_add, by = c("Var1","Var2"))
}

names(d_long) = c("person","item","res", "LogLoss_np", "LogLoss_no", "LogLoss_pn")
d_long$LogLoss_diff_np = d_long$LogLoss_no - d_long$LogLoss_np
d_long$LogLoss_diff_pn = d_long$LogLoss_no - d_long$LogLoss_pn
d_long$res = factor(d_long$res, labels=c("incorrect","correct"))

ll_boxp_np_by <- ggplot(d_long, aes(x=item,y=LogLoss_diff_np,fill=factor(item))) + facet_wrap(~res) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - M1 log loss")+
  ylab("Difference in LogLoss")

ll_boxp_pn_by <- ggplot(d_long, aes(x=item,y=LogLoss_diff_pn,fill=factor(item))) + facet_wrap(~res) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - M2 log loss") +
    ylab("Difference in LogLoss")

ll_boxp_np <- ggplot(d_long, aes(x=item,y=LogLoss_diff_np,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - M1 log loss")+
  ylab("Difference in LogLoss")

ll_boxp_pn <- ggplot(d_long, aes(x=item,y=LogLoss_diff_pn,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ggtitle("baseline - M2 log loss") +
    ylab("Difference in LogLoss")

pdf(pname)
print(ll_boxp_np_by)
print(ll_boxp_pn_by)
print(ll_boxp_np)
print(ll_boxp_pn)
dev.off()
#+end_src

#+begin_src R
out_dir = "chessB_np/"

dd_se = function(x) sd(x) / sqrt(N)
dd = d_long %>% group_by(item)
dif = dd %>% summarise_at(vars(LogLoss_diff_pn, LogLoss_diff_np),list(mean = mean, se = dd_se ))
prin = dif[,c(1,2,4,3,5)]
names(prin) = c("item", "pos_neg", "se_pn", "neg_pos",  "se_np")
round(prin,3) %>% knitr::kable()
readr::write_csv(prin, file = paste0(out_dir, "logloss_diff.csv"))
#+end_src

#+RESULTS:
#+begin_example


| item| pos_neg| se_pn| neg_pos| se_np|
|----:|-------:|-----:|-------:|-----:|
|    1|  -0.935| 0.039|   0.692| 0.041|
|    2|  -0.944| 0.038|   0.636| 0.040|
|    3|  -0.892| 0.040|   0.460| 0.040|
|    4|  -0.938| 0.038|   0.511| 0.040|
|    5|  -0.919| 0.039|   0.540| 0.040|
|    6|  -0.882| 0.040|   0.326| 0.038|
|    7|  -0.888| 0.039|   0.331| 0.037|
|    8|  -0.854| 0.041|   0.221| 0.035|
|    9|  -0.613| 0.045|   0.059| 0.029|
|   10|  -0.771| 0.043|   0.350| 0.040|
|   11|  -0.747| 0.043|   0.089| 0.031|
|   12|  -0.606| 0.045|   0.034| 0.026|
|   13|  -0.659| 0.043|   0.165| 0.033|
|   14|  -0.593| 0.045|   0.049| 0.028|
|   15|  -0.814| 0.042|   0.178| 0.033|
|   16|  -0.328| 0.043|  -0.013| 0.024|
|   17|  -0.413| 0.045|   0.118| 0.032|
|   18|  -0.289| 0.042|   0.120| 0.031|
|   19|  -0.412| 0.044|   0.087| 0.029|
|   20|  -0.100| 0.038|   0.048| 0.028|
|   21|  -0.942| 0.038|   0.575| 0.039|
|   22|  -0.838| 0.041|   0.374| 0.038|
|   23|  -0.800| 0.041|   0.349| 0.038|
|   24|  -0.320| 0.043|   0.021| 0.026|
|   25|  -0.768| 0.041|   0.331| 0.038|
|   26|  -0.316| 0.044|  -0.017| 0.023|
|   27|  -0.066| 0.033|   0.026| 0.025|
|   28|  -0.267| 0.044|   0.095| 0.030|
|   29|  -0.501| 0.044|   0.096| 0.031|
|   30|  -0.046| 0.033|   0.137| 0.032|
|   31|  -0.955| 0.038|   0.711| 0.041|
|   32|  -0.933| 0.038|   0.643| 0.040|
|   33|  -0.920| 0.039|   0.432| 0.039|
|   34|  -0.425| 0.044|  -0.009| 0.024|
|   35|  -0.510| 0.043|   0.065| 0.028|
|   36|  -0.473| 0.043|   0.100| 0.030|
|   37|  -0.135| 0.038|   0.008| 0.025|
|   38|  -0.257| 0.040|  -0.005| 0.024|
|   39|  -0.383| 0.044|   0.043| 0.027|
|   40|  -0.125| 0.037|   0.167| 0.033|
#+end_example

#+begin_src R
dd = d_long %>% group_by(item,res)
dif = dd %>% summarise_at(vars(LogLoss_diff_pn, LogLoss_diff_np),list(mean = mean, se = dd_se ))
prin_by = dif[,c(1,2,3,5,4,6)]
names(prin_by) = c("item", "res", "pos_neg", "se_pn", "neg_pos",  "se_np")
cbind(prin_by[,2], round(prin_by[,-2],3)) %>% knitr::kable()

readr::write_csv(prin_by, file = paste0(out_dir, "logloss_diff_by.csv"))
#+end_src

#+RESULTS:
#+begin_example


|res       | item| pos_neg| se_pn| neg_pos| se_np|
|:---------|----:|-------:|-----:|-------:|-----:|
|incorrect |    1|  -0.083| 0.014|  -0.126| 0.018|
|correct   |    1|  -0.970| 0.038|   0.726| 0.041|
|incorrect |    2|  -0.146| 0.019|  -0.318| 0.034|
|correct   |    2|  -0.995| 0.037|   0.696| 0.037|
|incorrect |    3|  -0.164| 0.015|  -0.270| 0.026|
|correct   |    3|  -1.051| 0.037|   0.620| 0.035|
|incorrect |    4|  -0.237| 0.009|  -0.398| 0.024|
|correct   |    4|  -1.033| 0.037|   0.634| 0.035|
|incorrect |    5|  -0.178| 0.016|  -0.332| 0.025|
|correct   |    5|  -1.012| 0.037|   0.650| 0.036|
|incorrect |    6|  -0.203| 0.010|  -0.318| 0.024|
|correct   |    6|  -1.109| 0.035|   0.542| 0.031|
|incorrect |    7|  -0.200| 0.013|  -0.324| 0.027|
|correct   |    7|  -1.109| 0.034|   0.541| 0.029|
|incorrect |    8|  -0.208| 0.012|  -0.292| 0.023|
|correct   |    8|  -1.174| 0.034|   0.474| 0.029|
|incorrect |    9|  -0.107| 0.016|  -0.149| 0.023|
|correct   |    9|  -1.317| 0.033|   0.348| 0.026|
|incorrect |   10|  -0.113| 0.016|  -0.161| 0.024|
|correct   |   10|  -1.078| 0.038|   0.589| 0.036|
|incorrect |   11|  -0.167| 0.014|  -0.221| 0.022|
|correct   |   11|  -1.278| 0.033|   0.372| 0.027|
|incorrect |   12|  -0.106| 0.018|  -0.154| 0.025|
|correct   |   12|  -1.325| 0.032|   0.305| 0.018|
|incorrect |   13|  -0.100| 0.018|  -0.155| 0.026|
|correct   |   13|  -1.170| 0.034|   0.458| 0.026|
|incorrect |   14|  -0.097| 0.016|  -0.143| 0.024|
|correct   |   14|  -1.329| 0.033|   0.335| 0.022|
|incorrect |   15|  -0.179| 0.014|  -0.253| 0.024|
|correct   |   15|  -1.208| 0.034|   0.444| 0.025|
|incorrect |   16|  -0.030| 0.019|  -0.065| 0.024|
|correct   |   16|  -1.466| 0.032|   0.184| 0.016|
|incorrect |   17|  -0.018| 0.020|  -0.055| 0.025|
|correct   |   17|  -1.198| 0.042|   0.461| 0.032|
|incorrect |   18|   0.015| 0.021|  -0.019| 0.025|
|correct   |   18|  -1.106| 0.040|   0.495| 0.034|
|incorrect |   19|  -0.012| 0.023|  -0.067| 0.027|
|correct   |   19|  -1.223| 0.030|   0.401| 0.023|
|incorrect |   20|   0.036| 0.021|   0.013| 0.024|
|correct   |   20|  -1.444| 0.058|   0.395| 0.051|
|incorrect |   21|  -0.193| 0.011|  -0.401| 0.032|
|correct   |   21|  -1.010| 0.036|   0.664| 0.035|
|incorrect |   22|  -0.132| 0.016|  -0.231| 0.030|
|correct   |   22|  -1.079| 0.035|   0.581| 0.031|
|incorrect |   23|  -0.114| 0.019|  -0.205| 0.029|
|correct   |   23|  -1.081| 0.033|   0.576| 0.031|
|incorrect |   24|  -0.020| 0.019|  -0.055| 0.025|
|correct   |   24|  -1.341| 0.036|   0.278| 0.023|
|incorrect |   25|  -0.105| 0.019|  -0.185| 0.026|
|correct   |   25|  -1.079| 0.033|   0.573| 0.033|
|incorrect |   26|  -0.029| 0.018|  -0.060| 0.024|
|correct   |   26|  -1.499| 0.037|   0.161| 0.016|
|incorrect |   27|   0.043| 0.022|   0.009| 0.026|
|correct   |   27|  -1.326| 0.029|   0.217| 0.021|
|incorrect |   28|   0.026| 0.023|  -0.013| 0.026|
|correct   |   28|  -1.242| 0.040|   0.456| 0.033|
|incorrect |   29|  -0.055| 0.019|  -0.096| 0.025|
|correct   |   29|  -1.233| 0.031|   0.412| 0.030|
|incorrect |   30|   0.076| 0.023|   0.045| 0.025|
|correct   |   30|  -0.907| 0.044|   0.786| 0.045|
|incorrect |   31|  -0.141| 0.006|  -0.259| 0.017|
|correct   |   31|  -0.969| 0.038|   0.727| 0.040|
|incorrect |   32|  -0.064| 0.021|  -0.249| 0.038|
|correct   |   32|  -0.989| 0.036|   0.700| 0.037|
|incorrect |   33|  -0.218| 0.013|  -0.352| 0.025|
|correct   |   33|  -1.065| 0.036|   0.594| 0.033|
|incorrect |   34|  -0.057| 0.018|  -0.094| 0.024|
|correct   |   34|  -1.414| 0.032|   0.221| 0.016|
|incorrect |   35|  -0.062| 0.019|  -0.113| 0.025|
|correct   |   35|  -1.247| 0.029|   0.359| 0.022|
|incorrect |   36|  -0.037| 0.020|  -0.089| 0.026|
|correct   |   36|  -1.201| 0.030|   0.415| 0.025|
|incorrect |   37|   0.022| 0.020|  -0.007| 0.025|
|correct   |   37|  -1.552| 0.045|   0.146| 0.021|
|incorrect |   38|  -0.012| 0.020|  -0.045| 0.025|
|correct   |   38|  -1.413| 0.024|   0.183| 0.014|
|incorrect |   39|  -0.028| 0.020|  -0.066| 0.025|
|correct   |   39|  -1.318| 0.035|   0.331| 0.024|
|incorrect |   40|   0.072| 0.023|   0.038| 0.026|
|correct   |   40|  -0.961| 0.041|   0.712| 0.039|
#+end_example


*** [2021-03-01 Mon] histogram of simulated survival time (correct vs incorrect)

[[pdf:chessB_np/hist_time.pdf::1]]
[[pdf:chessB_pn/hist_time.pdf::1]]
[[pdf:chessB_no_latent/hist_time.pdf::1]]
#+begin_src R
out_dir = "chessB_no_latent/"
out_dir = "chessB_np/"
out_dir = "chessB_pn/"

load(paste0(out_dir, "surv_sim.RData"))

pdf(paste0(out_dir,"hist_time.pdf"))
for (i in 1:I) {
 time = sim_data[[i]][, 1:251]
 time_cor = time[,mi[i,] == 1]
 time_incor = time[,mi[i,] == 0]
 par(mfrow = c(1,2))
 hist(time_cor,main=paste0("correct_item",i))
 hist(time_incor,main=paste0("incorrect_item",i))
 }
dev.off()
#+end_src

#+RESULTS:
: null device
:           1

*** TODO found discrepancy b/w log-likelihood. see if the diffence is consistent
#+begin_src R
num_iter <- nrow(mylist[[1]])
ll <- rep(0, num_iter)
for (nn in 1:3) {
  for (item in 1:I) {
    for (k in 1:N) {
      ll[nn] <- ll[nn] + eval_log_like(getparam(mylist[[1]][nn, ], sj, item, k), mi[item, k], mt[item, k])
    }
  }
}

#+end_src

#+RESULTS:

#+begin_src R
mylist[[1]][1:5,"lp_"] %>% diff()
ll[1:5] %>% diff()
#+end_src

#+RESULTS:
: [1]  31.5 -57.8  62.9 -21.5
: [1]    22.80881   -30.98535 33521.58194     0.00000
** with simulated time
#+begin_src R :results none
## out_dir = "chessb_np/"
## out_dir = "chessb_pn/"
## out_dir = "chessb_no_latent/"

lout = c("chessb_np/", "chessb_pn/", "chessb_no_latent/")

lout = c("chessB_pn_ncut2_zero_beta/", "chessB_no_latent_ncut2_zero_beta/", "chessB_np_ncut2_zero_beta/","chessB_swdz_pp_ncut2_zero_beta/", "chessB_double_pp_ncut2_zero_beta/",
"chessB_swdz_nn_ncut2_zero_beta/", "chessB_double_nn_ncut2_zero_beta/")

mi = as.matrix(mi)

for (out_dir in lout) {

## log loss using simulated time
mll  <- mauc <- matrix(0, num_iter, I)

load(paste0(out_dir, "surv_sim.RData"))

for (ii in 1:I) {
  pp = sim_data[[ii]][, (N+1): (2*N)]
  for (nn in 1:num_iter) {
    mll[nn, ii] = MLmetrics::LogLoss(pp[nn, ], mi[ii, ])
    mauc[nn, ii] = MLmetrics::AUC(pp[nn, ], mi[ii, ])
    }
  }

save(mll,file = paste0(out_dir,"simll.RData"))
  }
#+end_src

#+begin_src R
fname = "simll.RData"
pname = "single_logloss_diff_by.pdf"

lout = c("chessB_pn_ncut2_zero_beta/", "chessB_no_latent_ncut2_zero_beta/", "chessB_np_ncut2_zero_beta/")

source("R/draw_logloss_diff_by.R")

pname = "half_single_logloss_diff_by.pdf"
lout = c("chessB_swdz_nn_ncut2_zero_beta/", "chessB_no_latent_ncut2_zero_beta/", "chessB_double_pp_ncut2_zero_beta/")

source("R/draw_logloss_diff_by.R")

pname = "double_logloss_diff_by.pdf"
lout = c("chessB_double_nn_ncut2_zero_beta/", "chessB_no_latent_ncut2_zero_beta/", "chessB_double_pp_ncut2_zero_beta/")

source("R/draw_logloss_diff_by.R")
#+end_src

#+RESULTS:

** with simulated time Rcpp
Upon setting the output directory containing MCMC sample, ~R/postcheck.R~
 simulates posterior predictive samples for each item in a form of a ~L~ by ~2 * N~ matrix where ~L~ is a sample size and ~2 * N~ is a number of subjects. The first ~N~ columns are for simulated response time, and the second half is for simulated response. These matrices are stored in  a list object ~sim_data~.

#+begin_src R :results none :tangle R/postcheck_ex.R :noweb no-export :comments none
out_dir = "chessB_pn_ncut5_zero_beta_noinfo_lc2/"
out_dir = "duolingo_pn_ncut5_zero_beta_noinfo_lc2/"
num_chain = 1; HAS_REF = 0

## simulating samples
<<gen_postpred>>

## visualizing performance metrics
<<viz_postpred_metric>>
#+end_src

#+begin_src R
set.seed(1)
num_iter <- nrow(mylist[[1]])
sim_data1 <- list()
len = diff(sj)
num_chain = 1
mll1  <- mauc1<- matrix(0, num_iter, I)

for (ii in 1:I) {
  start_time <- proc.time()
  stk_tt <- foreach(chain = 1:num_chain, .combine = "rbind") %do% {
    out <- gethaz_item(mylist[[chain]], cname, ii, N, double_w, double_z)
    time <- foreach(nn = 1:num_iter, .combine = "rbind") %dopar% {
      gen_surv_time(out, sj,N, nn)
    }
    pp <- gen_surv_pp(out, time, sj) %>% array(dim = dim(time))
    cbind(time, pp)
  }
  sim_data1[[ii]] <- stk_tt
  cat("\nelapsed time to simulate item", ii, "\n")
  print(proc.time() - start_time)
}

for (ii in 1:I) {
  pp1 = sim_data1[[ii]][, (N+1): (2*N)]
  for (nn in 1:num_iter) {
    mll1[nn, ii] = MLmetrics::LogLoss(pp1[nn, ], mi[ii, ])
    mauc1[nn, ii] = MLmetrics::AUC(pp1[nn, ], mi[ii, ])
    }
  }

time1 = sim_data1[[ii]][, 1:N]
summary(mauc1[,1])
summary(sim_data1[[ii]][, 1:10])
#+end_src

#+name: gen_postpred
#+begin_src R :tangle R/postcheck.R
source("R/Renviron.R")
source("R/load-outputs.R")
source("R/wrap_param.R")

sim_data <- list()
len = diff(sj)
num_chain = 1
num_iter = min(unlist(lapply(mydf,  nrow)))
mll  <- mauc <- matrix(0, num_iter, I)

for(ii in 1:I){
start_time <- proc.time()
  stk_tt <- foreach(chain = 1:num_chain, .combine = "rbind") %do% {
    simtp <- art::rcpp_gen_surv(lambda, theta, z, w, gamma, param, ii)
    cbind(simtp$time, simtp$pp)
    }
  sim_data[[ii]] <- stk_tt
  pp = simtp$pp
  for (nn in 1:num_iter) {
    mll[nn, ii] = MLmetrics::LogLoss(pp[nn, ], mi[ii, ])
    mauc[nn, ii] = MLmetrics::AUC(pp[nn, ], mi[ii, ])
    }
  cat("\nelapsed time to simulate item", ii, "\n")
  print(proc.time() - start_time)
}
#+end_src

#+name: viz_postpred_metric
#+begin_src R :tangle R/postcheck.R
dll = t(mll)
dauc = t(mauc)
colnames(mauc) = colnames(mll) = row.names(mi) = 1:I
## row.names(dauc) = row.names(dll) = colnames(mi) = 1:num_iter
dauc = reshape2::melt(mauc)
dll <- reshape2::melt(mll)
## mi_long <- reshape2::melt(t(mi))
dd = plyr::join(dll, dauc, by = c("Var1","Var2"))
names(dd) = c("iter","item","LogLoss","AUC")

ll_boxp <- ggplot(dd, aes(x=item,y=LogLoss,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(0, 1)

auc_boxp <- ggplot(dd, aes(x=item,y=AUC,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(0, 1)

pdf(paste0(out_dir,"figure/sim_cmetrics.pdf"))
print(ll_boxp)
print(auc_boxp)
dev.off()
#+end_src

#+RESULTS:
: null device
:           1

#+begin_src R :results none
out_dir="chessB_no_latent_ncut5_zero_beta_noinfo_lc2/"
num_chain = 1; HAS_REF = 0
source("R/postcheck.R")

## fname = paste0(out_dir,"dll_auc.RData")
## if (file.exists(fname)) load(file = fname) else source("R/test_simcode.R")

ddd = dd # baseline to ddd

lout = NULL
lout=c(lout,"chessB_pn_ncut5_zero_beta_noinfo_lc2/")

## fname = paste0(out_dir,"dll_auc.RData")
## if (file.exists(fname)) load(file = fname) else source("R/test_simcode.R")

num_chain <- 1
HAS_REF <- 0

for (out_dir in lout) {

source("R/postcheck.R")
ddd$dLogLoss = ddd$LogLoss - dd$LogLoss
ddd$dAUC = ddd$AUC - dd$AUC

## logloss (smaller, better)
ll_boxp <- ggplot(ddd, aes(x=item,y=dLogLoss,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(-0.25, 0.25)

## AUC (larger, better)
auc_boxp <- ggplot(ddd, aes(x=item,y=dAUC,fill=factor(item))) +
  geom_boxplot() + theme(legend.position = "none") + ylim(-0.25, 0.25)

pdf(paste0(out_dir,"sim_dmetrics.pdf"))
print(ll_boxp)
print(auc_boxp)
dev.off()

cat("Plot(s) are saved in",out_dir,"\n")
cat("=================================\n")
}
#+end_src

* custom functions
#+begin_src R :tangle R/art-functions.R
fun_hazard_surv <- function(t, i, k, posm, cname, sj) {
  z <- posm[stringr::str_which(cname, paste0("z\\.[0-1]\\.", k, "\\.[1-2]"))] %>% matrix(ncol = 2)
  w <- rep(posm[stringr::str_which(cname, paste0("w\\.", i, "\\."))], 2) %>% matrix(ncol = 2)
  gamma <- posm[stringr::str_which(cname, paste0("gamma"))] %>% matrix(ncol = 2)
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\."))] %>% matrix(ncol = 2)
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\."))] %>% matrix(ncol = 2)
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.[0-1]\\.", i, "\\."))] %>% matrix(ncol = 2)

  G <- length(lambda[, 1])
  H <- sj[2:(G + 1)] - sj[1:G]

  seg <- 0
  for (g in 1:G) {
    seg <- seg + 1 * (t > sj[g])
  }
  out <- lambda[seg, 2] * exp(beta[, 2] + theta[, 2] - gamma[, 2] * sqrt(sum((z[, 2] - w[, 2])^2)))
  if (seg == 1) {
    for (c in 1:2) {
      out <- out * exp(
        -( (t - sj[seg]) * lambda[seg, c]) * exp(beta[, c] + theta[, c] - gamma[, c] * sqrt(sum((z[, c] - w[, c])^2)))
      )
    }
  } else {
    for (c in 1:2) {
      out <- out * exp(
        -( (t - sj[seg]) * lambda[seg, c] + sum(H[1:(seg - 1)] * lambda[1:(seg - 1), c])) * exp(beta[, c] + theta[, c] - gamma[, c] * sqrt(sum((z[, c] - w[, c])^2)))
      )
    }
  }
  names(out) <- NULL
  return(out)
}
#+end_src

#+begin_src R :tangle R/art-functions.R
fun_hazard_ick <- function(t, i, c, k, posm, cname, sj) {
  z <- posm[stringr::str_which(cname, paste0("z\\.", c, "\\.", k, "\\.[1-2]"))]
  w <- posm[stringr::str_which(cname, paste0("w\\.", i))]
  gamma <- posm[stringr::str_which(cname, paste0("gamma\\.", c))]
  beta <- posm[stringr::str_which(cname, paste0("beta\\.", i, "\\.", c))]
  theta <- posm[stringr::str_which(cname, paste0("theta\\.", k, "\\.", c))]
  lambda <- posm[stringr::str_which(cname, paste0("lambda\\.", c, "\\.", i, "\\."))]

  G <- length(lambda)
  seg <- 0 * t
  for (g in 1:G) {
    seg <- seg + 1 * (t > sj[g])
  }
  hazard <- lambda[seg] * exp(beta + theta - gamma * sum((z - w)^2))
  names(hazard) <- NULL
  return(hazard)
}
#+end_src

#+begin_src R :tangle R/art-functions.R
fun_accuracy_ick <- function(t, i, k, posm, cname, sj) {
  fun_hazard_ick(t, i, 1, k, posm, cname, sj) / (fun_hazard_ick(t, i, 1, k, posm, cname, sj) + fun_hazard_ick(t, i, 0, k, posm, cname, sj))
}
#+end_src

#+name: mdsplot
#+begin_src R :tangle R/art-functions.R
library(ggplot2)
library(ggrepel)

lsjmplot <- function(z, w, myname = NULL, xlim = NA, ylim = NA, lab = "Coordinate") {

  ## extract objects

  x <- rbind(z, w)
  idx <- rep("w", nrow(x))
  idx[seq_len(nrow(z))] <- "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position", 1:ndim, sep = "")

  padding <- 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[, 1])) * padding
    x2 <- max(abs(position[, 1])) * padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[, 2])) * padding
    y2 <- max(abs(position[, 2])) * padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme <- theme(
    axis.line = element_line(colour = "black"),
    ## panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    ## panel.border = element_blank(),
    panel.background = element_blank()
  )

  ## plot
  pp <- ggplot(position, aes(x = position1, y = position2, colour = idx)) +
    theme(text = element_text(size = 20)) +
    ## geom_point()+
    xlim(x1, x2) +
    ylim(y1, y2) +
    xlab(paste(lab, " 1", sep = "")) +
    ylab(paste(lab, " 2", sep = "")) +
    ## xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype = 2) +
    geom_vline(xintercept = 0, color = "gray70", linetype = 2)
  ##  pp = pp + geom_text_repel(label=rownames(position), segment.color = "grey50", size=6)
  if (!is.null(myname)) {
    pp <- pp + geom_text(
      label = myname,
      ## segment.color = "grey50",
      check_overlap = FALSE, show.legend = FALSE, size = 2
    )
  } else {
    pp <- pp + geom_point()
  }
  pp + mytheme
}
#+end_src

#+begin_src R :tangle R/art-functions.R
library(ggplot2)
library(ggrepel)

cl_lsjmplot <- function(z, w, cl_z, cl_w, myname = NULL, xlim = NA, ylim = NA, lab = "Coordinate") {

  ## extract objects
  n_z <- nrow(z)
  n_w <- nrow(w)

  cl <- rbind(cl_z, cl_w)[[1]]
  cl <- as.factor(cl)
  cl_z <- cl[1:n_z]
  cl_w <- cl[(n_z + 1):length(cl)]
  x <- rbind(z, w)
  idx <- rep("w", nrow(x))
  idx[seq_len(nrow(z))] <- "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position", 1:ndim, sep = "")

  padding <- 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[, 1])) * padding
    x2 <- max(abs(position[, 1])) * padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[, 2])) * padding
    y2 <- max(abs(position[, 2])) * padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme <- theme(
    axis.line = element_line(colour = "black"),
    ## panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    ## panel.border = element_blank(),
    panel.background = element_blank()
  )

  position$idx <- idx

  ## plot
  pp <- ggplot(subset(position, idx == "z"), aes(x = position1, y = position2, colour = cl_z)) +
    ## theme(text=element_text(size=20)) +
    ## geom_point()+
    xlim(x1, x2) +
    ylim(y1, y2) +
    xlab(paste(lab, " 1", sep = "")) +
    ylab(paste(lab, " 2", sep = "")) +
    ## xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype = 2) +
    geom_vline(xintercept = 0, color = "gray70", linetype = 2) +
    mytheme
  pp <- pp + geom_point()
  pp +
    geom_text(
      data = subset(position, idx == "w"), aes(x = position1, y = position2, label = (1:n_w), colour = cl_w),
      ## segment.color = "grey50",
      check_overlap = FALSE, show.legend = FALSE, size = 4
    )
}
#+end_src

#+begin_src R :tangle R/art-functions.R
find_xstar <- function(df) {
  num_samples <- nrow(df)

  z0dx <- grepl("^z\\.0\\.", colnames(df))
  z1dx <- grepl("^z\\.1\\.", colnames(df))
  w0dx <- grepl("^w\\.0\\.", colnames(df))
  w1dx <- grepl("^w\\.1\\.", colnames(df))
  adx <- z0dx | z1dx | w0dx | w1dx

  mlp_ <- max(df$lp_)
  star <- min(which.max(df$lp_))
  lpos <- df[, adx]
  Xstar <- list()
  Xstar$z.0 <- matrix(unlist(df[star, z0dx]), byrow = T, ncol = 2)
  if (sum(z1dx) == 0) {
    Xstar$z.1 <- NULL
  } else {
    Xstar$z.1 <- matrix(unlist(df[star, z1dx]), byrow = T, ncol = 2)
  }
  if (sum(w1dx) == 0) {
    Xstar$w.1 <- NULL
  } else {
    Xstar$w.1 <- matrix(unlist(df[star, w1dx]), byrow = T, ncol = 2)
  }
  Xstar$w.0 <- matrix(unlist(df[star, w0dx]), byrow = T, ncol = 2)
  return(list(lp_ = mlp_, Xstar = Xstar))
}
#+end_src

#+begin_src R :tangle R/art-functions.R
find_xstar_inlist <- function(mydf) {
  num_chain <- length(mydf)
  mlp <- -Inf
  for (i in 1:num_chain) {
    slist <- find_xstar(mydf[[i]])
    if (slist$lp_ > mlp) Xstar <- slist$Xstar
  }
  return(Xstar)
}
#+end_src

#+begin_src R :tangle R/art-functions.R
do_procrustes <- function(Xstar, mydf, is_list = FALSE, translation = TRUE, scale = FALSE, reflect = TRUE) {
  posm <- 0
  if (is_list == TRUE) {
    num_chain <- length(mydf)
  } else {
    num_chain <- 1
  }
  for (i in 1:num_chain) {
    if (is_list == TRUE) {
      df <- mydf[[i]]
    } else {
      df <- mydf
    }

    num_samples <- nrow(df)

    z0dx <- grepl("^z\\.0\\.", colnames(df))
    z1dx <- grepl("^z\\.1\\.", colnames(df))
    wdx <- grepl("^w", colnames(df))
    adx <- z0dx | z1dx | wdx
    N <- sum(z0dx) / 2
    nall <- sum(adx) / 2

    mlp_ <- max(df$lp_)
    star <- min(which.max(df$lp_))
    lpos <- df[, adx]

    ## mm = list()
    ## for (k in 1:num_samples) {
    ##   X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
    ##   ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation)$X.new #MCMCpack
    ##   mm[[k]] = vegan::procrustes(X, Xstar, scale = scale)$Yrot #vegan
    ##   df[k,adx] = mm[[k]] %>% t() %>% c()
    ## }

    mm <- foreach(k = 1:num_samples) %dopar% {
      ## X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
      ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation = scale)$X.new #MCMCpack
      ## vegan::procrustes(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2) ), scale = scale)$Yrot #vegan
      shapes::procOPA(Xstar, t(matrix(unlist(lpos[k, ]), nrow = 2)), scale = scale, reflect = reflect)$Bhat # shapes
    }
    tmm <- lapply(mm, t)
    df[, adx] <- t(matrix(unlist(tmm), nrow = sum(adx)))


    posm <- posm + Reduce("+", mm) / num_samples
    if (is_list == TRUE) {
      mydf[[i]] <- df
    } else {
      mydf <- df
    }
  }

  posm <- posm / num_chain
  z0 <- posm[1:N, ]
  if (sum(z1dx) == 0) {
    w <- posm[-(1:N), ]
    z1 <- NULL
  } else {
    z1 <- posm[(N + 1):(2 * N), ]
    w <- posm[-(1:(2 * N)), ]
  }
  return(list(mydf = mydf, z0 = z0, z1 = z1, w = w))
}
#+end_src

** PISA2015
#+begin_src R :tangle R/art-functions.R
pullit <- function(info, cl) {
  it <- info %>% filter(Cluster_A == cl) # %>% dplyr::select(Item,Time)
  item <- pull(it, Item)
  time <- pull(it, Time)
  return(cbind(item, time))
}
#+end_src

#+begin_src R :tangle R/art-functions.R
tabulate_id = function(chrid) {
  ## reference table of charactor and numeric id
  chr = sort(unique(chrid))
  out = data.frame(chr = chr, num = seq_len(length(chr)))
  return(out)
}
to_numID = function(x, tab) {
  sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID = function(x, tab) {
  sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+end_src
** verbal
#+begin_src R :results none :tangle R/art-functions.R
tab_sj <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g >= m))
  }
  return(res)
}

tab_IY <- function(seg_g, G) {
  res <- NULL
  for (m in 0:(G - 1)) {
    res <- c(res, sum(seg_g == m))
  }
  return(res)
}
#+end_src

* lintr
#+begin_src emacs-lisp
(setq flycheck-checker-error-threshold 700)
#+end_src

#+begin_src sh :eval no :tangle .lintr
linters: with_defaults(line_length_linter(120), assignment_linter = NULL, object_name_linter = NULL)
#+end_src

* build R package
#+begin_src R
devtools::build('~/Dropbox/research/lsjm-art/lsjm-code/art')
#+end_src

#+begin_src R
install.packages("art_0.1.2.tar.gz", repos = NULL, type="source")
library(art)
#+end_src

*** function to get param from MCMC sample
#+begin_src R
srow = mylist[[1]][1, ]

## extract parameters from a row of MCMC samples
row_to_param <- function(srow, cname, I, N, G) {

  z <- srow[stringr::str_which(cname, paste0("^z\\."))]
  w <- srow[stringr::str_which(cname, paste0("^w\\."))]

  z = matrix(z, ncol = 2,  byrow = T)
  w = matrix(w, ncol = 2,  byrow = T)

  beta <- srow[stringr::str_which(cname, paste0("^beta\\."))]
  beta = matrix(beta, ncol = 2, byrow = T)

  theta <- srow[stringr::str_which(cname, paste0("^theta\\."))] ## (theta.k.0 theta.k.1)
  theta =  matrix(theta, ncol = 2, byrow = T)

  gamma <- srow[stringr::str_which(cname, paste0("gamma\\."))]

  lambda <- srow[stringr::str_which(cname, paste0("^lambda\\.[0-1]\\."))]
  lambda =  matrix(lambda, ncol = G, byrow = T)

  out <- list(z = z, w = w, beta = beta, theta = theta, gamma = gamma, lambda = lambda)

  return(out)

}

fun_segH = function(mt, sj) {

  seg = matrix(findInterval(mt, sj),  ncol = ncol(mt))

}

#+end_src
* Send to draft
#+begin_src sh
cp duolingo_pn_ncut5_zero_beta_noinfo_lc2/figure/sim_cmetrics.pdf ../lsjm-draft/figure/duolingo_pp_type.pdf
cp chessB_pn_ncut5_zero_beta_noinfo_lc2/figure/sim_cmetrics.pdf ../lsjm-draft/figure/chessB_pp_type.pdf
#+end_src

#+RESULTS:

* COMMENT Local Variables
# Local Variables:
# org-babel-default-header-args:R: ((:session . "*R-Org*") (:export . "both") (:results . "output replace"))
# eval: (flyspell-mode -1)
# eval: (spell-fu-mode -1)
# End:
