#+TITLE: LSJM Code for accuracy and RT
#+AUTHOR: Jonghyun Yun
#+EMAIL: jonghyun.yun@gmail.com

#+OPTIONS:   H:10 num:nil toc:nil \n:nil @:t ::t |:t ^:nil ^:{} -:t f:t *:t <:t ':nil -:nil pri:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

#+STARTUP: overview inlineimages logdone noindent

# #+SETUPFILE: ~/setup/my-theme-readtheorg.setup

#+PROPERTY: header-args :tangle
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args:R :session *LSJM-ART-R* :exports both :results value :noweb yes :eval never-export
* OrgMode :noexport:
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
# slide/none/fade/convex/concave/zoom
#+REVEAL_TRANS: slide
# solarized/black/white/league/sky/beige/simple/serif/blood/night/moon
#+REVEAL_THEME: solarized
#+REVEAL_HLEVEL: 1
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_EXTRA_CSS: ./my_reveal_style.css

#+HUGO_BASE_DIR: ~/website
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DATE_FORMAT: %Y-%m-%dT%T%z
#+HUGO_FRONT_MATTER_FORMAT: toml

#+HUGO_SECTION:
#+HUGO_BUNDLE:
#+HUGO_CATEGORIES:

#+HUGO_EXPORT_RMARKDOWN:

#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:t

#+HTML_MATHJAX: align: left tagside: right
#+HTML_MATHJAX: indent: 5em scale: 85
# MATHJAX font: MathJax TeX (default) Asana-Math Neo-Euler Latin-Modern Gyre-Pagella Gyre-Termes
# #+OPTIONS: tex:dvipng # use LaTeX to generate images for equations

#+HTML_HEAD:  <!-- Global site tag (gtag.js) - Google Analytics -->
#+HTML_HEAD:<script async src="https://www.googletagmanager.com/gtag/js?id=UA-128966866-1"></script>
#+HTML_HEAD:<script>
#+HTML_HEAD:  window.dataLayer = window.dataLayer || [];
#+HTML_HEAD:  function gtag(){dataLayer.push(arguments);}
#+HTML_HEAD:  gtag('js', new Date());
#+HTML_HEAD:
#+HTML_HEAD:  gtag('config', 'UA-128966866-1');
#+HTML_HEAD:</script>

# #+HTML_LINK_HOME: http://wweb.uta.edu/faculty/yunj/index.html
# #+HTML_LINK_UP: http://wweb.uta.edu/faculty/yunj/index.html

# https://scripter.co/latex-in-html/
#+macro: latex @@html:<span class="latex">L<sup>a</sup>T<sub>e</sub>X</span>@@

#+BEGIN_SRC emacs-lisp :eval no :results silent :exports none :tangle no
(setq org-html-htmlize-output-type 'css)
(setq org-html-htmlize-output-type 'inline-css)
#+END_SRC

#+begin_src emacs-lisp ::eval no results silent :exports none :tangle no
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
(add-hook 'org-mode-hook 'org-display-inline-images)
#+end_src

* LaTeX Header                                                     :noexport:
#+LATEX_CLASS: no-article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]

#+LATEX_COMPILER: xelatex

#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=0.7in,rmargin=0.7in}
#+LATEX_HEADER: \usepackage[stretch=10,babel=true]{microtype}
#+LATEX_HEADER: \usepackage{lmodern}
#+LATEX_HEADER: \setlength\parindent{0pt}\linespread{1.5}
#+LATEX_HEADER: \usepackage[mathbf=sym]{unicode-math}

#+LATEX_HEADER: \setmathfont{latinmodern-math.otf}
#+LATEX_HEADER: \setmathfont{XITS Math}[range={scr,bfscr}]

# #+LATEX_HEADER: \usepackage{amsmath}
# #+LATEX_HEADER: \usepackage{amsbsy}  %\boldsymbol %\pbm (faked bold)

#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage[unicode,colorlinks]{hyperref}
# #+LATEX_HEADER: \PassOptionsToPackage{unicode,colorlinks}{hyperref}

# #+LATEX_HEADER: \usepackage[unicode]{hyperref}
# #+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     colorlinks,
# #+LATEX_HEADER:     linkcolor={red!50!black},
# #+LATEX_HEADER:     citecolor={blue!50!black},
# #+LATEX_HEADER:     urlcolor={blue!80!black}}

* References
#+BEGIN_SRC emacs-lisp :eval yes :results silent :exports none
(require 'org-ref)
(require 'org-ref-citeproc)

(when (file-exists-p "readme.html")
  (delete-file "readme.html"))
(let ((org-export-before-parsing-hook '(orcp-citeproc)))
  (browse-url (org-html-export-to-html)))
#+End_src

#+BEGIN_SRC emacs-lisp :eval yes :results silent :exports none
  (add-hook 'org-export-before-parsing-hook 'orcp-citeproc)
#+END_SRC

#+Bibliography: ~/Zotero/myref.bib
#+PANDOC_OPTIONS: csl:~/Zotero/styles/chicago-author-date.csl

# #+LATEX_HEADER: \usepackage[backend=bibtex, style=numeric, natbib=true]{biblatex}
# #+LATEX_HEADER: \addbibresource{~/Zotero/myref.bib}
# #+LATEX_HEADER: \hypersetup{urlcolor=blue}
# #+LATEX_HEADER: \hypersetup{colorlinks,urlcolor=blue}
# #+LATEX_HEADER: \usepackage[authoryear]{natbib}

# #+LATEX_HEADER: \usepackage[natbib=true, backend=bibtex, maxbibnames=3, doi=false, isbn=false, style=nature]{biblatex}
#+LATEX_HEADER: \usepackage[natbib=true, backend=bibtex, maxbibnames=3, doi=false, isbn=false, style=nature]{biblatex}
#+LATEX_HEADER: \addbibresource{~/Zotero/myref.bib}
# #+LATEX_HEADER: \AtEveryBibitem{\clearfield{note}}
# #+LATEX_HEADER: \AtEveryBibitem{\clearfield{month}}
# #+LATEX_HEADER: \AtEveryBibitem{\clearfield{day}}
# #+LATEX_HEADER: \AtEveryBibitem{\clearfield{eprint}}

#+latex: \begingroup
#+latex: \renewcommand{\section}[2]{}%

# for html export with bib
# bibliographystyle:unsrt
# bibliography:~/Zotero/myref.bib

#+latex: \printbibliography[sorting=ydnt, heading=none, type=article] % for biblatex, comment out everything else
#+latex: \endgroup
* pseudo code
** Initialize
1. initialize $\lambda_{ic,g}$: I x N x 2
** Update \lambda
1. initialize $\log \lambda_{ic,g}$: I x N x 2
2. for each i,k,c
3. for each j
4. Draw $\lambda_{ic,g}^{* } \sim N(\log \lambda_{ic,j}^{(t)}, jump_{\lambda_{ic,j}})$
5. accept if $r > \log U(0,1)$
\begin{align*}
r = & \prod_{k=1}^{N}
\frac{
   (\lambda_{ic,g}^{* })^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{* }]}
   {(\lambda_{ic,g}^{t})^{I(Y_{ikc,g} = 1)} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{1}||z_{kc} - w_{i}||)\Lambda_{ic}(t)^{t}]} \\
& \times
  \frac{J(\lambda_{ic,g}^{(t)} -> \lambda_{ic,g}^{* })}{J(\lambda_{ic,g}^{* } -> \lambda_{ic,g}^{t})}
\frac{\pi(\lambda_{ic,g}^{* })}{\pi(\lambda_{ic,g}^{(t)})} \\
= & \prod_{k=1}^{N}
  \frac{(\lambda_{ic,g}^{* })^{I(Y_{ikc,j} = 1)}}{(\lambda_{ic,j}^{t})^{I(Y_{ikc,j} = 1)}} \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)(\sum_{m=1}^{j} H_{ic,m}(\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t}))] \\
& \times
\frac{\pi(\lambda_{ic,g}^{* })}{\pi(\lambda_{ic,g}^{(t)})}
 \frac{J(\lambda_{ic,g}^{(t)} -> \lambda_{ic,g}^{* })}{J(\lambda_{ic,g}^{* } -> \lambda_{ic,g}^{t})};
\end{align*}

if the event occurs before the $j$-th segment (g > j), then $\lambda_{ic,m}^{* } - \lambda_{ic,m}^{t} = 0$ for all $m=1,..,j$, so no contribution in the likelihood part.

** Update \theta
prior: $\theta_{kc} | \sigma^{2} ~ N(0,\sigma^2)$
1. initialize $\theta_{kc}$: N x 2
2. for each k,c
3. Draw $\theta_{kc}^{* } \sim N(\theta_{kc}^{(t)}, jump_{\theta_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{* } - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc}^{t} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{* })}
   \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})} \\
&=
\frac{\exp(\theta_{kc}^{* })}{\exp(\theta_{kc}^{t})}
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r = &
\frac{\pi(\theta_{kc}^{* })}{\pi(\theta_{kc}^{t})}
# \frac{J(\theta_{kc}^{t} -> \theta_{kc}^{* })}{J(\theta_{kc}^{* } -> \theta_{kc}^{t})}
(\exp(\theta_{kc}^{* }) - \exp(\theta_{kc}^{t}))
\exp[-\sum_{i=1}^{I} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)]
\end{align*}

** Update \beta
1. initialize $\beta_{ic}$: I x 2
2. for each i,c
3. Draw $\beta_{ic}^{* } \sim N(\\beta_{ic}^{(t)}, jump_{\beta_{ic}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r &= \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{* } + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic}^{t} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\beta_{ic}^{* })}{\pi(\beta_{ic}^{t})}
   \frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})} \\
&=
\frac{\exp(\beta_{kc}^{* })}{\exp(\beta_{kc}^{t})}
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
if $Y_{ikc} = 1$; otherwise
\begin{align*}
r =&
\frac{\pi(\beta_{kc}^{* })}{\pi(\beta_{kc}^{t})}
\frac{J(\beta_{kc}^{t} -> \beta_{kc}^{* })}{J(\beta_{kc}^{* } -> \beta_{kc}^{t})}
\exp[-\sum_{k=1}^{N} \Lambda_{ic}(t) \exp(\beta_{ic} - \gamma_{c}||z_{kc} - w_{i}||)(\exp(\beta_{kc}^{* }) - \exp(\beta_{kc}^{t}))]
\end{align*}
** Update z
1. initialize $z_{kc}$: N x 2
2. for each k,c
3. Draw $z_{ic}^{* } \sim N(\z_{kc}^{(t)}, jump_{z_{kc}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r =& \prod_{i=1}^{I} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{* } - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{t} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc}^{t} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{t})}
   \frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})} \\
=&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{t})}
# \frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}
\exp[-\gamma_{c}\sum_{i=1}^{I}
(||z_{kc}^{* } - w_{i}||-||z_{kc}^{t} - w_{i}||)]\\
&\times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t)\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{t} - w_{i}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r =&
\frac{\pi(z_{kc}^{* })}{\pi(z_{kc}^{t})}
\frac{J(z_{kc}^{t} -> z_{kc}^{* })}{J(z_{kc}^{* } -> z_{kc}^{t})}\\
& \times
   \exp[-\exp(\theta_{kc}) \sum_{i=1}^{I}\Lambda_{ic}(t)\exp(\beta_{ic}) \{\exp( - \gamma_{c}||z_{kc}^{* } - w_{i}||) - \exp(-\gamma_c||z_{kc}^{t} - w_{i}||)\}]
\end{align*}
** Update w
1. initialize $w_{i}$: I
2. for each I
3. Draw $w_{i}^{* } \sim N(\w_i^{(t)}, jump_{w_i})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r = &\prod_{c=1}^{2} \prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{* }||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}||z_{kc} - w_{i}^{t}||)\Lambda_{ic}(t) ]
}
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
   \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
# \frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[\sum_{c=1}^{2}\sum_{k=1}^{N} \gamma_{c}
(||z_{kc} - w_{i}^{* }||-||z_{kc} - w_{i}^{t}||)] \\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}
if $Y_{ikc} = 1$; otherwise

\begin{align*}
r & =
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}\\
& \times \exp[-\sum_{c=1}^{2}\Lambda_{ic}(t)\exp(\beta_{ic}) \sum_{k=1}^{N}\exp(\theta_{kc})\{ \exp(- \gamma_{c}||z_{kc} - w_{i}^{* }||) - \exp(-\gamma_c ||z_{kc} - w_{i}^{t}||)\}]
\end{align*}

** Update gamma
1. initialize $\gamma_{c}$: 2
2. for each c
3. Draw $\gamma_{c}^{* } \sim \log N(\log \gamma_{c}^{(t)}, jump_{\gamma_{c}})$
4. accept if $\log r < \log U(0,1)$
\begin{align*}
r = & \prod_{i=1}^{I}\prod_{k=1}^{N} \frac{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{* }||z_{kc} - w_{i}||)\Lambda_{ic}(t)]
}{
   \exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)
   \exp[-\exp(\beta_{ic} + \theta_{kc} - \gamma_{c}^{t}||z_{kc} - w_{i}||)\Lambda_{ic}(t) ]
}
\frac{\pi(\gamma_{c}^{* })}{\pi(\gamma_c^{t})}
   \frac{J(\gamma_{c}^{t} -> \gamma_{c}^{* })}{J(\gamma_{c}^{* } -> \gamma_{c}^{t})} \\
=&
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}
\exp[\sum_{i=1}^{I}\sum_{k=1}^{N} ||z_{kc} - w_{i}||(\gamma_{c}^{t}-\gamma_{c}^{* })]\\
& \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t)\exp(\beta_{ic} + \theta_{kc}) \{\exp( - \gamma_{c}^{* } ||z_{kc} - w_{i}||) -
 \exp( -\gamma_{c}^{t} ||z_{kc} - w_{i}||)\}]
\end{align*}

if $Y_{ikc} = 1$; otherwise
\begin{align*}
r = &
\frac{\pi(w_i^{* })}{\pi(w_i^{t})}
\frac{J(w_i^{t} -> w_i^{* })}{J(w_i^{* } -> w_i^{t})}\\
& \times \exp[-\sum_{i=1}^{I}\sum_{k=1}^{N}\Lambda_{ic}(t)\exp(\beta_{ic} + \theta_{kc}) \{\exp( - \gamma_{c}^{* } ||z_{kc} - w_{i}||) -
 \exp( -\gamma_{c}^{t} ||z_{kc} - w_{i}||)\}]
\end{align*}

** update \sigma^2
prior: $\sigma^{2} \sim inv-gamma(a,b)$
target: $\prod_{k,c} N(\theta_{kc}|0,\sigma^{2}) inv-gamma(\sigma^{2}|a,b)$ -> normal-(inv-gamma) model

1. initialize $\sigma^{2}$
2. Draw $\sigma^{2} \sim inv-Gamma(a + N, b + \sum_{k,c} \theta_{kc} / 2)$
* LSJM prior
\begin{aligned} \pi\left(\beta_{i}\right) & \sim \mathrm{N}\left(0, \tau_{\beta}^{2}\right) \\ \pi\left(\theta_{j} | \sigma^{2}\right) & \sim \mathrm{N}\left(0, \sigma^{2}\right) \\ \pi\left(\sigma^{2}\right) & \sim \operatorname{lnv}-\operatorname{Gamma}\left(a_{\sigma}, b_{\sigma}\right) \\ \pi\left(\mathbf{z}_{j}\right) & \sim \mathrm{MVN}_{d}\left(0, I_{d}\right) \\ \pi\left(\mathbf{w}_{i}\right) & \sim \mathrm{MVN}_{d}\left(0, I_{d}\right) \\ \log \pi(\gamma) & \sim \mathrm{N}\left(\mu_{\gamma}, \tau_{\gamma}^{2}\right) \end{aligned}

\[\sigma^{2}=4, \tau_{\beta}^{2}=1, a_{\sigma}=1, b_{\sigma}=1, \mu_{\gamma}=0, \text { and } \tau_{\gamma}^{2}=1\]
* PISA2015 data
** pisa2015/README.txt
   - pisa2015: math
#+BEGIN_SRC sh :results output
cat ../pisa2015/README.txt
#+END_SRC

** notebook
#+BEGIN_SRC R :results silent

## pick_person = 1:592
pick_person = 1:92
## pick_item = 1:21 # (first 3 is not item-related)
pick_item = 1:6

ncut = 5 # segment # in piecewise approximation
source('pisa-preprocess.R')
#+END_SRC


#+BEGIN_SRC R :results none :tangle pisa-preprocess.R
setwd("~/Dropbox/research/lsjm-art/lsjm-code")

source("Rfunction.R")

library(tidyverse)
load("data/pisa2015/US_PISA2015.rdata")
df = as_tibble(US_2015)
info = readr::read_csv("data/pisa2015/ItemTimeInfo.csv")
polytomous = c("DS519Q01C","DS498Q04C","DS465Q01C","CS635Q01S", "CS635Q04S","DS635Q05C","DS605Q04C","DS607Q03C","CS634Q02S", "CS645Q01S","DS657Q04C","DS629Q01C","CS637Q02S")
pdx = which(colnames(df) %in% polytomous)
pdx = c(pdx,pdx + 184)
df[,-pdx]
#+END_SRC

#+BEGIN_SRC R
dim(df)
length(unique(df$CNTSTUID)) # unique STUID?
#+END_SRC

#+begin_src R :tangle Rfunction.R
pullit = function(info,cl) {
it = info %>% filter(Cluster_A == cl)# %>% dplyr::select(Item,Time)
item = pull(it,Item)
time = pull(it,Time)
return(cbind(item,time))
}
#+end_src

#+begin_src R :tangle pisa-preprocess.R
di = df[,1:187]
dt = df[,c(1:3,188:371)]
its = pullit(info,"S01")
dt01 = dt %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,2])) %>% na.omit
di01 = di %>% dplyr::select(CNTSCHID,CNTSTUID,ST004D01T,any_of(its[,1])) %>% filter(CNTSTUID %in% dt01$CNTSTUID)

di01[di01 == 2] = 1
di01[is.na(di01)] = 999

di01 = di01[pick_person,pick_item]
dt01 = dt01[pick_person,pick_item]
#+end_src

** boxplot :ARCHIVE:
#+BEGIN_SRC R
library(reshape2)

di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

identical(di01_long[,1],di01_long[,1])
identical(di01_long[,2],di01_long[,2])
identical(di01_long[,3],di01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")
#+END_SRC

#+BEGIN_SRC R :results value
dit01 %>% group_by(item) %>% summarise(F = sum(res == 0), T = sum(res == 1), mis = sum(res == 99))
#+END_SRC

#+BEGIN_SRC R
rt_boxp <- ggplot(dit01, aes(x=factor(res),y=time,fill=factor(res)))+
  geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
logrt_boxp <- ggplot(dit01, aes(x=factor(res),y=log(time),fill=factor(res)))+
  geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
#+END_SRC

[[file:figure/RTs_S01.pdf]]

#+BEGIN_SRC R
pdf("figure/RTs_S01.pdf")
rt_boxp
logrt_boxp
dev.off(which = dev.cur())
#+END_SRC
** numeric ID
#+BEGIN_SRC R :tangle Rfunction.R
tabulate_id = function(chrid) {
## reference table of charactor and numeric id
  chr = sort(unique(chrid))
  out = data.frame(chr = chr, num = 1:length(chr))
  return(out)
}
to_numID = function(x, tab) {
    sapply(x, function(x) tab$num[which(tab$chr == x)])
}

to_chrID = function(x, tab) {
    sapply(x, function(x) tab$chr[which(tab$num == x)])
}
#+END_SRC

#+begin_src R :tangle pisa-preprocess.R
tab_schid = tabulate_id(di01$CNTSCHID)
tab_stuid = tabulate_id(di01$CNTSTUID)
tab_item = tabulate_id(colnames(di01)[-(1:3)])

di01$schid = to_numID(dt01$CNTSCHID, tab_schid)
di01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
dt01$schid = to_numID(dt01$CNTSCHID, tab_schid)
dt01$stuid = to_numID(dt01$CNTSTUID, tab_stuid)
#+END_SRC

#+begin_src R :tangle pisa-preprocess.R
##di01_long <- melt(di01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))
##dt01_long <- melt(dt01, id.vars=c("CNTSCHID","CNTSTUID","ST004D01T"))

di01_long = di01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)
dt01_long = dt01 %>% dplyr::select(- CNTSCHID, - CNTSTUID)

di01_long <- reshape2::melt(di01_long, id.vars=c("schid","stuid","ST004D01T"))
dt01_long <- reshape2::melt(dt01_long, id.vars=c("schid","stuid","ST004D01T"))

identical(di01_long[,1],dt01_long[,1])
identical(di01_long[,2],dt01_long[,2])
identical(di01_long[,3],dt01_long[,3])

dit01 = cbind(di01_long, dt01_long[,5])
colnames(dit01)[4:6] = c("item","res","time")

dit01$item = to_numID(dit01$item, tab_item)
#+END_SRC

** knot selection
#+begin_src R :tangle pisa-preprocess.R
sdi01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()
sdt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix()

time = pull(dit01,time)
## ncut = 5

## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
N = ncol(sdi01)
msj = array(0,dim=c(N,ncut+1,2))
for (i in 1:N) {
  msj[i,1,1]  = msj[i,1,1] = 0
  msj[i,2:(ncut+1),2] = quantile(sdt01[sdi01[,i]==1,i], probs = pseq[-1]) %>% round()
  msj[i,2:(ncut+1),1] = quantile(sdt01[sdi01[,i]==0,i], probs = pseq[-1]) %>% round()
}
#+end_src
** survSplit
*** To export long format data for STAN
 #+begin_src R
 library(survival)
 status = !(dit01$res == 99)

 tmp <- survival::survSplit(formula = Surv(time, status) ~ ., data = dit01, cut = sj, episode ="seg_g") %>%
     mutate(seg = factor(tstart),
            len = time - tstart,
            status_T = 1 * (status == 1 & res == 1),
            status_F = 1 * (status == 1 & res == 0)
            ) %>%
     as_tibble
 to_stan = tmp %>% mutate(seg_g = seg_g - 1) %>% dplyr::select(stuid, item, time, seg_g, len, status_F, status_T)
 ## tmp %>% dplyr::select(res,status,status_T,status_F)
 #+end_src

 #+begin_src R
 ## data and fixed parameters
 I = nrow(tab_item)
 N = nrow(tab_stuid)
 C = 2

 L = nrow(to_stan)
 G = ncut

 with(to_stan,
 rstan::stan_rdump(c('I','N','C','L','G','stuid','item', 'G', 'seg_g','len','status_F','status_T'),"pisa_data.R"))

 #+end_src

*** To export short format data for STAN

   #+BEGIN_SRC R
   tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
   nitem = ncol(tt01)
   tt01 = data.frame(time = c(as.matrix(tt01)), status = 1)

   tmp <- survival::survSplit(formula = survival::Surv(time, status) ~ ., data = tt01, cut = sj, episode ="seg_g") %>%
       mutate(seg = factor(tstart),
              seg_g = seg_g - 1,
              len = time - tstart
              ) %>% filter(status == 1) %>%
       as_tibble
   mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
   mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
   mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
   mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
   mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
   #+END_SRC

   #+begin_src R
   ## data and fixed parameters
   I = nrow(mt)
   N = ncol(mt)
   C = 2

   G = ncut + 1

   rstan::stan_rdump(c('I','N','C','G', 'mseg','mlen', 'mh', 'mt','mi'),"pisa_short.R")

   #+end_src

*** to export short format data for C++
#+BEGIN_SRC R :tangle pisa-preprocess.R
   library(survival)
   tt01 = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
   ti01 = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID)
   nitem = ncol(tt01)

   tf01 = data.frame(time = c(as.matrix(tt01)), status = 1)
   tmp <- survSplit(formula = Surv(time, status) ~ ., data = tf01, cut = sj, episode ="seg_g") %>%
       mutate(seg = factor(tstart),
              seg_g = seg_g - 2,
              len = time - tstart
              ) %>% filter(status == 1) %>%
       as_tibble

   mseg = matrix(pull(tmp,seg_g),ncol=nitem) %>% t()
   mh = matrix(pull(tmp,len),ncol=nitem) %>% t()
   mlen = sj[2:(ncut+1)] - sj[1:(ncut)]
   mt = dt01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
   mi = di01 %>% dplyr::select(-ST004D01T,-schid,-stuid) %>% dplyr::select(- CNTSCHID, - CNTSTUID) %>% as.matrix %>% t()
   #+END_SRC

#+BEGIN_SRC R :tangle pisa-preprocess.R
   ## data and fixed parameters
   I = nrow(mt)
   N = ncol(mt)
   C = 2
   G = ncut # 
   write_csv(data.frame(I=I, N=N, C=C, G=G), "mvar.csv", col_names = FALSE)
   write_csv(as.data.frame(mlen),"mlen.csv", col_names = FALSE)
   write_csv(as.data.frame(mseg),"mseg.csv", col_names = FALSE)
   write_csv(as.data.frame(mh),"mh.csv", col_names = FALSE)
   write_csv(as.data.frame(mt),"mt.csv", col_names = FALSE)
   write_csv(as.data.frame(mi),"mi.csv", col_names = FALSE)
   #+end_src

   This is to export hyper-parameters and jumping rule
#+BEGIN_SRC R :tangle pisa-preprocess.R
   mvar = readr::read_csv("mvar.csv", col_names=FALSE) %>% as.matrix()
   I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

   ## lambda
   a_lambda = matrix(0.001,I,G)
   b_lambda = matrix(0.001,I,G)
   jump_lambda = matrix(1.0,I,G)

   mu_beta = matrix(0.0,I,2)
   sigma_beta = matrix(1.0,I,2)
   jump_beta = matrix(0.25,I,2)

   mu_theta = matrix(0.0,N,2)
   sigma_theta = matrix(1.0,N,2)
   jump_theta = matrix(1.0,N,2)

   a_sigma = 1.0
   b_sigma = 1.0

   mu_gamma = matrix(0.0,1,2)
   sigma_gamma = matrix(1.0,1,2)
   jump_gamma = matrix(1.0,1,2)

   mu_z = matrix(0.0,N,2)
   sigma_z = matrix(1.0,N,2)
   jump_z = matrix(1.0,N,2)

   mu_w = matrix(0.0,I,2)
   sigma_w = matrix(1.0,I,2)
   jump_w = matrix(0.1,I,2)
   #+END_SRC

   #+RESULTS:
   | 0.5 | 0.5 |
   | 0.5 | 0.5 |
   | 0.5 | 0.5 |

#+BEGIN_SRC R :tangle pisa-preprocess.R
write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"pj_lambda.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"pj_beta.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"pj_theta.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"pj_sigma.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"pj_gamma.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"pj_z.csv", col_names = FALSE)
write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"pj_w.csv", col_names = FALSE)
   #+END_SRC

   #+RESULTS:
   |   0 |   0 |
   |   0 |   0 |
   |   0 |   0 |
   |   1 |   1 |
   |   1 |   1 |
   |   1 |   1 |
   | 0.5 | 0.5 |
   | 0.5 | 0.5 |
   | 0.5 | 0.5 |

** not used
#+BEGIN_SRC R
item <- pull(info, Item)
time <- pull(info, Time)
cname <- colnames(df)
#+END_SRC

#+begin_src R
item = item[info$Cluster_A == "S01"]
time = time[info$Cluster_A == "S01"]
yi = df[,cname %in% item]
yt = df[,cname %in% time]

idx = !apply(yi,1,function(x) all(is.na(x)))
yi = yi[idx,]
yt = yt[idx,]
yi[is.na(yi)] = 99
yi[yi == 2] = 1
#+end_src


#+BEGIN_SRC R
boxplot(yt)
#+END_SRC


#+RESULTS:

* C++ MCMC output
#+begin_src sh :tangle run.sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=8
mkdir -p output
rm output/*
for v in {1..5}
do
./main parallel full latent no_gamma $v 1000 1000 10
done
#+end_src

#+begin_src sh :tangle run_more.sh
#!/usr/bin/env bash
export STAN_NUM_THREADS=10
for v in {4..5}
do
./main parallel $v 5000 5000 10
done
#+end_src

#+BEGIN_SRC R :results none
## Rcpp::sourceCpp("comprisk.cpp")
## install.packages("art_1.0.tar.gz", repos = NULL, type="source")
library(art)
#+END_SRC

#+BEGIN_SRC R :results none
library(coda)
library(tidyverse)
library(bayesplot)
library(foreach)
library(doParallel)
registerDoParallel(cores = detectCores() - 1)
source("Rfunction.R")
#+END_SRC

#+BEGIN_SRC R :results none
source('load-outputs.R')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
cat output/summary.csv
#+END_SRC

#+RESULTS:
| 1 | 0.459083 | 0.455333 | 0.588201 | 0.471168 |    0.658 | 0 | 1 |
| 2 | 0.463233 | 0.468083 |    0.588 | 0.471342 | 0.669833 | 0 | 1 |
| 3 | 0.460567 | 0.461583 | 0.591546 | 0.472677 |    0.661 | 0 | 1 |
| 4 | 0.462367 | 0.460167 | 0.587149 | 0.470935 |   0.6765 | 0 | 1 |
| 5 | 0.461083 |  0.46575 | 0.583962 | 0.473321 | 0.669667 | 0 | 1 |

** load outputs
#+begin_src R :results silent :tangle load-outputs.R
mvar = readr::read_csv("mvar.csv", col_names=F) %>% as.matrix()
I = mvar[1]
N = mvar[2]
G = mvar[4]

sj = readr::read_csv("mlen.csv",col_names=F) %>% as.matrix()
sj = c(0, cumsum(sj))
H = sj[2:(G+1)] - sj[1:G]

cnames = c(".chain", ".iteration")
for (c in 0:1) {
  for (i in 1:I) {
    for (g in 1:G) {
      cnames = c(cnames, paste0("lambda.",c,".",i,".",g))
    }}}

for (i in 1:I) {
  for (c in 0:1) {
    cnames = c(cnames, paste0("beta.",i,".",c))
  }}

for (k in 1:N) {
  for (c in 0:1) {
    cnames = c(cnames, paste0("theta.",k,".",c))
  }}

for(c in 0:1)
  for (k in 1:N) {
    for (d in 1:2) {
      cnames = c(cnames, paste0("z.",c,".",k,".",d))
    }}
for (i in 1:I) {
  for (d in 1:2) {
    cnames = c(cnames, paste0("w.",i,".",d))
  }}

for (c in 0:1) {
  cnames = c(cnames, paste0("gamma.",c))
}

cnames = c(cnames, "sigma", "lp_")
#+end_src

#+BEGIN_SRC R :results silent :tangle load-outputs.R
## mythin = 10
## mystart = 5001
## myend = 25000
mydf = list()
mylist = mcmc.list()
for (cid in 1:5) {
mydf[[cid]] = readr::read_csv(paste0("output/sample_chain",cid,".csv"), col_names=F) %>% as.data.frame()
colnames(mydf[[cid]]) = cnames
}

## mylist[[cid]] = mcmc(df, start = mystart, end = myend, thin = mythin)
#+END_SRC

 #+begin_src R :results none :tangle load-outputs.R
 Xstar = find_xstar_inlist(mydf)
 matched = do_procrustes(Xstar, mydf, is_list = TRUE)
 mydf = matched$mydf
 #+end_src

 #+BEGIN_SRC R :tangle load-outputs.R
  item = 1
  cname = names(mydf[[1]])
  mylist = mcmc.list()
  for (cid in 1:5) {
    for (c in 0:1) {
     for (k in 1:N) {
       z = mydf[[cid]][,str_which(cname, paste0("z\\.",c,"\\.",k,"\\.[1-2]"))]
       w = mydf[[cid]][,str_which(cname, paste0("w\\.",item,"\\."))]
       mydf[[cid]][[paste0("dist_z.",c,".",k,"_","w.",item)]] = sqrt(rowSums((z-2)^2))
     }
 }
    mylist[[cid]] = mcmc(mydf[[cid]])
  }
 #+END_SRC

 #+RESULTS:

** latent space
  [[file:figure/star_latent.pdf]]
  #+BEGIN_SRC R
   z0.star = Xstar[1:N,]
   z1.star = Xstar[(N+1):(2*N),]
   w.star = Xstar[(2*N + 1):nrow(Xstar),]
   xmin = min(z0.star[,1],z1.star[,1],w.star[,1])
   ymin = min(z0.star[,2],z1.star[,2],w.star[,2])
   xmax = max(z0.star[,1],z1.star[,1],w.star[,1])
   ymax = max(z0.star[,2],z1.star[,2],w.star[,2])

  myname = c(1:N,paste0("I.",1:I))
  pdf("figure/star_latent.pdf")
   lsjmplot(z0.star,w.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname)
   lsjmplot(z1.star,w.star,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname)
  dev.off(which = dev.cur())
  #+END_SRC

  #+RESULTS:
  : 1

 #+begin_src R :results silent :tangle load-outputs.R
 #+end_src

  [[file:figure/latent_position_plot_vegan.pdf]]
  #+begin_src R
  pdf("figure/latent_position_plot_vegan.pdf")

  z0 = matched$z0
  z1 = matched$z1
  w = matched$w %>% as.matrix()
  xmin = min(z0[,1],z1[,1],w[,1])
  ymin = min(z0[,2],z1[,2],w[,2])
  xmax = max(z0[,1],z1[,1],w[,1])
  ymax = max(z0[,2],z1[,2],w[,2])

  myname = c(1:N,paste0("I.",1:I))
  lsjmplot(z0,w,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname)
  lsjmplot(z1,w,xlim=c(xmin,xmax),ylim=c(ymin,ymax),myname)
  dev.off(which = dev.cur())
  #+end_src

  #+RESULTS:
  : 1

** trace plots
   [[file:figure/lambda_mcmc_interval_plot.pdf]]
   #+BEGIN_SRC R
   pdf("figure/lambda_mcmc_interval_plot.pdf")
   mcmc_intervals(
     mylist,
     regex_pars = "^lambda\\.0\\.1\\.",
     transformations = "log"
   )
   ##mcmc_areas(
   ##  lambda0.sam,
   ##  prob = 0.8, # 80% intervals
   ##  prob_outer = 0.99, # 99%
   ##  point_est = "mean"
   ##)

   mcmc_intervals(
     mylist,
     regex_pars = "^lambda\\.1\\.1\\.",
     transformations = "log"
   )
   dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

[[pdf:figure/z_pairs_plot.pdf]]
#+BEGIN_SRC R
pdf("figure/z_pairs_plot.pdf")
mcmc_pairs(mylist,
           regex_pars = "^z.[0-1]\\.1\\.",
           off_diag_args = list(size = 0.75))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

[[file:figure/beta_parcoord.pdf]]
#+BEGIN_SRC R
pdf("figure/beta_parcoord.pdf")
bayesplot::mcmc_parcoord(mylist,
           regex_pars = "^beta\\.[1-5]\\.",
           off_diag_args = list(size = 0.75))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

[[file:figure/theta_parcoord.pdf]]
#+BEGIN_SRC R
pdf("figure/theta_parcoord.pdf")
bayesplot::mcmc_parcoord(mylist,
           regex_pars = "^theta\\.[1-5]\\.",
           off_diag_args = list(size = 0.75))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

[[file:figure/lambda_parcoord.pdf]]
#+BEGIN_SRC R
pdf("figure/lambda_parcoord.pdf")
bayesplot::mcmc_parcoord(mylist,
           regex_pars = "^lambda\\.[0-1]\\.1\\.",
           transfomrations = "log",
           off_diag_args = list(size = 0.75))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

[[pdf:figure/w_parcoord_plot.pdf::1]]
#+BEGIN_SRC R
pdf("figure/w_parcoord_plot.pdf")
mcmc_parcoord(mylist,
           regex_pars = "^w.[1-5]\\.",
           off_diag_args = list(size = 0.75))
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

[[file:figure/dist_mcmc_trace_plot.pdf]]
#+BEGIN_SRC R
## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
pdf("figure/dist_mcmc_trace_plot.pdf")
p <- mcmc_trace(mylist,
                ##pars = c("lambda.0.1.1",  "lambda.0.1.2",  "lambda.0.1.3", "lambda.0.1.4"),
           regex_pars = "^dist_z.[0-1]\\.[0-4]_w",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
p <- mcmc_trace(mylist,
                ##pars = c("lambda.0.1.1",  "lambda.0.1.2",  "lambda.0.1.3", "lambda.0.1.4"),
           regex_pars = "^dist_z.[0-1]\\.[5-9]_w",
                ##transformations = "log",
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1


  [[file:figure/z_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
   ## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
   pdf("figure/z_mcmc_trace_plot.pdf")
   p <- mcmc_trace(mylist,
                   ##pars = c("lambda.0.1.1",  "lambda.0.1.2",  "lambda.0.1.3", "lambda.0.1.4"),
                   regex_pars = "^z.[0-1]\\.[1-2]\\.",
                   ##transformations = "log",
                   facet_args = list(nrow = 2, labeller = label_parsed))
   p + facet_text(size = 15)
   dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

  [[file:figure/w_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
   ## mcmc_intervals(mylist, pars=c("lambda.0.1.1")
   pdf("figure/w_mcmc_trace_plot.pdf")
   p <- mcmc_trace(mylist,
                   ##pars = c("lambda.0.1.1",  "lambda.0.1.2",  "lambda.0.1.3", "lambda.0.1.4"),
                   regex_pars = "^w\\.[0-9]\\.",
                   ##transformations = "log",
                   facet_args = list(nrow = 2, labeller = label_parsed))
   p + facet_text(size = 15)
   dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

   [[file:figure/lambda_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
   pdf("figure/lambda_mcmc_trace_plot.pdf")
   color_scheme_set("mix-blue-pink")
   for (item in 1:I) {
     p <- mcmc_trace(mylist,
                     regex_pars = paste0("^lambda\\.0\\.",item,"\\."),
                     transformations = "log",
                     facet_args = list(nrow = 2, labeller = label_parsed))
    print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ",item,".")))

     p <- mcmc_trace(mylist,
                     regex_pars = paste0("^lambda\\.1\\.",item,"\\."),
                     transformations = "log",
                     facet_args = list(nrow = 2, labeller = label_parsed))
     print(p <- p + facet_text(size = 15) + ggtitle(paste0("lambda.1 trace for item ",item,".")))
   }
   dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

   [[file:figure/beta_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
      pdf("figure/beta_mcmc_trace_plot.pdf")
            for (i in 1:I) {
      color_scheme_set("mix-blue-pink")
      p <- mcmc_trace(mylist,
                      regex_pars = paste0("^beta\\.",i,"\\."),
                      facet_args = list(nrow = 2, labeller = label_parsed))
      p + facet_text(size = 15)
               print(p <- p + facet_text(size = 15))
   }
      dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

   [[file:figure/theta_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
            pdf("figure/theta_mcmc_trace_plot.pdf")
            color_scheme_set("mix-blue-pink")
         for (k in 1:10) {
         p <- mcmc_trace(mylist,
                            regex_pars = paste0("^theta\\.",k,"\\."),
                            facet_args = list(nrow = 2, labeller = label_parsed))
            print(p <- p + facet_text(size = 15))
   }
            dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

   [[pdf:figure/lp_sigma_mcmc_trace_plot.pdf]]
   #+BEGIN_SRC R
   pdf("figure/lp_sigma_mcmc_trace_plot.pdf")
   color_scheme_set("mix-blue-pink")
   p <- mcmc_trace(mylist,
                   pars = c("sigma", "lp_"),
                   facet_args = list(nrow = 2, labeller = label_parsed))
   p + facet_text(size = 15)
   dev.off(which = dev.cur())
   #+END_SRC

   #+RESULTS:
   : 1

** output analysis

#+BEGIN_SRC R
tmp = foreach(v=1:5, .combine='rbind') %dopar% apply(mydf[[1]], 2, mean)
tmp = tmp[,1:( which( colnames(tmp) == "lp_") )]
posm = apply(tmp, 2, mean)
cname = names(posm)

param = getparam(posm,sj,i,k)

#+END_SRC

#+RESULTS:

[[file:figure/tradeoff.pdf]]
#+BEGIN_SRC R
## accuracy = foreach(k=1:N, .combine='rbind') %dopar% fun_accuracy_ick(t,i,k,posm,cname,sj)
pdf(paste0("figure/tradeoff.pdf"))
for (item in 1:I) {
time = 1:(sj[G] + 200)
accuracy = foreach(k=1:N, .combine='rbind') %dopar%
  {
    param = getparam(posm,sj,item,k)
    eval_accuracy(param, time)
    }

plotdf = reshape::melt(accuracy, id.vars=c("time"))
colnames(plotdf) = c("person", "time", "accuracy")

p = ggplot(data=plotdf, aes(x=time, y=accuracy, group=person)) +
  geom_line(aes(color=factor(person)), show.legend=FALSE) +
  # geom_line(group="3", col="red") +
  ##scale_colour_grey() +
  theme_bw() +
  ggtitle(paste0("Plot of speed-accuracy tradeoff for item ",item,"."))
print(p)
}
dev.off(which = dev.cur())

## system(paste0("open figure/tradeoff_", item, ".pdf")
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC R :tangle Rfunction.R
getparam = function(posm, sj, i, k) {
cname = names(posm)
z = posm[str_which(cname, paste0("z\\..\\.",k,"\\.[1-2]"))] %>% matrix(ncol = 2) %>% t()
w = posm[str_which(cname, paste0("w\\.",i,"\\."))]
gamma = posm[str_which(cname, paste0("gamma"))]
beta = posm[str_which(cname, paste0("beta\\.",i,"\\."))]
theta = posm[str_which(cname, paste0("theta\\.",k,"\\."))]
lambda = posm[str_which(cname, paste0("lambda\\..\\.",i,"\\."))] %>% matrix(ncol = 2) %>% t()
H = sj[2:(G+1)] - sj[1:G]
return(list(lambda=lambda,beta=beta,theta=theta,gamma=gamma,z=z,w=w,sj=sj,H=H))
}
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R
param = getparam(posm, sj, i, k)

ll = 0;
uu = 50

cumcicurve(param, 1, ll, uu, 50);
cumcifun(param, 1, ll, uu);
#+END_SRC

#+RESULTS:
| 0.0692147477235695 | 5.52919020821745e-08 | 0 |

#+BEGIN_SRC R
##CIF = foreach (k=1:50, .combine='rbind') %dopar% {
##integrand <- function(t) {
##  fun_hazard_surv(t,i,k,posm,cname,sj)
##}
##CIF_k = foreach(t=1:200, .combine='c') %dopar% {
##  integrate(integrand, lower = t-1, upper = t)$value
##}
##cumsum(CIF_k)
##}
#+END_SRC

[[pdf:figure/CIF.pdf::1]]
#+BEGIN_SRC R :results none
myN = 100
maxt = sj[G] + 250
num_seg = 100
time = seq(0, maxt, (maxt) / num_seg)

pdf(paste0("figure/CIF.pdf"))

for (item in 1:I) {

CIF_T = foreach (k=1:myN, .combine='rbind') %dopar% {
  c(0,cumcicurve(getparam(posm, sj, item, k), 1, 0, maxt, num_seg))
  }

CIF_F = foreach (k=1:myN, .combine='rbind') %dopar% {
  c(0,cumcicurve(getparam(posm, sj, item, k), 0, 0, maxt, num_seg))
}

CIF_T = data.frame(t(CIF_T), time)
CIF_F = data.frame(t(CIF_F), time)
plot_T <- reshape::melt(CIF_T, id.vars="time")
colnames(plot_T) = c("time", "person", "CIF")
p = ggplot(data=plot_T, aes(x=time, y=CIF, group=person)) +
  geom_line(aes(color=factor(person)), show.legend=FALSE) +
  # geom_line(group="3", col="red") +
  ##scale_colour_grey() +
  theme_bw() +
    ggtitle(paste0("Cumulative incidence function for TRUE response (item ",item,")."))
print(p)

plot_F <- reshape::melt(CIF_F, id.vars=c("time"))
colnames(plot_F) = c("time", "person", "CIF")
p = ggplot(data=plot_F, aes(x=time, y=CIF, group=person)) +
  geom_line(aes(color=factor(person)), show.legend=FALSE) +
  # geom_line(group="3", col="red") +
  ## scale_colour_grey() +
  theme_bw() +
    ggtitle(paste0("Cumulative incidence function for FALSE response (item ",item,")."))
  print (p)
  }
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC R
library(fda)
library(funFEM)
#library(fda.usc)
#+END_SRC

#+RESULTS:
| funFEM     |
| elasticnet |
| lars       |
| MASS       |
| fda        |
| Matrix     |
| ggrepel    |
| doParallel |
| parallel   |
| iterators  |
| foreach    |
| bayesplot  |
| forcats    |
| stringr    |
| dplyr      |
| purrr      |
| readr      |
| tidyr      |
| tibble     |
| ggplot2    |
| tidyverse  |
| coda       |
| art        |
| stats      |
| graphics   |
| grDevices  |
| datasets   |
| utils      |
| methods    |
| base       |

[[file:figure/functionDA.pdf]]
#+BEGIN_SRC R
tmp = as.matrix(CIF_T)
y = tmp[, -ncol(tmp)]
x = tmp[, ncol(tmp)]

 basis <- create.polygonal.basis(x)
## basis <- create.bspline.basis(c(0, max(x)), nbasis=50, norder=4) #below 0 occurs
#basis <- create.bspline.basis(c(0, max(x)), nbasis=20)
#basis <- create.fourier.basis(c(0, max(x)), nbasis=99)
#basis <- create.fourier.basis(c(0, max(x)), nbasis=27)
##basis = create.monomial.basis(c(0, max(x)), nbasis=25)
#basis = create.exponential.basis(c(0, max(x)), nbasis=9) # not work
fdobj <- smooth.basis(x,y,basis,fdnames=list("t", "Respondant", "CIF_T"))$fd

pdf("figure/functionDA.pdf")
plot(fdobj)
dev.off(which = dev.cur())
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC R
kran = 2:2
##res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)
# res = funFEM(fdobj,K=kran,model='AkjBk',crit="icl",init='hclust',lambda=0,disp=TRUE)
res = funFEM(fdobj,K=kran,model='AkjBk',init='hclust',lambda=0,disp=TRUE)

## plot(kran,res$plot$bic,type='b',xlab='K',main='ICL')
#+END_SRC

#+RESULTS:

[[file:figure/functional-clustering.pdf]]
#+begin_src R
pdf("figure/functional-clustering.pdf")
par(mfrow=c(1,2))
plot(fdobj,col=res$cls,lwd=2,lty=1)
fdmeans = fdobj;
fdmeans$coefs = t(res$prms$my)
plot(fdmeans,col=1:max(res$cls),lwd=2)
dev.off(which = dev.cur())
#+end_src

#+RESULTS:
: 1

** custom functions
#+BEGIN_SRC R :tangle Rfunction.R
fun_hazard_surv = function(t,i,k,posm,cname,sj) {
  z = posm[str_which(cname, paste0("z\\.[0-1]\\.",k,"\\.[1-2]"))] %>% matrix(ncol = 2)
  w = rep(posm[str_which(cname, paste0("w\\.",i,"\\."))], 2)  %>% matrix(ncol = 2)
  gamma = posm[str_which(cname, paste0("gamma"))] %>% matrix(ncol = 2)
  beta = posm[str_which(cname, paste0("beta\\.",i,"\\."))] %>% matrix(ncol = 2)
  theta = posm[str_which(cname, paste0("theta\\.",k,"\\."))] %>% matrix(ncol = 2)
  lambda = posm[str_which(cname, paste0("lambda\\.[0-1]\\.",i,"\\."))] %>% matrix(ncol = 2)

  G = length(lambda[,1])
  H = sj[2:(G+1)] - sj[1:G]

  seg = 0
  for (g in 1:G) {
    seg = seg + 1 * (t > sj[g])
    }
  out = lambda[seg,2] * exp(beta[,2] + theta[,2] - gamma[,2] * sqrt(sum((z[,2]-w[,2])^2)))
  if (seg == 1) {
    for (c in 1:2) {
      out = out * exp(
                    - ((t - sj[seg]) *lambda[seg,c]) * exp(beta[,c] + theta[,c] - gamma[,c] * sqrt( sum((z[,c]-w[,c])^2))))
    }
  } else {
    for (c in 1:2) {
      out = out * exp(
                    - ((t - sj[seg]) *lambda[seg,c] + sum(H[1:(seg-1)] * lambda[1:(seg-1),c])) * exp(beta[,c] + theta[,c] - gamma[,c] * sqrt(sum((z[,c]-w[,c])^2))))
    }
    }
    names(out) = NULL
    return(out)
  }
#+END_SRC

#+BEGIN_SRC R :tangle Rfunction.R
fun_hazard_ick = function(t,i,c,k,posm,cname,sj) {
z = posm[str_which(cname, paste0("z\\.",c,"\\.",k,"\\.[1-2]"))]
w = posm[str_which(cname, paste0("w\\.",i))]
gamma = posm[str_which(cname, paste0("gamma\\.",c))]
beta = posm[str_which(cname, paste0("beta\\.",i,"\\.",c))]
theta = posm[str_which(cname, paste0("theta\\.",k,"\\.",c))]
lambda = posm[str_which(cname, paste0("lambda\\.",c,"\\.",i,"\\."))]

G = length(lambda)
seg = 0 * t
for (g in 1:G)
  seg = seg + 1 * (t > sj[g])
hazard = lambda[seg] * exp(beta + theta - gamma * sum((z-w)^2))
names(hazard) = NULL
return(hazard)
}
#+END_SRC

#+BEGIN_SRC R :tangle Rfunction.R
fun_accuracy_ick = function(t,i,k,posm,cname,sj) {
fun_hazard_ick(t,i,1,k,posm,cname,sj) / (fun_hazard_ick(t,i,1,k,posm,cname,sj) + fun_hazard_ick(t,i,0,k,posm,cname,sj))
}
#+END_SRC

#+NAME: mdsplot
#+BEGIN_SRC R :tangle Rfunction.R
library(ggplot2)
library(ggrepel)

lsjmplot <- function( z, w, myname = NULL, xlim=NA, ylim=NA, lab = "Coordinate") {

  ## extract objects

  x = rbind(z,w)
  idx = rep("w", nrow(x))
  idx[1:nrow(z)] = "z"
  position <- as.data.frame(x)
  ndim <- dim(x)[2]

  colnames(position) <- paste("position",1:ndim,sep="")

  padding = 1.05
  if (any(is.na(xlim))) {
    x1 <- -max(abs(position[,1]))*padding
    x2 <- max(abs(position[,1]))*padding
  } else {
    x1 <- xlim[1]
    x2 <- xlim[2]
  }
  if (any(is.na(ylim))) {
    y1 <- -max(abs(position[,2]))*padding
    y2 <- max(abs(position[,2]))*padding
  } else {
    y1 <- ylim[1]
    y2 <- ylim[2]
  }

  mytheme = theme(axis.line = element_line(colour = "black"),
                  ##panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  ##panel.border = element_blank(),
                  panel.background = element_blank()
                  )

  ## plot
  pp = ggplot(position,aes(x=position1,y=position2,colour=idx)) +
    theme(text=element_text(size=20)) +
    ## geom_point()+
    xlim(x1,x2) + ylim(y1,y2) +
    xlab(paste(lab," 1",sep="")) + ylab(paste(lab," 2",sep="")) +
    ##xlab("Position 1") + ylab("Position 2") +
    geom_hline(yintercept = 0, color = "gray70", linetype=2) +
    geom_vline(xintercept = 0, color = "gray70", linetype=2)
  ##  pp = pp + geom_text_repel(label=rownames(position), segment.color = "grey50", size=6)
  if (!is.null(myname)) {
    pp = pp + geom_text(label=myname,
                        ## segment.color = "grey50",
                        check_overlap = FALSE, show.legend=FALSE,size = 2)
  } else pp = pp + geom_point()
  pp + mytheme
}
#+END_SRC

#+BEGIN_SRC R :tangle Rfunction.R
find_xstar = function(df) {
num_samples = nrow(df)

z0dx = grepl("^z.0", colnames(df))
z1dx = grepl("^z.1", colnames(df))
wdx = grepl("^w", colnames(df))
adx = z0dx | z1dx | wdx

mlp_ = max(df$lp_)
star = min(which.max(df$lp_))
lpos = df[,adx]
Xstar = matrix(unlist(lpos[star,]), ncol = 2)
return(list(lp_ = mlp_, Xstar=Xstar))}
#+END_SRC

#+BEGIN_SRC R :tangle Rfunction.R
find_xstar_inlist = function(mydf) {
num_chain = length(mydf)
mlp = -Inf
  for (i in 1:num_chain) {
  slist = find_xstar(mydf[[i]])
  if (slist$lp_ > mlp) Xstar = slist$Xstar
  }
return(Xstar)}
#+END_SRC

#+BEGIN_SRC R :tangle Rfunction.R
do_procrustes = function(Xstar, mydf, is_list = FALSE, translation = TRUE, dilation = FALSE, scale = FALSE, reflect = TRUE) {
  posm = 0
  if (is_list == TRUE) {
    num_chain = length(mydf)
  } else { num_chain = 1 }
  for (i in 1:num_chain) {
    if (is_list == TRUE) { df = mydf[[i]]
    } else { df = mydf }

    num_samples = nrow(df)

    z0dx = grepl("^z\\.0\\.", colnames(df))
    z1dx = grepl("^z\\.1\\.", colnames(df))
    wdx = grepl("^w", colnames(df))
    adx = z0dx | z1dx | wdx
    N = sum(z0dx) / 2
    nall = sum(adx)/2

    mlp_ = max(df$lp_)
    star = min(which.max(df$lp_))
    lpos = df[,adx]

    ## mm = list()
    ## for (k in 1:num_samples) {
    ##   X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
    ##   ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation)$X.new #MCMCpack
    ##   mm[[k]] = vegan::procrustes(X, Xstar, scale = scale)$Yrot #vegan
    ##   df[k,adx] = mm[[k]] %>% t() %>% c()
    ## }

    mm = foreach (k = 1:num_samples) %dopar% {
      ## X = matrix(unlist(lpos[k,]), nrow = 2) %>% t()
      ## mm[[k]] = MCMCpack::procrustes(X, Xstar, translation, dilation)$X.new #MCMCpack
      ## vegan::procrustes(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2) ), scale = scale)$Yrot #vegan
      shapes::procOPA(Xstar, t( matrix(unlist(lpos[k,]), nrow = 2)) , scale = scale, reflect = reflect)$Bhat #shapes
    }
    df[,adx] = t( matrix(unlist(mm), nrow = sum(adx)) )

    posm = posm + Reduce("+",mm) / num_samples
    if (is_list == TRUE) { mydf[[i]] = df
    } else { mydf = df }
  }

  posm = posm / num_chain
  z0= posm[1:N,]
  w = posm[-(1:(2*N)),]
  z1 = posm[(N + 1):(2*N),]
  return(list(mydf = mydf,  z0=z0, z1=z1, w=w))
}
#+END_SRC

#+RESULTS:

* opusIII-matrices-data.dat

#+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
num_person = 504 ## max 504: do not change
num_item = 5 ## max 35

setwd("~/Dropbox/research/lsjm-art/lsjm-code")

library(dplyr)

source("Rfunction.R")
source("opusIII-preprocess.R")
#+END_SRC

#+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
opusIII = readr::read_delim("data/opusIII-matrices-data.dat"," ")
df = as_tibble(opusIII[,-1])[,1:4] ## drop row names
name_item = unique(df$item)
pick_item = df$item %in% name_item[1:num_item]

df = df[pick_item, ]

pick_person = df$person %in% unique(df$person)[1:num_person]
df = df[pick_person,]

di = df[,-4]
dt = df[,-3]

nitem = length(unique(df$item))
nperson = length(unique(df$person))
#+END_SRC

** knot selection
#+begin_src R :tangle opusIII-preprocess.R
time = pull(dt,RT)
ncut = 5
## interval <- seq(from=0, to = max(time)+1,length.out = 8)
pseq =  seq(from=0, to = 1, length.out = ncut + 1)
sj = quantile(time, probs = pseq) %>% round()
sj[1] = 0; sj[length(sj)] = sj[length(sj)] + 1
#+end_src

#+RESULTS:
: 569

** survSplit
#+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
library(survival)
status = rep(1, nrow(dt))

tdf = data.frame(item = dt$item, person = dt$person, time = dt$RT, response = di$resp, status = 1)
tmp <- survSplit(formula = Surv(time, status) ~ ., data = tdf, cut = sj, episode ="seg_g") %>%
  mutate(seg = factor(tstart),
         seg_g = seg_g - 2,
         len = time - tstart
         ) %>% filter(status == 1) %>%
  as_tibble
#+END_SRC

#+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
item = pull(tmp, item)
person = pull(tmp, person)
seg_g = pull(tmp,seg_g)
H = pull(tmp,len)
   #+END_SRC

#+BEGIN_SRC R :tangle opusIII-preprocess.R
mi = reshape2::dcast(tmp %>% select(item, person, response), item ~ person)[,-1]
mt = reshape2::dcast(tmp %>% select(item, person, time), item ~ person)[,-1]
mNA = mi; mNA[!is.na(mNA)] = 1;  mNA[is.na(mNA)] = 0
mseg = reshape2::dcast(tmp %>% select(item, person, seg_g), item ~ person)[,-1]
mh = reshape2::dcast(tmp %>% select(item, person, len), item ~ person)[,-1]
mlen = sj[2:(ncut+1)] - sj[1:(ncut)]

mi[is.na(mi)] = -99
mt[is.na(mt)] = -99
mseg[is.na(mseg)] = -99
mh[is.na(mh)] = -99
#+END_SRC

#+RESULTS:
: -99

   #+begin_src R :results none :tangle opusIII-preprocess.R
   ## data and fixed parameters
   I = nrow(mt)
   N = ncol(mt)
   C = 2
   G = ncut #
   readr::write_csv(data.frame(I=I, N=N, C=C, G=G), "mvar.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mlen),"mlen.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mseg),"mseg.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mh),"mh.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mt),"mt.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mi),"mi.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(mNA),"mNA.csv", col_names = FALSE)
   #+end_src
** prior & jump
   This is to export hyper-parameters and jumping rule
   #+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
   mvar = readr::read_csv("mvar.csv", col_names=FALSE) %>% as.matrix()
   I = mvar[1,1]; N = mvar[1,2]; C = mvar[1,3]; G = mvar[1,4];

   ## lambda
   a_lambda = matrix(0.001,I,G)
   b_lambda = matrix(0.001,I,G)
   jump_lambda = matrix(1.0,I,G)

   mu_beta = matrix(0.0,I,2)
   sigma_beta = matrix(1.0,I,2)
   jump_beta = matrix(0.25,I,2)

   mu_theta = matrix(0.0,N,2)
   sigma_theta = matrix(1.0,N,2)
   jump_theta = matrix(1.0,N,2)

   a_sigma = 1.0
   b_sigma = 1.0

   mu_gamma = matrix(0.0,1,2)
   sigma_gamma = matrix(1.0,1,2)
   jump_gamma = matrix(1.0,1,2)

   mu_z = matrix(0.0,N,2)
   sigma_z = matrix(1.0,N,2)
   jump_z = matrix(1.0,N,2)

   mu_w = matrix(0.0,I,2)
   sigma_w = matrix(1.0,I,2)
   jump_w = matrix(0.1,I,2)
   #+END_SRC

   #+BEGIN_SRC R :results none :tangle opusIII-preprocess.R
   readr::write_csv(as.data.frame(rbind(a_lambda,b_lambda,jump_lambda)),"pj_lambda.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(mu_beta,sigma_beta,jump_beta)),"pj_beta.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(mu_theta,sigma_theta,jump_theta)),"pj_theta.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(a_sigma,b_sigma)),"pj_sigma.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(mu_gamma,sigma_gamma,jump_gamma)),"pj_gamma.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(mu_z,sigma_z,jump_z)),"pj_z.csv", col_names = FALSE)
   readr::write_csv(as.data.frame(rbind(mu_w,sigma_w,jump_w)),"pj_w.csv", col_names = FALSE)
   #+END_SRC

   #+RESULTS:

** boxplot
  #+BEGIN_SRC R :results value
  df %>% group_by(item) %>% summarise(F = sum(resp == 0), T = sum(resp == 1))
  #+END_SRC

  #+RESULTS:
  | MAT003 |  69 | 157 |
  | MAT007 |  55 | 171 |
  | MAT010 | 102 |  95 |
  | MAT013 | 152 |  45 |
  | MAT014 |  74 | 123 |

 [[file:figure/boxplot_ART.pdf]]
   #+BEGIN_SRC R
   pdf("figure/boxplot_ART.pdf")
   rt_boxp <- ggplot(df, aes(x=factor(resp),y=RT,fill=factor(resp)))+
     geom_boxplot() + labs(title="RT by accuracy") + facet_wrap(~item)
   logrt_boxp <- ggplot(df, aes(x=factor(resp),y=log(RT),fill=factor(resp)))+
     geom_boxplot() + labs(title="log RT by accuracy") + facet_wrap(~item)
   rt_boxp
   logrt_boxp
   dev.off(which = dev.cur())
  #+END_SRC

  #+RESULTS:
  : 2

  [[file:figure/RTs_S01.pdf]]

  #+BEGIN_SRC R
  pdf("figure/RTs_S01.pdf")
  #+END_SRC
* Local Variables
# Local Variables:
# eval: (flyspell-mode -1)
# End:
